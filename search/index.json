[{"content":" 本文是学习笔记，来自极客时间\n mysql\u0026gt; select * from T where ID=10； 这么一条查询语句是如何执行的呢？\nMySQL基础架构 Server层：\n 连接器：管理连接，权限认证 分析器：词法语法分析 查询缓存：命中则直接返回结果 优化器：执行计划生成，索引选择 执行器：操作引擎，返回结果 Server层涵盖了MySQL的大多数的核心服务功能，以及所有的内置函数  ","date":"2021-01-27T14:46:13Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg","permalink":"https://lllovol.com/how-a-sql-executes/","title":"基础架构：一条SQL更新语句是如何执行的？"},{"content":"背景 需要查询到一批部门以及子部门，最终拿到这些部门下的人员信息，我们能够进行的操作如下\n 通过部门的目录前缀（前缀树）的方式，能够查询到所有子部门 能够通过部门查询到这个部门（不包含子部门）的所有人员 已经添加索引  方法一 思路 找到每一个需要排除的部门，以及每一个排除的部门的子部门，然后分别查出来需要排除的人,最后通过stream的flatMap进行聚合\nreturn allDepartment.stream().flatMap(department -\u0026gt; { List\u0026lt;EmployeeDetail\u0026gt; allByDepartmentId = employeeRepo.findAllByDepartmentId(department.getDepartmentId()); return allByDepartmentId.stream(); }).collect(Collectors.toList());  耗费时间 30616ms\n方法二 思路 找到每一个需要排除的部门，将部门聚合，分别查询\n List\u0026lt;Department\u0026gt; allDepartment = findAllChildDepartments(byId.get()); return employeeRepo.findAllByDepartmentIdIsIn(allDepartment.stream().map(Department::getDepartmentId).collect(Collectors.toList())); List\u0026lt;EmployeeDetail\u0026gt; excludeEmployees = excludeDepartments.stream().flatMap(department -\u0026gt; serviceV2.findAllEmployeesByDepartmentId(department.getDepartmentId(), 1).stream()).collect(Collectors.toList()); 耗费时间 20057ms\n方法三 思路 将所有需要排除的部门聚合，统一查询\n @Override public List\u0026lt;EmployeeDetail\u0026gt; findAllEmployeesByDepartmentsId(Iterable\u0026lt;String\u0026gt; departmentIds) { return employeeRepo.findAllByDepartmentIdIsIn(departmentIds); }  List\u0026lt;Department\u0026gt; allExcludedDepartments = excludeDepartments.stream().flatMap(department -\u0026gt; serviceV2.findAllChildDepartments(department).stream()).collect(Collectors.toList()); List\u0026lt;EmployeeDetail\u0026gt; excludeEmployees = serviceV2.findAllEmployeesByDepartmentsId(allExcludedDepartments.stream().map(Department::getDepartmentId).collect(Collectors.toList())); 耗费时间 26058ms 时间耗费反而多了，因为对数据库的查询次数变多了\n方法四 思路 取出所有的排除的部门，构造出一个Set，然后通过filter取到需要的人员\n List\u0026lt;Department\u0026gt; excludeDepartments = serviceV2.findAllDepartmentsByName(exclude); log.info(\u0026quot;excludeDepartments:{}\u0026quot;, JSONObject.toJSONString(excludeDepartments.stream().map(Department::getPath).toArray(), true)); StopWatch started = StopWatch.createStarted(); List\u0026lt;Department\u0026gt; allExcludedDepartments = excludeDepartments.stream().flatMap(department -\u0026gt; serviceV2.findAllChildDepartments(department).stream()).collect(Collectors.toList()); log.info(\u0026quot;excludeDepartments size:{}\u0026quot;, allExcludedDepartments.size()); Set\u0026lt;String\u0026gt; excludeDepartmentIdSet = allExcludedDepartments.stream().map(Department::getDepartmentId).collect(Collectors.toSet()); List\u0026lt;EmployeeDetail\u0026gt; allEmployees = serviceV2.findAllEmployees(); log.debug(\u0026quot;all employee size:[{}]\u0026quot;, allEmployees.size()); allEmployees.removeIf(employeeDetail -\u0026gt; { String departmentId = employeeDetail.getDepartmentId(); return excludeDepartmentIdSet.contains(departmentId); }); log.debug(\u0026quot;filtered employee size:[{}]\u0026quot;, allEmployees.size()); started.stop(); log.debug(\u0026quot;cost time:[{}]ms\u0026quot;, started.getTime(TimeUnit.MILLISECONDS)); 耗时 14030ms\n方法五 思路 将方法四的removeIf换成流的处理方式\n allEmployees = allEmployees.stream().filter(employeeDetail -\u0026gt; { String departmentId = employeeDetail.getDepartmentId(); return !excludeDepartmentIdSet.contains(departmentId); }).collect(Collectors.toList()); 耗时 14104ms 几乎没有区别\n方法六 思路 将所有的部门聚合，直接从库中取出来目标数据\n List\u0026lt;Department\u0026gt; excludeDepartments = serviceV2.findAllDepartmentsByName(exclude); log.info(\u0026quot;excludeDepartments:{}\u0026quot;, JSONObject.toJSONString(excludeDepartments.stream().map(Department::getPath).toArray(), true)); StopWatch started = StopWatch.createStarted();s List\u0026lt;Department\u0026gt; allExcludedDepartments = excludeDepartments.stream().flatMap(department -\u0026gt; serviceV2.findAllChildDepartments(department).stream()).collect(Collectors.toList()); log.info(\u0026quot;excludeDepartments size:{}\u0026quot;, allExcludedDepartments.size()); Set\u0026lt;String\u0026gt; excludeDepartmentIdSet = allExcludedDepartments.stream().map(Department::getDepartmentId).collect(Collectors.toSet()); List\u0026lt;EmployeeDetail\u0026gt; allEmployees = serviceV2.findAllEmployeesNotInDepartmentIds(excludeDepartmentIdSet); log.debug(\u0026quot;all employee size:[{}]\u0026quot;, allEmployees.size()); log.debug(\u0026quot;filtered employee size:[{}]\u0026quot;, allEmployees.size()); started.stop(); log.debug(\u0026quot;cost time:[{}]ms\u0026quot;, started.getTime(TimeUnit.MILLISECONDS)); 耗时 8666ms\n结论 方法六最靠谱，在数据量越大的情况下，查询时间与数据量肯定呈现线性关系。在这种情况下，尽量减少IO的读取次数，这样的查询时间消耗最少\n","date":"2020-10-30T16:28:10Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/5.jpg","permalink":"https://lllovol.com/query-test/","title":"从零开始的查询优化"},{"content":"背景 由于业务需求将一些数据作为缓存存到Mongo库中，然后在优化这个缓存过程的时候，发现的一个坑。\n主要逻辑 原来的逻辑  获取所有数据 删除库中所有数据 将新数据全部存入库中  初步优化后的逻辑  获取所有数据 获取缓存库中所有数据 将两组数据做一个差值比较，筛选出来需要新建的 需要更新的 需要删除 三组数据 新增的数据进行新增 需要更新的数据进行更新 需要删除的数据进行删除  优化效果 从15000ms优化到230ms，由于数据量很大，但是其实并没有每次所有数据都有更新\n坑 看起来上面逻辑没有什么问题，但是在执行的时候，发现每一次更新数据的时候，实际在mongo数据库中并不是更新数据，而是从新新建了一条数据！这就导致同一条数据在更新之后出现了两次？？ 但是我明明已经将唯一的Id值作为主键了，为什么还是会被认为是新的呢？\nModel public class Example { @Id String exampleId; String name; } 看起来没有什么问题，但是这个主键获取的实际值长度特别长。导致在存入mongo库的时候，每一条新数据，都会使用系统生成的ObjectId的BSON。\n但是这个生成的id值并没有返回回来\n这就导致，使用JPA的save操作的时候，每一次都会判断成新数据。\n解决方式 查了很久，也看了JPA的部分源码，并没有设置主键长度的地方。最终解决方式，每一次更新的时候，将旧的数据清除，然后将更新的数据和新数据聚合，更新到数据库中去。\n","date":"2020-10-28T15:03:26Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg","permalink":"https://lllovol.com/mongo-bad/","title":"JavaJPA使用Mongo中的坑"},{"content":"Java内存管理  Java的内存管理机制\n 1. JMM java的内存模型\n1.1 主内存和工作内存 Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程有自己的工作内存（Working Memory），线程的工作内存中保存了该线程所使用到的变量的内存副本。 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量的传递都要通过主内存来完成（如下图 2-1所有）。\n1.2 执行引擎 执行引擎，就是一个运算器，能够识别输入的指令，并根据输入的指令执行一套特定的逻辑。\n1.3 主内存和工作内存的交互模型 Java 内存模型中定义了 8 种操作完成主内存与工作内存之间具体的交互协议，虚拟机实现时必须保证 每一种操作都是原子级、不可再分的。 这 8 种操作又可分为作用于主内存和作用于工作内存的操作。\n1.3.1 作用于主内存的操作  lock 作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定。 read 作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便 laod 时使用。 write 作用于主内存的变量，它把 store 操作从工作内存中得到的变量值存入到主内存变量中。  1.3.2 作用于工作内存的操作  load 作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。 use 作用于工作内存的变量，它把一个工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用的变量的值的字节码执行时会执行这个操作。 assign 作用于工作内存的变量，它把一个执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个变量赋值的字节码执行时执行这个操作。 store 作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的 write 操作。  2. JVM是如何划分内存的 垃圾回收机制 对象类型 对象擦除 基本运行原理 ","date":"2020-09-20T18:44:18Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg","permalink":"https://lllovol.com/java-basic/","title":"Java的部分基础机制"},{"content":"参考  说说为什么用了索引之后，查询就会变快？\n 个人理解  数据页和数据页之间，组成一个双向链表 每个数据页中的记录，是一个单向链表 每个数据页都根据内部的记录生成一个页目录（Page directory），如果是主键的话，可以在页目录中使用二分法快速定位 如果我们根据一个非主键、非索引列进行查询，那么需要遍历双向链表，找到所在的页；再遍历页内的单向链表；如果表内数据很大的话，这样的查询就会很慢  如果我们根据一个非主键、非索引列进行查询，那么需要遍历双向链表，找到所在的页；再遍历页内的单向链表；如果表内数据很大的话，这样的查询就会很慢。所以没有用索引的时候，需要遍历双向链表来定位对应的页，而有了索引，则可以通过一层层“目录”定位到对应的页上。\n为什么 B+ Tree 索引会降低新增、修改、删除的速度 B+ Tree 是一颗平衡树，如果对这颗树新增、修改、删除的话，会破坏它的原有结构； 我们在做数据新增、修改、删除的时候，需要花额外的时间去维护索引； 正因为这些额外的开销，导致索引会降低新增、修改、删除的速度。\n","date":"2020-09-20T18:28:53Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/7.jpg","permalink":"https://lllovol.com/why-index-faster/","title":"为什么加了索引后查询会变快"},{"content":"背景 从实习开始也算是工作了两年了，但是从来没有使用过事务，原因可能是由于一直用的是MongoDB，而不是mysql，但是事物这种\n事务的定义 可以将事物简单理解为，将一系列的操作整合为一个操作，这些操作只能全部都成功或者全部都执行失败。\n事物的四个特性ACID  原子性(Atomicity):操作这些整合的操作的时候，要当成一条操作来执行，要么全部执行，要么全部不执行，一旦其中一个操作执行失败，那么就需要将数据进行回滚，回到执行事务之前的状态。 一致性(Consistency):事务的执行是让数据从一个状态转换为另外一个状态，但是对于整个数据的完整性保持稳定（比如AB两个账户相互转账，原来的总数是20000元，无论操作多少次，总数都应该还是20000元） 隔离性(Isolation):事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。 持久性(Durability):一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。\u0026ndash;即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态  事务的好处与事务的实例  事务分析\n 事务提供了一种机制，可用来将一系列数据库更改归入一个逻辑操作。更改数据库后，所做的更改可以作为一个单元进行提交或取消。事务可确保遵循原子性、一致性、隔离性和持续性（ACID）这几种属性，以使数据能够正确地提交到数据库中。 使用事务机制的好处非常明显，例如银行转账之类的交易操作中，事务有着重要的作用。事务的成功取决于事务单元帐户相互依赖的操作行为是否能全部执行成功，只要有一个操作行为失败，整个事务将失败。例如：客户A和客户B的银行账户金额都是10000元人民币，客户A需要把自己帐户中的5000元人民币转到客户B的账户上。这个过程看似简单，实际上涉及了一系列的数据库操作，可以简单地视为两步基本操作，即从客户A帐户的金额中扣除5000元人民币，以及将客户B帐户中金额添加5000元人民币。假设第1步数据库操作成功，而第二步失败的话，将导致整个操作失败，并且客户A帐户金额将被扣除5000元人民币。事务机制可以避免此类情况，以保证整个操作的完成，如果某步操作出错，之前所作的数据库操作将全部失效。\n","date":"2020-09-18T17:27:51Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg","permalink":"https://lllovol.com/what-is-transaction/","title":"什么是事务？"},{"content":"背景 最近在做同步先关的工作，为了提升同步任务的处理效率，减少频繁的mongo数据库查询，因此需要将一些数据统一查询出来，在内存中进行处理。\n解决方式 在任务执行的之前，就需要将相关的数据查询出来，如何实现呢？使用一个@EventListener进行ApplicationReadyEvent时间的监听，就能在应用启动之后，进行相应的操作\n@EventListener(classes = {ApplicationReadyEvent.class}) public void initialMap() { if (CollectionUtils.isEmpty(ridMobileMap)) { List\u0026lt;UserRecord\u0026gt; all = entranceUserRecordRepo.findAll(); ridMobileMap = all.stream().filter(userRecord -\u0026gt; StringUtils.isNotEmpty(userRecord.getMobileNo())).collect(Collectors.toMap(UserRecord::getRid, UserRecord::getMobileNo)); } } More Application spring application，一般就是spring boot项目中的 Application这个类\n@SpringBootApplication @EnableConfigurationProperties @EnableAutoConfiguration(exclude = {DruidDataSourceAutoConfigure.class, DataSourceAutoConfiguration.class, RedisAutoConfiguration.class}) @EnableScheduling @EnableFeignClients(basePackages = {\u0026quot;\u0026quot;}) @EnableAspectJAutoProxy(proxyTargetClass = true) @EnableCircuitBreaker @EnableLdapRepositories public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Bean LdapTemplate getLdapTemplate(ContextSource contextSource) { LdapTemplate ldapTemplate = new LdapTemplate(contextSource); ldapTemplate.setIgnorePartialResultException(true); return ldapTemplate; } } 在这个当中，我们可以设置很多配置，比如排除掉一些自动配置、设置feignClient的扫描路径等等操作。\n Spring Boot详细生命周期介绍\n 自定义事件和监听 在不同的Service当中的时候，两个service的职责差别很大，但是A会调用B的方法，或者在A中个别服务完成之后，我们需要通知B中的个别方法开始执行。（观察者模式的一种实现）\n自定义event\npublic class ObjectALifecycleEvent extends ApplicationEvent { private ObjectA objectA; /** * Create a new ApplicationEvent. * * @param source the object on which the event initially occurred (never {@code null}) */ public ObjectALifecycleEvent(Object source) { super(source); if (source instanceof ObjectA) { this.objectA = (ObjectA) source; } } public ObjectA getObjectA() { return objectA; } } 自定义listener\n @Component @Slf4j @Data public class PolicyUpdater implements ApplicationListener\u0026lt;ObjectALifecycleEvent\u0026gt; { @Override public void onApplicationEvent(@NotNull ObjectALifecycleEvent event) { if (event instanceof ObjectABeforeScheduleEvent) { updatePolicyBeforeTaskSchedule((ObjectABeforeScheduleEvent) event); } if (event instanceof ObjectAFinishEvent) { updatePolicyWhenTaskFinish((ObjectAFinishEvent) event); } } } ","date":"2020-07-27T15:51:33Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg","permalink":"https://lllovol.com/spring14/","title":"SpringBoot开发中的一些小细节(十四）事件监听的使用"},{"content":"1. volatile volatile是轻量级的同步机制\n 保证可见性 不保证原子性 禁止指令重排  1.1 JMM内存模型之可见性 JMM（Java Memory Model） Java内存模型\n Java内存模型\n ","date":"2020-07-04T14:07:38Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/9.jpg","permalink":"https://lllovol.com/java-note/","title":"Java学习笔记（一）"},{"content":"什么是单例模式？ 在整个程序运行过程中只会实现一次的对象，例如Runtime类。\n需要满足的条件有以下几点：\n 构造器私有化 自行创建，并且用静态变量保存 向外提供这种实例 为了强调这是单例模式，我们可以使用final修饰  常见形式 饿汉式 懒汉式就是直接就实例化了，在程序运行的时候，直接创建，不管是否需要这个对象.不存在线程安全问题\n饿汉式-直接实例化饿汉式 public class Singleton(){ public static final INSTANCE=new Singleton(); private Singleton(){ // 构造器私有化 } } 饿汉式-枚举式 和上面的效果一模一样\npublic enum Singleton(){ INSTANCE, ; } 静态代码块饿汉式 这种情况和第一种效果也是一样的，但是如果需要配置的话，就需要使用这种方式了\npublic class Singleton(){ public static final INSTANCE; private String info; static { Properties pro=new Properties(); pro.load( Singleton.class.getClassLoader().getResourceAsStream(\u0026quot;src/下面的资源文件\u0026quot;)) INSTANCE=new Singleton(pro.getProperty(\u0026quot;info\u0026quot;)); } private Singleton(String info){ this.info=info; // 构造器私有化 } } 懒汉式 延迟创建，在需要的时候才创建对象\n线程不安全的懒汉式 这种情况就是会有线程安全的问题\npublic class Singleton(){ private static final INSTANCE; private Singleton(){ // 构造器私有化 } public Singleton getInstance(){ if(null==INSTANCE){ INSTANCE=new Singleton(); } return INSTANCE; } } 线程安全的懒汉式 加上锁，保证多线程的时候，不会有问题\npublic class Singleton(){ private static final INSTANCE; private Singleton(){ // 构造器私有化 } public Singleton getInstance(){ if(null==INSTANCE){ synchronized(Singleton.class){ INSTANCE=new Singleton(); } } return INSTANCE; } } 静态内部类形式（适用于多线程） 静态内部类只有在被使用的时候，才会开始实例化。因此这个也将是线程安全的，并且只有再被需要的时候才会被加载\npublic class Singleton{ private Singleton(){ // 构造器私有化 } private static class Inner{ private static final INSTANCE=new Singleton(); } public Singleton getInstance(){ return Inner.INSTANCE; } } ","date":"2020-07-04T00:34:38Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg","permalink":"https://lllovol.com/singleton-realization/","title":"单例模式的实现方式"},{"content":"背景 最近在做一个小工具的权限控制系统，由于是第一次做这方面的工作，而且对权限的控制会非常的详细，比如，需要细致到对每一个对象的控制。在前期有一些调研。\n想法 我大概实现的思路和设计\n 构建实体类，实现相应的数据存储化，用户可以设置相应的权限策略。权限设置，换一个说法就是主谓宾\u0026ndash;\u0026ldquo;谁\u0026rdquo; \u0026ldquo;能看/不能看\u0026rdquo; \u0026ldquo;什么东西\u0026rdquo;。将这个权限设置抽象为对象，并进行存储。 根据实体类解析用户保存的策略，使之生效。  说起来简单，做起来难。第一点设置权限，其实就是非常简单的单表查询维护。难点在于第二点，如何能让这个策略生效。按照我目前接触和掌握到的技术手段，主要的解决方式有下面几种：\n 写一个intercepor，拦截器。但是这个方式，只能处理请求的控制器和方法，控制不了具体的参数。这一点比较适合用来做整体的系统权限拦截，拦截接口。拦截控制的粒度比较粗糙。 在每一个业务逻辑中，分别添加拦截的逻辑，即每一个返回对象的接口，都需要查询和判断权限表。优点：思路简单。缺点：可维护性差，写完第一次之后，再维护就是噩梦。 使用Aspect，可以自定义切入的点，甚至能细化到拦截什么包什么类的什么方法等等。Perfectly，就是他了。  除了上面的Interceptor和Aspect，还有filter。这三者实际上都是对Aop的具体实现，都可以实现权限检查，日志记录等等的功能。都是对业务逻辑的提取，不同的是，使用的范围 规范、和深度不同。\n Filter、Interceptor、Aop实现与区别\n 实现 由于包含工作的涉密内容，真实实现的代码就不在此展示。而网上的Demo已经相当丰富。\n SpringBooot AOP的使用\n 其中实现权限控制的最简单的demo就是如下的代码\n@Aspect @Component @RequiredArgsConstructor @Slf4j public class AuthAspect { @Pointcut(\u0026quot;execution(public * com.company.group.auth.service.AuthService.list(..))\u0026quot;) public void pointCutForListObjective() { } /** * 对list的方法返回值进行拦截处理 */ @AfterReturning(pointcut = \u0026quot;pointCutForListObjective()\u0026quot;, returning = \u0026quot;okrResponses\u0026quot;) public void afterReturningListObjective(JoinPoint joinPoint, Object okrResponses) { // 这个地方就能够对返回值直接进行处理 } }  定义切点pointCut(),这个地方，就是定义一个我们需要切入的点，我们要进行拦截处理的地方。 对这个切点有很多处理的方式，实现真正的权限拦截控制逻辑  其他的点  对于用户的组织权限的控制，我们可以使用路径的方式来进行判断，类似于一个树，我们每一次，存储的时候，需要将用户所在的组织架构的路径进行存储。这样我们在进行权限判断的时候，就不想要每一次都从库中获取用户的组织架构信息了。 对于model的校验可以写注解来进行实现。这一点，以后会专门写一篇文章来进行分享 Npe问题可谓是开发过程中的一生之敌。在循环迭代过程中，不可以一遍迭代，一边删除list中的值。 使用JPA的时候可以使用 pageable 来直接进行分页，不用再写mongoTemplate这种CustomRepo   @Override public List\u0026lt;Department\u0026gt; listAuthDepartment(String departmentName) { if (Strings.isEmpty(departmentName)) { return Lists.newArrayList(); } Sort sort = new Sort(Sort.Direction.DESC, \u0026quot;name\u0026quot;); Pageable pageable = PageRequest.of( 0, 20, sort); // （当前页， 每页记录数， 排序方式） return departmentRepo.findAllByNameIsLike(departmentName, pageable); } ","date":"2020-05-12T15:04:26Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/3.jpg","permalink":"https://lllovol.com/spring13/","title":"SpringBoot开发中的一些小细节（十三）使用AOP实现权限系统"},{"content":"第1章 构造抽象过程  这一张主要学习的是有关计算过程的知识。   定义：计算过程是存在于计算机的里的一类抽象事物，主要操作一些被称之为\u0026quot;数据\u0026quot;的抽象事物。（就像Java中的各种类中的方法）\n   我们指挥这种过程的程序就像是巫师的巫术一样，使用一些诡秘而深奥的程序设计语言，通过符号表达式的形式精心编排而成，他们描述了我们希望相应的计算过程去完成的工作。\n  但是幸运的是，我们学习程序的危险性远远小于巫术。但是我们也必须像麻瓜一样，必须去学习、理解、预期我们所使用的咒语（程序）所带来的效果。程序里即使有一个小错误（bug or glitch）,也可能带来无法预料的后果。 真实的程序设计则需要极度细心，需要经验和智慧。\n  设计良好的计算系统就像设计良好的汽车或者核反应堆一样，具有某种模块化的设计，其中的各个部分都可以独立地构造、替换和排除错误。\n  书中所使用的Lisp方言Scheme，并不是一门主流语言，但是有一个非常重要的特征：计算过程的Lisp描述（过程）本身可以作为Lisp的数据来表示和操作。而不是现在很多威力强大的程序设计技术，都依赖于填平在 \u0026ldquo;被动的\u0026quot;数据和\u0026quot;主动的\u0026quot;过程之间的传统划分。\n  1.1 程序设计的基本元素 一个强有力的语言，不仅是一种指挥计算机执行任务的方式，它应该成为一种框架，是我们能够在其中组织自己有关计算过程的思想。 每一种强有力的语言都提供了三种机制：\n 基本表达式形式：用于表示语言所关心的最简单的个体。 组合的方法：通过它们可以从比较简单的东西出发构造出复合的元素。 抽象的方法：通过它们可以为复合对象命名，并将它们当做单元去操作。  用白话来解释，数据就是我们希望去操作的东西，而过程就是有关操作这些数据的规则描述。这样，任何强有力的程序设计语言都必须能够表达表述基本的数据和基本过程，还需要提供对过程和数据进行组合和抽象的方法。\n1.1.1 表达式  开始程序设计，最简单的方式就是打开计算机的终端，用键盘输入一个表达式，解释器的响应就是将它对这一个表达式的求值结果显示出来。 运算对象+运算符 ==\u0026gt;组合式 （组合式本身也可以作为运算对象参与其他组合式的运算（套娃递归）） 即使对于非常复杂的表达式 解释器也是按照同样的基本循环运作： 读入-\u0026gt;求值-\u0026gt;打印  1.1.2 命名和环境  程序设计中一个必不可少的方面，就是它需要提供一种通过名字去使用计算对象的方式。我们将名字标识符成为变量，它的值也就是它所对应的那个对象。 实际上，构造一个复杂的程序，也就是为了去一步步地创建出越来越复杂的计算性对象。（一个Lisp程序通常是由一大批相对简单的过程组成的） 我们可以将值和符号相关联，而后又能提取出这些纸，这意味着解释器必须维护这某种存储能力，以便保持有关 名字-值 对偶的轨迹。这种存储被称之为环境 （更加准确的说是全局环境，以后会看到，在一个计算过程中完全可能涉及到若干不同的环境（全局域和局部域，全局变量和局部变量））  1.1.3 组合式的求值 一个组合式的求值狐妖就是做两件事\n 求值该组合式的各个子表达式 将作为最左子表达式的（运算符）的值那个过程应用于相应的实际参数，所谓的实际参数就是其他子表达式（运算对象）的值。   一般而言，我们将递归看做一种处理层次性结构的（像树这样的对象）极强有力的技术。 \u0026ldquo;值向上穿行\u0026quot;形式的求值形式是一类更一般的计算过程的例子，这种计算过程被称为树形积累。 (define x 3)这种定义的情况，这算是一种特殊形式，作用是将符号x关联一个3的值，这并不是一个组合式。每一种特殊形式都有自己的求值规则。  1.1.4 复合过程 三个元素：\n 数和算数运算是基本的数据和过程 组合式的嵌套提供了一种组织起多个操作的方法 定义是一种受限的抽象手段，他为名字关联相应的值  这是一种威力更强大的抽象技术\n(define (square x) (* x x)) 上述代码就是是用复合过程的方式，定义了一个乘方，使用的时候只需要\n(square x) 和组合式的嵌套类似，复合过程也可以使用在其他的复合过程的定义当中\n( define (sum_of_squares x y) (+ (square x) (square y)) ) 例如上面的代码，就是一个平方和的复合过程实现,我们同样也能够将其实用到更加复杂的复合过程中去（无限套娃）。但是由于复合过程的构造太深，如果我们只是看到sum_of_squares这一层，就会感到疑惑？这个square究竟是像 \u0026ldquo;+\u0026rdquo;,\u0026quot;-\u0026rdquo;,\u0026quot;*\u0026rdquo;,\u0026quot;/\u0026quot; 一样直接做在解释器中呢？还是被定义成了一个复合过程呢？\n( define (f a) (sum_of_squares (+ a 1) (* a 2)) ) 1.1.5 过程应用的代换模型 在本章的例子当中，就比如上方的 平方和 例子 (f 5) 结果是136，我们是怎么去理解这个过程的呢？\n (f 5) 我们先取出f的体 (sum_of_squares (+ a 1) (* a 2)) 然后将实际参数替换这个表达式中的形参 (sum_of_squares (+ 5 1) (* 5 2)) 这样就转化为了两个简单表达式的运算 (sum_of_squares 6 10) 然后取出sum_of_square的体，同样进行计算 \u0026hellip; (+ 36 100) 得到结果  上面的这种模型，就是我们所说的代换模型。但是有两点需要注意：\n 代换的作用只是方便我们理解，而不是解释器的实际工作方式的具体描述。 在模拟复杂的科学研究现象的时候，我们也都是从最简单的模型开始的。  正则序和应用序  正则序：完全展开再进行规约（处理到了最后一步，再进行求值） 应用序：先求值参数而后应用（一边带入，一边处理）（可能会重复求值，浪费效率  条件表达式和谓词  条件表达式：根据不同的情况进行不同的处理（if-else、switch、cond等等） 谓词：返回 真 或者 假 的表达式。  ","date":"2020-01-17T11:13:47Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/5.jpg","permalink":"https://lllovol.com/sicp-chapter1.1/","title":"Structure and Interpretation of Computer Programs 读书笔记 Chapter 1 构造过程抽象 1.1 程序设计的基本元素"},{"content":"写在最前面 本文主要用来记录自己再工作之余阅读的这本书籍的读书笔记，在记录的同时，也会加入一些自己的一些思考与总结(括号中的内容)\n书籍目录架构  构造过程抽象 构造数据抽象 模块化、对象和状态 元语言抽象 寄存机器里的计算  序言部分笔记  程序员必须同时追求具体部分的完美和继承的适宜性。 每一个计算机程序都是现实中或者精神中的某一个过程的模型，通过人的头脑孵化出来。 如果艺术解释了我们的梦想，那么计算机就是以程序的名义执行着他们。 计算机是一位一丝不苟的\u0026quot;工匠\u0026quot;：它的程序必须正确，我们希望的所有东西，都必须表述得准确到每一点细节。 掌握强有力的组织技术，将会提升我们构造大型重要程序的能力。 计算机必须遵守物理定律。如果它们要快速执行，几个纳秒做一次状态转换，那么就必须在很短的距离内传导电子。 计算机永远都不够大也不够快。硬件技术的每一次突破都带来了更大规模的程序设计事业（同时也会带来更大规模的机会，机会总是无处不在的，但是能发现并抓住机会的人却没有那么多） Lisp语言有着非常简单的语法和语义，程序的语法分析可以看做一种很简单的工作。这样，语法分析技术对于Lisp程序几乎就没有价值，语言处理器的构造不会成为大型Lisp系统发展的变化和阻碍。最后，正是这种语法和语义的极端简单性，给所有的Lisp程序员都带来了负担和自由。任何规模的Lisp程序，除了那种寥寥几行的程序外，都包含考虑周到的各种功能。 发明并调整，调整恰当后再去发明！  前言部分笔记  计算机语言并不仅仅是一种让计算机去执行操作的方式，更重要的是，它是一种表述有关方法学的思想的新颖的形式化媒介。因此，程序必须写的能够供人阅读，偶尔地去供计算机执行。 能够对程序设计的风格要素有一种很好的审美观。……知道在什么时候哪些地方不需要去读，哪些东西不需要去理解。应该很有把握地去修改一个程序，同时又能保持原来作者的精神和风格。 计算机革命是关于我们如何去思考，以及如何去表达自己所思考的  ","date":"2020-01-13T15:22:58Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/10.jpg","permalink":"https://lllovol.com/sicp/","title":"Structure and Interpretation of Computer Programs 读书笔记 前言"},{"content":"前言 2020将近，已经很久没有更新blog，但是每天的工作笔记都还是有在记录，趁着马上就要过年，没有那么忙碌了，把自己19年Q4的工作中遇到的问题以及一些有用的方法整理一下~\n测试的必要性 在程序员的日常工作中，实际上真正在编写代码的时间，在整个工作时间中所占的比例其实很小的一部分。在写代码之前我们需要撰写需求文档，以及充足的思考，画出uml图（虽然很多经验丰富的大佬都没有画，但是那是建立在经验相当丰富的基础之上的）；在写完代码之后，这个项目需要发布与部署到测试环境，这就是CI/CD所负责的部分了；再之后，我们就需要测试我们的项目，是否能够完成需求文档中的需求，实现了相应的功能。 如果没有进行充分完整的测试，直接上线，这个项目差不多就是穿着皇帝的新衣在大街上到处晃荡了。同样，在互联网高速发展的今天，测试也不再仅仅是人工进行测试，自动化测试的演进又再一次的提升了团队的生产效率。这和敏捷开发、持续集成、持续部署、DevOps是一脉相承的。\n测试金字塔Test Pyramid  图来源于ThoughtWorks\n 在上方的金字塔当中，越往金字塔尖尖方向的，集成的程度越高，测试所耗费的时间就越长，但是需要的测试数目并没有那么多；与之相反，越往金字塔底层方向的，集成的程度就越低，测试所消耗的时间也更快，但是所需要测试的数量就会更加的庞大。\n UI Tests 项目的ui界面测试，这一层面的测试比较适合在上线之后进行冒烟测试，能够知道项目的整个流程到底是不是有问题。但是通常由于集成的程度太高，不能很快的定位问题。 Service Tests 这一层，用来测试服务是否可用，比如API测试。 Unit Tests 在代码层面进行测试，通常可以针对某一个类，某一个方法进行测试，能够快速定位问题。这个层级的层级能够保证一个系统的每一个基石都能够按照预期的那样进行工作。单元测试的数量应该在测试组合中远远多于其他类型的测试。  Junit 三段式结构 我们通常采用三段式的结构来撰写单元测试\n 构造部分。进行对象的构建、赋值等。 逻辑部分。运行方法逻辑对第一部分的数据对象进行运算。 断言部分。判断本次单元测试能否通过。  实例代码 要使用is（）方法首先需要导入hamcrest-library-1.3.jar和hamcrest-core-1.3.jar两个jar包\n依赖配置：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hamcrest\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hamcrest-library\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 简单的UT代码实现\nimport static org.hamcrest.core.Is.is; import static org.junit.Assert.assertThat; @RunWith(SpringRunner.class) @SpringBootTest @Slf4j public class ApplicationTests { @Test @Ignore public void contextLoads() { } public Boolean compare(String A, String B) { return A.equals(B); } @Test public void testCompare() { // 第一段 var tempParamA = \u0026quot;1\u0026quot;; var tempParamB = \u0026quot;2\u0026quot;; // 第二段 var result = compare(tempParamA, tempParamB); // 第三段 assertThat( result, is(false)); } } 上述代码的意思是\n 定义两个参数AB 使用compare方法对两个参数进行比较 断言，如果result是false，那么本次UT通过  其他需要注意的地方  通常在进行打包的时候，一般是会跳过这个打包阶段的mvn clean package -DskipTests，当然如果我们想要执行单元测试，那么直接mvn clean package这样就是ok的。 在写单元测试的时候，我们需要将语义表达清楚，尤其是在写单元测试名字的时候，还有在写断言的时候，需要直接就是英文的一句具有完整语义的句子，这样在后期维护的时候会很方便，可以一眼就知道这是干什么的。 在不想跑的Test上面加上@Ignore就可以不执行我们不需要的依赖等等，因此我们最好就是使用充血模型，在每个model中最好就有本类能做到的相关功能的方法实现。（贫血模型，通常就是简单的POJO，主要的功能方法都是在Service等外界实现的）  ","date":"2020-01-10T19:07:19Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg","permalink":"https://lllovol.com/spring12/","title":"SpringBoot开发中的一些小细节（十二）单元测试"},{"content":"一、前言 kubernetes作为一个容器的编排引擎，如今已经相当的火热，日常的工作中也有使用常用的kubernetes的相关的功能，例如滚动发布、扩容等等，但是这都是在公司现成的已经搭建好的kubernetes集群上实践的，因此，本篇文章就是自主探索在本地运行一个kubernetes集群，同时写一个自己的demo，运行到本地的kubernetes集群当中。\n本文主要包含如下几个方面：\n 国内条件下如何安装kubernetes（no vpn） 写一个Spring boot 的demo 使用Docker将demo打包成镜像 将demo部署到本地kubernetes集群当中  二、本地安装kubernetes 选择使用minikube 我们想要学习使用kubernetes，首先就是选择一个平台进行操作，比如阿里云、Azure、Google Kubernetes等等\n这里我们选择的就是学习用的minikube\n kubernetes官方文档 minikube操作文档 minikube安装文档\n 安装minikube 1.检查能否虚拟化 sysctl -a | grep -E --color 'machdep.cpu.features|VMX' vmx被标注出来有颜色，说明就是ok的，这台电脑是支持virtualization的（一般都是支持的,但是我花了88白菜价在腾讯云上买的1年1核1g服务器是不支持的）\n2.安装kubectl brew install kubernetes-cli 使用kubectl version能够查看到对应的kubectl版本\n3.安装Hypervisor（virtual machine monitor） 这个主要就是安装虚拟机了，kvm或者virtualBox二选一\n4.安装minikube 有两种方式,第一种方式就是如下的方式\ncurl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \\ \u0026amp;\u0026amp; chmod +x minikube 将minikube安装包下载下来，手动进行安装\nsudo mkdir -p /usr/local/bin/ sudo install minikube /usr/local/bin/ 如果是mac用户，直接使用如下的命令就可以了\nbrew install minikube brew link minikube 5.启动minikube minikube start 就会开始根据本地的virtualBox来下载对应的驱动,中间应该会要求输入一次本机电脑的一次密码,然后会出现这样的错误： Error creating machine: Error in driver during machine creation: hyperkit crashed! 我们可以使用minikube start -help查看到这个命令的一些参数: 例如--cpus=2我们可以设置为4,--disk-size等等都可以进行测试。由于按照官网的操作一步一步来做，发现依然会出错？然后我发现本地已经有了hyperkit，装的virtualBox没有什么用，因此我brew reinstall hyperkit重新安装了一下，这时候再来一次minikube start,这一次似乎终于是成功了。\n然后就开始下载kubernetes的相关的各种组件dns、kube-proxy\\kube-addon-manager等等，但是可能是由于被墙的原因下载不下来，这个时候我进行了以下的几种处理方式：\n 科学上网,ok科学上网之后，再来看看，但是发现依然还是不行 设置国内的代理\u0026ndash;image-repository……ok还是一样的错  minikube start --registry-mirror=https://registry.docker-cn.com 换一个虚拟机来进行安装，改用vmware来进行安装,当然也是没有什么作用的  brew install docker-machine-driver-vmware minikube start --vm-driver=vmware 关键的问题就在于VM is unable to access k8s.gcr.io, you may need to configure a proxy or set --image-repository,因此我找到了kubernetes minikube的github仓库，找到了其issue区，看看有没有仁兄有我一样的情况。功夫不负有心人，找到了issue 3860，我们可以使用国内的阿里云镜像egistry.cn-hangzhou.aliyuncs.com/google_containers  rm -rf ~/.minikube minikube start --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers --vm-driver=vmware 看一看minikube都有些什么namespace 成功了！\n三、编写Demo 接下来我们新建一个demo，使用Spring框架写一个简单的controller\n TestDemo\n 1.使用官方的Initializer脚手架初始化一个demo  https://start.spring.io/\n 2.在项目中添加需要的RestController和swagger的依赖 RestController有关的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.5.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 与swagger有关的依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${io.springfox.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${io.springfox.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-common\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${io.springfox.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-spring-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${io.springfox.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-spi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${io.springfox.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-schema\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${io.springfox.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${io.springfox.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-bean-validators\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${io.springfox.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.swagger\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;swagger-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.21\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.swagger\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;swagger-models\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.21\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 同时我们还需要在Application类中@EnableSwagger2\n3.创建controller 首先在application.properties文件中添加一条配置\nversion=@project.version@ 然后添加controller\npackage com.example.demo.controller; import io.swagger.annotations.Api; import io.swagger.annotations.ApiOperation; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * Created by Yangmingkai on 2019-11-11. */ @RestController @Api(\u0026quot;用于istio测试\u0026quot;) @RequestMapping(\u0026quot;/demo\u0026quot;) public class IstioController { @Value(\u0026quot;${version}\u0026quot;) private String version; @GetMapping(\u0026quot;/version\u0026quot;) @ApiOperation(\u0026quot;获取当前版本\u0026quot;) public String getVersion() { return String.format(\u0026quot;This is version %s\u0026quot;, version); } } 4.运行 四、将Demo打包成镜像 1.打包成jar包 进入pom.xml文件目录，运行命令mvn clean install -Dmaven.test.skip=true执行打包 2.利用dockerFile打包成镜像 编写docker file\n# 拉取JDK11的系统镜像 From openjdk:11 # 设置时区 ENV TZ=Asia/Shanghai # 时区写入系统文件 RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime \u0026amp;\u0026amp; echo $TZ \u0026gt; /etc/timezone VOLUME /tmp # 加入打包好的jar文件(xxxxx改为自己文件名) ADD ./target/demo-0.0.1-SNAPSHOT.jar / ENTRYPOINT [\u0026quot;java\u0026quot;,\u0026quot;-Djava.security.egd=file:/dev/./urandom\u0026quot;,\u0026quot;-jar\u0026quot;,\u0026quot;/demo-0.0.1-SNAPSHOT.jar\u0026quot;] 运行命令docker build -t 自定义镜像名称 .（注意后面有个 . 不要漏掉）,如果需要将该镜像加入我本地的harbor仓库（需要自己搭建），则镜像名称需要为： 仓库地址/名称:v版本号\n 如：192.168.123.45:8000/library/data_lake:v1.0\n 这里我们docker builde一下\ndocker build -t my-demo . 3.在本地docker运行打包好的镜像 使用命令docker run 运行镜像\ndocker run -d --name test -p 8080:8080 my-demo 然后可以使用docker ps查看运行中的docker镜像 使用docker stop加上对应的容器的id就能够停止对应的镜像的运行\n4.将docker推向镜像仓库 首先我们需要创建一个docker的账号，就能拥有一个docker远端的镜像仓库。我们给我们的镜像打一个tag,使用docker tag将本地原来的镜像推\n docker tag my-demo yangdocker1118/my-demo 然后使用docker push将本地的镜像推向远端\ndocker push yangdocker1118/my-demo 五、将demo镜像部署到kubernetes集群当中 1.创建一个namespace 创建namespace也有两种方式\n 使用yaml文件编写配置来进行创建  apiVersion: v1 kind: Namespace metadata: labels: istio-injection: enabled name: zelda status: phase: Active 然后使用kc apply -f namespace.yaml就能创建一个名为zelda的namespace 2. kubectl create namespace命令直接创建\n2.创建deployment 这里我们同样也可以使用yaml配置的方式来创建deployment，也可以直接使用下面命令行的方式直接创建deployment拉取镜像进行部署（推荐还是本地自己重新搭建一个镜像仓库harbor，使用docker官方的镜像仓库拉镜像的速度太慢了）\nkubectl create deployment my-demo --image=yangdocker1118/my-demo -n zelda 成功！Done!\n","date":"2019-12-02T14:23:17Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/4.jpg","permalink":"https://lllovol.com/minikube/","title":"从零开始将项目部署到Kubernetes"},{"content":"前言 最近将java升级到了11，因此学习了一些java11的一些新特性\n一.局部变量类型判断 代码：\n @Test public void testVar() { // 测试局部变量类型判断特性 var java11 = \u0026quot;test java11\u0026quot;; var test = 1; System.out.println(java11); System.out.println(test); } 输出：\n二.String类的新方法 代码：\n @Test public void testString() { String blank = \u0026quot;\u0026quot;; String strip = \u0026quot; strip \u0026quot;; String lines = \u0026quot;\\n\\n\u0026quot; + \u0026quot;\\n\u0026quot; + \u0026quot;\\n\u0026quot;; // 判断字符串是否为空白 System.out.println(blank.isBlank()); // 去除首尾空格 System.out.println(strip.strip()); // 去除开头空格 System.out.println(strip.stripLeading()); // 去除结尾空格 System.out.println(strip.stripTrailing()); // 重复 System.out.println(strip.repeat(0)); System.out.println(strip.repeat(1)); System.out.println(strip.repeat(2)); System.out.println(strip.repeat(3)); // 统计行数 System.out.println(lines.lines().count()); } 输出：\n三.使用of、copyOf方法创建不可变更的集合 代码：\n@Test public void testList() { // 使用 of copyOf 创建不可变的集合 AbstractImmutableList ImmutableCollections.ListN\u0026lt;\u0026gt;(e1, e2, e3); // 通过这些方式创建出来的集合，是不能进行添加删除操作的，如果使用了就会报java.lang.UnsupportedOperationException异常 var list = List.of(\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;); var copy = List.copyOf(list); System.out.println(list == copy); var list1 = new ArrayList\u0026lt;\u0026gt;(); var copy1 = List.copyOf(list1); System.out.println(list1 == copy1); } 输出：\n四.Stream的新方法 代码：\n@Test public void testStream() { // 为stream增加了4个新方法 // 1.增加了单个参数的构造方法 long count = Stream.ofNullable(null).count(); System.out.println(count); // 2.takeWhile 一旦不满足了条件就停止 下面样例输出是123 Stream.of(1, 2, 3, 4, 3, 2, 1).takeWhile(n -\u0026gt; n \u0026lt; 4).forEach(System.out::print); System.out.println(); // 3.dropWhile 满足条件的时候都扔掉 下面样例输出是4321 Stream.of(1, 2, 3, 4, 3, 2, 1).dropWhile(n -\u0026gt; n \u0026lt; 4).forEach(System.out::print); System.out.println(); // 4. iterate重载，可以提供一个predicate判断条件来指定什么时候结束迭代。 } 输出：\n五.更加强大的Optional方法 代码：\n@Test public void testOptional() { // 可以很方便的将一个Optional转成一个stream，这个repo需要自己实现或者换个东西进行替代 Optional\u0026lt;GreyPolicy\u0026gt; byId = greyPolicyRepo.findById(\u0026quot;\u0026quot;); System.out.println(byId.stream().count()); // 或者当optional为空的时候给他一个替代 System.out.println(\u0026quot;label:\u0026quot;); byId.ifPresent(greyPolicy -\u0026gt; System.out.println(greyPolicy.getLabel())); Optional\u0026lt;GreyPolicy\u0026gt; replace = byId.or(() -\u0026gt; { GreyPolicy greyPolicy = new GreyPolicy(); greyPolicy.setLabel(\u0026quot;replace\u0026quot;); return Optional.of(greyPolicy); }); System.out.println(\u0026quot;label:\u0026quot;); replace.ifPresent(greyPolicy -\u0026gt; System.out.println(greyPolicy.getLabel())); } 输出：\n六.JDK中自带的httpClient 代码：\n @Test public void testHttpClient() throws IOException, InterruptedException { // 可以在java.net中找到这个api，jdk自带的 http ClientAPI var request = HttpRequest.newBuilder().uri(URI.create(\u0026quot;https://www.baidu.com\u0026quot;)).GET().build(); var httpClient = HttpClient.newHttpClient(); HttpResponse\u0026lt;String\u0026gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); } 输出：\n","date":"2019-10-16T18:41:31Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg","permalink":"https://lllovol.com/java11/","title":"Java11新特性的六个实验"},{"content":"一 前言 最近独自完成了一个同步信息的项目，主要工作内容是从第三方的服务端将信息同步到公司的二方AD域当中。本文主要记录本项目的主要实现过程。\n二 项目设计 这是一个并不复杂的项目，因此项目主要涉及到两大部分：\n 从第三方服务器端获取到信息数据 将信息数据进行处理，能够存入到公司的二方AD域当中  三 第三方数据获取 1.主要技术 本项目主要获取信息的方式，是通过FeignClient来获取的\n2.主要实现 a.最单纯的feign方式实现 添加pom依赖 \t\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;10.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-jackson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;10.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 定义接收返回值所用到的model对象 这个地方的model定义，需要仔细阅读第三方服务端的api文档，然后根据上面的具体信息来进行定义\neg:\n@Data public class XxxApiResponse { private String code; private String message; private String timestamp; private String errcode; private String errmsg; private String detailMsg; } 这里的变量名没有按照驼峰的方式进行定义，是因为官方文档返回值当中的字段key值就是这样非驼峰的方式，我们需要保证名字的一致性。\n定义Feign public interface XxxClient { @RequestLine(\u0026quot;GET /v3/xxx/details?param1={param1}\u0026quot;) XxxDetailsResponse getXxxDetails(@Param(\u0026quot;param1\u0026quot;) String param1); } 注意这种RequestLine的方式和GetMapping和PostMapping的方式有所区别\n定义Feign的Factory public class XxxClientFactory { private final static String URL = \u0026quot;https://api.xxx.com\u0026quot;; public XxxClient createXxxClient() { ObjectMapper mapper = new ObjectMapper() .setSerializationInclusion(JsonInclude.Include.NON_NULL) .setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE) .configure(SerializationFeature.INDENT_OUTPUT, true) .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false); return Feign.builder() .logger(new Slf4jLogger()) .client(new OkHttpClient()) .encoder(new FormEncoder(new JacksonEncoder(mapper))) .decoder(new JacksonDecoder(mapper)) .logLevel(Logger.Level.FULL) .target(XxxClient.class, URL); } private XxxClientFactory() { } public static XxxClientFactory newInstance() { return new XxxClientFactory(); } } b.常用FeignClient实现 添加依赖 Application中增加注解,允许指定包的feignClient有效 @EnableFeignClients(basePackages = {\u0026quot;com.shuidihuzhu.devops.xrxs.client\u0026quot;, \u0026quot;com.shuidihuzhu.devops.xrxs.feign\u0026quot;}) public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } 3.创建service 创建获取第三方数据的service，所有三方数据的获取，按照内容分模块的进行封装实现，将通过上面的client获取到的数据进行处理然后分别进行返回。\n四 将数据同步到AD域 1.添加依赖和配置 a.依赖 \t\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-ldap\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; b.配置 LdapConfiguration.Java\n@Configuration @EnableLdapRepositories public class LdapConfiguration { private LdapTemplate ldapTemplate; @Value(\u0026quot;${spring.ldap.urls}\u0026quot;) private String LDAP_URL; @Value(\u0026quot;${spring.ldap.username}\u0026quot;) private String USERNAME; @Value(\u0026quot;${spring.ldap.password}\u0026quot;) private String PASSWORD; @Value(\u0026quot;${spring.ldap.base}\u0026quot;) private String BASE; @Bean public LdapContextSource contextSource() { LdapContextSource contextSource = new LdapContextSource(); Map\u0026lt;String, Object\u0026gt; config = new HashMap\u0026lt;\u0026gt;(); contextSource.setUrl(LDAP_URL); contextSource.setBase(BASE); contextSource.setUserDn(USERNAME); contextSource.setPassword(PASSWORD); config.put(\u0026quot;java.naming.ldap.attributes.binary\u0026quot;, \u0026quot;objectGUID\u0026quot;); contextSource.setPooled(true); contextSource.setBaseEnvironmentProperties(config); return contextSource; } @Bean public LdapTemplate ldapTemplate() { if (null == ldapTemplate){ ldapTemplate = new LdapTemplate(contextSource()); } ldapTemplate.setIgnorePartialResultException(true); return ldapTemplate; } } Application.Java\n@SpringBootApplication @EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class}) @EnableScheduling @EnableFeignClients(basePackages = {\u0026quot;com.shuidihuzhu.devops.xrxs.client\u0026quot;, \u0026quot;com.shuidihuzhu.devops.xrxs.feign\u0026quot;}) @EnableAspectJAutoProxy(proxyTargetClass = true) @EnableCircuitBreaker @EnableLdapRepositories public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Bean LdapTemplate getLdapTemplate(ContextSource contextSource) { LdapTemplate ldapTemplate = new LdapTemplate(contextSource); ldapTemplate.setIgnorePartialResultException(true); return ldapTemplate; } } 注意setIgnorePartialResultException(true)这个方法是必须要设置好的，不然对接AD的时候，会报出莫名其妙的错误\n2.定义model和DAO层 以人员为例,Ad中的user对应的objectClasses有四个类，base设置就是对应的AD域下的专门存放这些user的域\n@Data @Entry(objectClasses = {\u0026quot;top\u0026quot;, \u0026quot;person\u0026quot;, \u0026quot;organizationalPerson\u0026quot;, \u0026quot;user\u0026quot;}, base = \u0026quot;ou=XxxUser\u0026quot;) public final class XxxUser { @Id @JsonIgnore private Name id; @Attribute(name = \u0026quot;mail\u0026quot;) private String mail; @Attribute(name = \u0026quot;mobile\u0026quot;) private String mobile; @Attribute(name = \u0026quot;sn\u0026quot;) private String sn; @Attribute(name = \u0026quot;cn\u0026quot;) @DnAttribute(value = \u0026quot;cn\u0026quot;, index = 1) private String cn; @Attribute(name = \u0026quot;displayName\u0026quot;) private String displayName; @Attribute(name = \u0026quot;ou\u0026quot;) @DnAttribute(value = \u0026quot;ou\u0026quot;, index = 1) private String ou; } 定义对应的DAO,在这个DAO接口中，可以使用JPA的函数命名来进行条件查询，但是还是做不了一些复杂的查询，如果需要复杂的查询依然还是需要在自定义的接口XxxUserExtension中进行定义，然后进行实现。\n@Repository public interface XxxUserRepo extends LdapRepository\u0026lt;XxxUser\u0026gt;, XxxUserExtension { List\u0026lt;XxxUser\u0026gt; findByOu(String ou); } 3.定义Service层 根据业务的需求，将获取到的第三方的信息，经过处理之后，将Response的有效内容解析到对应的AD的model中，通过对应的DAO层类，存入到AD中\n五 创建定时任务 根据cron或者fixedRate(每隔一段时间执行)来设置定时任务\n@Slf4j @Component @EnableScheduling public class XxxToAdJob { /** * 每20分钟同步一次 */ // @Scheduled(cron = \u0026quot;0 */20 * * * ?\u0026quot;) @Scheduled(fixedRate = 1000 * 60 * 20) public void doExecuteJob() { // 同步逻辑 } 六 注意事项  本文只是将本项目最简单的框架思路展现了出来，在具体实施的过程中，会有很多很多坑 对接第三方数据源的时候，需要注意请求的一些频率，比如某些数据源要求，每分钟的请求调用不能超过200次 对接AD的时候，需要it部门的人将对应功能模块所需要的端口都打开，不然会有问题 如果需要ldaps访问，需要导出AD的证书然后使用java的keytool制作证书，然后在启动的时候增加参数（但是目前都没有成功） ldap常见错误码 官方链接 mac电脑可以使用Parallels Client这个软件远程登录AD的服务器进行查看（AD是搭建在一个windows的集群上的） AD自定义属性的创建 相关文章 注意x500的中国区对象id必须是2.16.156开头的  ","date":"2019-09-23T17:12:49Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/5.jpg","permalink":"https://lllovol.com/synchronize-job/","title":"从零开始搭建AD信息同步的项目"},{"content":"前言 Redis在曾经实现用户登录token的时候使用过，但是对其的了解程度，就只是在使用的这个层次。本篇文章主要用于学习记录Redis的常见的一些数据结构。\n第一部分 什么是redis？  是NoSql数据库，非关系型数据库。 是个非关系型数据库。 Key-Value数据库 使用C语言实现的单线程应用，基于内存，读取的速度都超快！ 基于内存存放,使用了rdb （就是redis内存的SNAPSHOT，存到了磁盘当中）和Aof(Append only file 也就是平时操作的命令集合)的机制来保障数据的持久化，宕机的时候可以通过这两种方式来进行数据恢复。 拥有丰富的Value对象，String\\Hash\\List\\Set\\ZSet\\Stream 拥有多种底层数据结构：SDS，list，dict，zskiplist，intset，ziplist，quicklist，zipmap，stream 支持丰富功能，过期，事物  第二部分 常用Value对象 1 String对象 最常见的类型\n1.1 编码 int，可以自增 embstr，就是单纯的字符串 raw\n1.2 扩容长度 字符串在小于1M的时候，是加倍扩张的策略 在超过1M的时候，每次扩容会增加1M的空间，每个key最大512M\n2 List 相当于java中的linkedList 插入和删除非常快，时间复杂度是O(1)\n2.1 编码 redis3.2之后列表的内部实现变成了quickList而非传统的ziplist或者双向链表实现。使用的是quicklist和ziplist组成的双向链表。 ziplist的分配过长和过小都不好，过小了会太多碎片化，过大了之后空间复杂度就会更大。\n list-max-ziplist-size-2可以用来设置size. list-compress-depth 0：表示数据都不被压缩，为n的话，就是两端的n个数据不被压缩,双向链表\n 2.2 常用场景 消息队列\n3 Hash 3.1 编码 zipList 默认，所有的key value，长度都小于64，保存的键值对数量都小于512 ht（hashTable），超过了就用ht\n4 Set和ZSet Set无序和唯一的 ZSet是可排序的，是对每一个元素添加了一个分数一样的东西\n4.1 编码 Set 小512用intset，大于用hashtable ZSet 小64数量小128 用ziplist 否则用skiplist\n4.2 场景 跟踪唯一性数据，比如说排行榜\n5 stream   是redis5.0 后引入的一种新数据类型。\n  Stream的多个客户端是竞争关系，可以拿到以前的数据，是通过id来获取的，stream会永久的存储数据 和KafKa的机制很类似。\n  提供了消费者组，不同组接受到的数据一致，组内是竞争关系。 可以设置为阻塞和非阻塞的\n  类型和编码的对应关系，是在redisObject这个类中进行存储的\n第三部分 底层数据结构 1 dict字典 底层实现\n扩容和缩容是根据负载因子的值来做的\n used/size 如果大于1 且没有备份 如果大于5 且在备份 那么就扩容，如果小于0.1那么来进行缩容   h1设置为扩容缩容所需要设置的大小 h0rehash放入h1当中，释放h0，给h1改名 不会锁主线程，会在每次的操作的过程中，做一次渐进的hash的过程  2 ziplist 是redis为了节约内存而进行开发的 是由一系列的特殊编码的连续内存块所组成的顺序形数据结构\n第四部分 其他事件  过期操作   定时删除策略 惰性删除策略 定期删除策略，每段时间删除一批，但是不会全量的删除  内存淘汰机制   noeviction allkeys-lru allkeys-random volatile-lru volatile-random volatile-ttl  ","date":"2019-08-19T19:15:50Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg","permalink":"https://lllovol.com/redis/","title":"Redis中的常用数据结构"},{"content":"前言 最近听了一场蔡黎博士关于如何提高我们技术视野的分享，收益良多，其实不仅仅是在技术方面，其实很多道理，在生活中都是有共通点的。分享的主要内容既然是关于如何提高我们的技术视野的，那么他是如何进行分享的呢？他主要将这次分享按照内容分为了三个方面：\n 视野 技术 效益  第一部分 视野 用英文来讲，就是Vision，这决定了格局和潜力，也是指的一种远见。\n那么怎样才能看的更远呢？  看得到多远的过去，就能看得到多远的未来。\u0026ndash;丘吉尔  例子一：如今阿里云计算排名第一 中国云计算市场现状：top1阿里云 超过了第2到第8名的总和。 但是如果看看10年前，国内的各个公司都在同一起跑线上，那时候的大佬们对于云计算，看法又都是怎样的呢？\n 李彦宏，说云计算是新瓶装旧酒，没有什么新东西。 马化腾，云计算的理念，还为时过早，就算能够实现也是过一百年和一千年之后才能实现的事情了。 马云，可以生产更好的商品，卖给消费者。  可以看到，BAT作为那时候中国的互联网三大巨头，只有阿里的马云是看好云计算的，而从如今的结果来看，阿里巴巴当初选择将精力投入到云计算是绝对正确的选择。那么，为什么阿里巴巴当初为什么要投云计算？ 因为云计算其实是数据时代的公共基础设施，那么那时候的阿里，是通过什么样的方式发现这样的一个原因呢？10年前，能看到如今的未来嘛？答案是肯定的。\n我们回顾一下第二次工业革命，电的出现之后，是如何发展的呢？\n 最开始-分散发电模式到现在-集中发电模式我们可以看到，在电出现了之后，最开始，都是分散发电的模式，工厂都用着自己的发电机来进行发电，实现电量的自给自足。再看看现在，都是国家电网，集中发电的集中发电形式。\n 通过类比的方式可以发现，其实和发电的形式是相当相似的\n工业时代看用电量\n信息时代看用云量\n科技永远向前，历史总在重演\n例子二：小米卖手机 雷军在做小米手机的初期，那时候他的演讲，就讲到过Android还有操作系统芯片等等部分模块，都将实现标准化。\n 产品经理是怎样炼成的？新媒体电商\n在那个时候的手机利润，是3倍来卖的，真的是个暴利行业，但是雷军觉得，手机不应该是3倍的毛利来卖，因此，小米手机一直都是每台手机只赚5%，一直卖到了现在世界五百强。 （看看pc，毛利才14%，那时候手机毛利3倍是多么的夸张，但是其实最开始的pc也没有几个人能买得起）第一个标准化，第二个是薄利多销，雷军他所看见的手机未来的发展趋势，其实就是pc行业发展的规律。\n  第一波浪潮-pc第二波浪潮-手机 这就是个历史规律，科技的趋势是普惠的。\n 一体化的用户体验，是远超组合的用户体验 标准化，差距会逐渐缩小 产业最终肯定分工化、规模化， 产业的演进是技术和商业模式的结合  例子三：为什么芯片要单独为手机再开发一次？ 为什么要在手机上芯片重新开发一遍？因为功耗更小\n差了几倍呢？10倍\n价格呢？便宜了10倍\n10倍因素的新技术，某个指标产生这种变化的时候，那么可能就是革命要出现了  你必须保持敏感，否则当新技术作为10倍数因素席卷而来的时候，猝不及防只能轰然倒塌。同时，对新技术的追逐可能不在盈利，而在于可以使得企业在必要的时候迅速转向。毕竟，只有早早行动，才有希望争取未来的胜利，改变不利的命运\u0026ndash;英特尔公司前CEO安迪·葛洛夫  水滴公司CEO沈鹏，是美团的第十号员工，他在带领团队做美团外卖的时候，也是在13年的时候，看见了一个10倍因素的场景，外卖出现了一个爆发的机会。 是什么呢？最开始的外卖机制，都需要店家在店里装一台二手电脑，用于接收订单的信息，相当的不方便。但是那时候，安卓手机的人人普及，提升了沟通的效率，也提高了配送的稳定性。外卖就是这么做出来的，稳定性就此提升，从而改变了这个产业。（饿了嘛 那时候已经做了5年左右，那时候都是用二手电脑来做的外卖生意， 美团当时第一年的目标，就是从饿了么的5w一天，美团的目标是要做到20w一天，而那时候真正的结果，美团达成了120w一天，这个因素已经远远超过了10倍）\n 很有可能在5年之后，这个10倍因素将会出现在电动车行业当中。看看如今电动车的体验，特斯拉差不多是一般电动车3倍的价格，但是它的体验，远远高于普通电动车所带来的3倍 分散发点模式，分久必合，合久必分。美国的solarcity公司，让每家每户，使用太阳能电池，各自发电，多余的电还可以输送到集中电网当中。 华为发布的鸿蒙系统其实，平头哥+鸿蒙，IoT（Internet of Things）是为了物联网而做出来的系统。  第二部分 技术 推荐一部书《技术的本质》W. Brain Arthur\n技术的本质就是自然现象有目的的组合\n技术=自然现象+目的+组合\n技术肯定是来自于自然现象的  数学是上帝描述自然的符号 \u0026ndash; 黑格尔  基础理论才是突破创新的最根本的基石 技术来源于自然现象\u2028技术的极限也受这些自然现象约束，除非发现新的自然现象\n华为5G  华为现在的水平尚停留在工程教学、物理算法等工程科学的创新层面，尚未真正进入基础理论研究。随着逐步逼近香农定理、摩尔定律的极限，而对大流量、低时延的理论还未创造出来，华为已感到前途茫茫、找不到方向。华为已前进在迷航中。重大创新是无人区的生存法则，没有理论突破，没有技术突破，没有大量的技术积累，是不可能产生爆发性创新的\u0026ndash;任正非\n 现在来看，5G真的是90后的机会，5G的出现，这个社会必将发生不小的变化，而绝非下载速度变快这么简单的一件事情5G的原理就是香农定理: C=Blog2(1+S/N) 使用类比的方式来看这个公司\nC就是单位时间的载货量 B道路的宽度 S车的速度 N道路的平整状况  如何解决这些问题才能实现5G？  使用的技术是毫米波，小基站，提高车速（频率越高，能量也就越大，所以为了安全不能使用大的基站） 使用多输入多输出，全双工技术，变宽车道 波束赋形，使得道路更加平整  而华为，投入了数以万计的工程师，才能将这些基础的东西结合起来，带给了我们5G\nps:技术视野还可以赚钱，知道什么地方需求大。比如如果知道了5G发展的趋势，可以提前买小基站公司的股票，可以大赚一笔。\n第三部分 效益 技术怎么带来效益，如何才能带来效益？再回答这个问题之前，我们需要想一想，一般老板最关心的是什么？\n增长！ 可以亏损，但是一定要增长 一般的工程师，最关注的是什么？\n一般都是在做将成本的降低。\n什么技术能使得全球运输成本下降90%? 集装箱  麦克莱恩认识到，降低货运成本所要求的不仅仅是一只金属箱子，而是一整套货物处理的新方法。这个系统的每一个组成部分，港口、轮船、起重机、储存设施、卡车、火车以及发货人自身的操作等等，都必须做出改变。他的这种认识几乎要比当时运输业中的每一个人都超前很多年。这些见识所引发的变革如此富有戏剧性，以至于连几十年来一直在推动集装箱运输的国际集装箱局的专家们都为之震惊。 \u0026ndash;摘编自《集装箱改变世界》\n 集装箱的发展节点：\n 效能发挥不出来，10年不盈利 1967年，越战，3C原则就是一个箱子、一种货物，一个客户 码头工人，阻止集装箱、塔吊，港口根据集装箱改造 陆地交通设施，根据集装箱改造 货轮越来越大，资本开始介入，给码头工人好处，相互协作 公司供应链，根据集装箱，进行改造 全球货运量越来越大，改变地域格局  可以说 没有集装箱，就没有全球化（无独有偶，docker的标志，就是个小鲸鱼，拖着个集装箱，就是技术的集装箱）\n总结 关于视野的总结 如何拥有技术的视野？ **那就是用历史的纵深，去深入抓规律。**这也就是为什么读史使人明智的原因。 我们可以看看前、后端、QA等方向发展的过去，看看其规律，看看是不是也有例如10倍指标这样的现象，通过这些现象，反观现在，又能看见什么未来呢？\n关于技术的总结  常识就像氧气一样,越往高处走，越是稀薄\n 要用基础的原理，去感知这个方向。知道的越底层，基础越牢靠，方向感越强。\n关于效益的总结 技术落地需要多方系统协作，才能发挥更大的效能\n结语  视野：用历史的纵深，抓主线 技术：用基础的原理，知方向 效益：用系统的协作，去演化  推荐以及相关链接  任何在我出生时已经有的科技都是稀松平常的世界本来秩序的一部分； 任何在我15-35岁之间诞生的科技都是将会改变世界的革命性产物； 任何在我35岁之后诞生的科技都是违反自然规律要遭天谴的。——英国科幻作家道格拉斯·亚当斯\n 推荐书籍  《技术的本质》W.Brain Arthur 《集装箱改变世界》Marc Levinson  相关链接  技术的本质 集装箱改变世界 雷军：产品经理是怎样练成的 5G是什么，5G如何改变我们的世界 吴国盛 科学通史 （全39讲） 吴军 科技史纲60讲密码:54dy  公众号  原理 返朴 sheldon 科学的历程  ","date":"2019-08-08T01:14:30Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/7.jpg","permalink":"https://lllovol.com/improve-our-vision/","title":"大咖分享-如何提高自己的技术视野"},{"content":"前言 在安装使用Idea Intelli的时候，导入新项目的时候，总会出现代码权限飘红的问题。本篇文章，就是介绍出现这种问题的几种情况和分别的解决方式。 情况一：maven二方库settings没有设置 一般公司内部都会有自己的二方库建设，新人在git下项目之后，总是会出现代码偏红的问题，各种库都没有导入下来，这时候首先应该排查的就是maven的配置是否正确，是否正确连接到了公司内部的二方库。\n解决方式 以Idea Intelli为例: preference -\u0026gt; build,execution,deployment -\u0026gt; build tools -\u0026gt; maven -\u0026gt; User settings file: 勾选上override，改写为二方库settings.xml文件的路径\n情况二：Lombok插件没有安装  Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.lombok官网\n Lombok可以让我们的Java代码更加简洁，不用再去写那些Getter和Setter。然而这个强大的功能，在初次安装idea的时候，并不会内置的给我们安装Lombok插件，因此这个时候，同样也会出现大片代码报错的问题。\n解决方式 安装Lombok的插件： ** preference -\u0026gt; Plugins -\u0026gt; Install lombok -\u0026gt; restart ** 问题三：注解未开启 在安装好了 Lombok之后，发现运行还是报错 解决方式  关闭项目。 Preference \u0026gt; Build, Execution, Deployment \u0026gt; Compiler \u0026gt; Annotation Processors. Check \u0026lsquo;Enable annotation processing\u0026rsquo;.  Open your project. File \u0026gt; Invalidate Caches / Restart\u0026hellip; \u0026gt; Invalidate and Restart 然后等待这个过程完成结束,将会发现一切都将回归平淡，云淡风轻.  ","date":"2019-08-07T10:08:30Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/9.jpg","permalink":"https://lllovol.com/ide-code-error-solution/","title":"Idea代码飘红的问题解决方式"},{"content":"前言 最近工作中需要参与一下scala的项目，借此机会学习一下这个心的语言。\n环境搭建  Java环境 JDK1.5以上  ymk@localhost ~ $ java -version java version \u0026quot;1.8.0_181\u0026quot; Java(TM) SE Runtime Environment (build 1.8.0_181-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) 下载安装Scala\nScala官方下载地址\n安装好了之后,可以通过scala查看是否安装成功  ymk@localhost ~ $ scala Welcome to Scala 2.12.7 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_181). Type in expressions for evaluation. Or try :help. 下载安装sbt\nMac: brew install sbt@1  使用命令行搭建第一个Scala项目 本节内容主要来自于官方文档\n创建项目  cd 进入一个新的空的文件夹。 执行命令 sbt new scala/hello-world.g8。这个命令是从github上面拉取了一个“hello-world”模板下来。(这个命令同时会创建一个target文件夹，可以忽略)。 当有提示的时候，给这个应用取个名hello-world。这时候就会创建一个名为“hello-world”的项目。 查看一下这个项目的目录结构  - hello-world - project (sbt uses this to install manage plugins and dependencies) - build.properties - src - main - scala (All of your scala code goes here) -Main.scala (Entry point of program) \u0026lt;-- this is all we need for now build.sbt (sbt's build definition file) 启动项目  cd进入对应的scala项目。 使用sbt,这将打开对应项目的sbt的命令行。  使用~run指令，~指令可以让sbt在每次文件更改保存后，重新run一次，可以用在快速编辑、快速启动、以及debug上。  编辑代码  使用自己最舒服的ide打开src/main/scala/Main.scala文件。 coding~  添加依赖 如果我们需要其他的功能和依赖，就需要打开 build.sbt文件夹，按照如下的方式，使用“+=”的方式来添加依赖，更多的依赖可以在Scaladex中找到\nlibraryDependencies += \u0026quot;org.scala-lang.modules\u0026quot; %% \u0026quot;scala-parser-combinators\u0026quot; % \u0026quot;1.1.0\u0026quot; ","date":"2019-08-02T14:50:13Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/8.jpg","permalink":"https://lllovol.com/scala1/","title":"Scala环境搭建"},{"content":"前言 最近的工作需要使用Jenkins执行一个特定脚本，但是使用FeignClient调用Jenkins的执行接口后，并不能获取到脚本执行之后的结果（成功和失败），本文就将介绍这种问题的其中一种解决方式。\n Jenkins是开源CI\u0026amp;CD软件领导者，提供超过1000个插件来支持构建、部署、自动化，满足任何项目的需要。Jenkins官网\n 关键点 通过调研后，Jenkins在完成构建后，可以添加一个构建后操作。这就可以通过这个构建后操作，将本次构建脚本执行的结果，通过这个构建后操作，传给另外一个job，然后通过这个job将执行的结果通过回调的方式，传给应用服务器。\n整个流程  服务器端创建一条记录，获取到记录的id，与需要执行的job所需要的参数还有回调所需要用到的apiHost一同存入到map当中，转换为JSON格式，通过FeignClient调用Jenkins对应的脚本。   服务器端应用可能会部署在不同的环境下，连接不同的数据库，因此可以在application.yml中配置当前apiHost的值，通过ConfigServer可以更改为当前环境所对应的值。\n  在Jenkins端进行对应的job执行。\n  通过构建后操作的trigger parameterized build on other projects功能。   根据本次构建的成功与否，分别执行不同的构建后操作，传递给回调job对应的参数。   回调job将获取到的信息，通过一个shell脚本，通过curl传递给服务器端。\n  echo \u0026quot;${ID}\u0026quot; echo \u0026quot;${API_HOST}\u0026quot; echo \u0026quot;${BUILD_NO}\u0026quot; echo \u0026quot;${RESULT}\u0026quot; curl \u0026quot;$API_HOST/api/xxx/xxx/xxx/hook\u0026quot; -X POST -d \u0026quot;Id=$ID\u0026amp;buildNo=$BUILD_NO\u0026amp;result=$RESULT\u0026quot; 服务器端拿到数据进行更新和处理。  结语 有时候只是想要一条小小的消息，却不知道要辗转多少次，才能到达该去的地方\n","date":"2019-07-26T11:01:52Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/3.jpg","permalink":"https://lllovol.com/jenkins-callback/","title":"使用Jenkins回调获取状态"},{"content":"前言 程序的静态表现就是程序，平常的安安静静的躺在硬盘上；但是一旦运行起来，他就变成了计算机里的数据和状态的总和，这就是它的动态表现。 而容器的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出了一个边界。\n Cgroups是用来约束的主要手段。 Namespace是用来修改视图的主要方法。  docker run实验 安装好docker，输入以下命令\ndocker run -it busybox /bin/sh 这个命令就是告诉docker：帮我启动一个容器\n接下来我们可以使用ps指令，来看一看容器和宿主机中的进程信息。 宿主机里的内容： 容器里的内容 Namespace机制 上面的小实验，这就是Linux里的namespace机制实现的， 我们可以看到，我们容器里pid为1的/bin/sh进程，在宿主机中的pid为13193，这就是容器使用了namespace使用了障眼法，让容器里的视角，以为自己就是这个机器的1号员工（pid=1），可是实际上，他还是原来的100号进程。\nnamespace其实只是Linux在创建新的进程的时候的一个参数，在Linux系统中创建线程的系统调用是clone()\nint pid=clone(main_function,stack_size,SIGCHLD,NULL); 这个系统调用，创建了一个新进程，并且返回一个pid。而我们在创建一个新进程的时候，可以指定CLONE_NEWPID 参数。\nint pid=clone(main_function,stack_size,CLONE_NEWPID | SIGCHLD,NULL); 这个新创建的进程就将“看见”一个全新的进程空间，看见它自己在这个进程空间中，他自己的pid为1。这其实只是一个障眼法，在宿主机上，它的pid该是多少，还是多少。\nNamespace种类 Namespace的种类很多，上文中提到的只是PID Namespace，除此之外，还有如下的Namespaces,这些namespaces用来实现对进程上下文的“障眼法操作”\n MOUNT Namespace， 用来隔离文件系统的挂载点，使得子进程拥有自己独立的挂载点信息。 UTS（UNIX Time-sharing System ）Namespace提供了主机名和域名的隔离,能够使得子进程有独立的主机名和域名(hostname),而不仅仅只是宿主机上的一个进程. IPC Namespace,使划分到不同ipc namespace的进程组通信上隔离，无法通过消息队列、共享内存、信号量方式通信，但没有对所述所有IPC通信方式隔离。 Network Namespace，是实现网络虚拟化的重要功能，它能创建多个隔离的网络空间，它们有独自的网络栈信息。不管是虚拟机还是容器，运行的时候仿佛自己就在独立的网络中。 User Namespace,是Linux3.8新增的一种namespace，用于隔离安全相关的资源，包括user IDs and group IDs，keys,和capabilities。同样一个用户的userID和groupID在不同的user namespace中可以不一样(与PID namespace类似)。换句话说，一个用户可以在一个user namespace中是普通用户，但在另一个user namespace中是超级用户。  通过Namespace这样的方式，容器就只能看见当前Namespace所限定的资源、文件、设备、状态、配置。而对于宿主机和其他不想关的程序，对这个容器（一个进程）来说，就“雨我无瓜了”\n结语 这个原理，就是为什么容器要比虚拟机效能更高的原因，本文是读了张磊前辈的文章后的学习笔记。\n","date":"2019-07-19T11:56:44Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/1.jpg","permalink":"https://lllovol.com/container-is-a-special-process/","title":"容器就是一个特殊的进程"},{"content":"前言 了解一个未知的事物，最好的方式就是去了解这个事物的历史。现在容器化，微服务很火热，有必要去了解一下docker这个小鲸鱼背后的东西。\n最热的服务器端技术 在如今，肯定可以不假思索的说，是容器，因为现在是2019年，如果是2013年，我们可不敢这么说.那时候最火热的是PaaS化。“应用托管”，那时候租了虚拟机之后，用脚本或者手动的在上面部署应用。这样部署应用就会有本地环境和云端环境不一致的问题，因此，那时候的公司，拼的就是，谁能更好的模拟云端的环境。而PaaS项目的出现，就是实现当时这个问题的最佳方案。\nCloud Foundry 当时最大的开源的PaaS项目。只需要一个命令\ncf push \u0026quot;我的应用\u0026quot;\n就可以将本地应用部署到云上。这就是实现了应用托管的功能。\n“应用托管”如何是实现？  每一种主流的语言特定方式各自打包，上传（cf push的作用就等同于用户将应用的可执行文件和启动脚本打进了脚本当中，上传到了Cloud Foundry的云存储当中。） 在虚拟机创造各种沙盒隔离环境 Cloud Foundry调度合适的虚拟机下载压缩包 机器上的Agent下载压缩包启动运行  而这个沙盒隔离环境，其实就是现如今所说的“容器”。\nDot Cloud公司 在随着PaaS的历史长河的流动过程中，dot Cloud这个公司，弱小，可怜又无助，无人问津，差一点就在PaaS的潮流中被抛弃。这个时候，这个公司决定开源一个项目，就是Docker项目。 这个Docker呢，其实同样也是使用了Cgroups和Namespace的方式来创造了容器，和Cloud Foundry等其他的PaaS项目基本没有什么区别，没有什么黑科技，因此那些PaaS平台的大佬也就没有将Docker放在眼里。\n风云变幻 然而，世事无常，短短几个月，Cloud Foundry等其他的PaaS社区，还没有来得及成为Docker的对手，就被Docker直接宣告“出局”。\n原因 先看看Cloud Foundry的一件上传\n 需要为每种语言、每种框架、甚至应用的每种版本单独维护一个打好的包。 打包过程没有章法 本地跑的好好的应用，需要修改和更改不少配置才能好好的在云端运行 表面一件发布，实际上一波三折、费劲心力  Docker成功，就是靠着Docker镜像，这个看起来无足轻重的一部分，但是却提供了一种非常方便的打包机制\n 完整操作系统的文件和目录 完全不需要任何配置和修改  这样做了之后，就是docker能够成功的精髓，那就是实现了本地环境和云端环境的高度一致！\n结语 生产力解放之后。PaaS自然就被淘汰，CaaS（Container as a Service）变成了一种新兴的趋势。DotCloud公司也改名为Docker公司。成为了基础设施领域近十年难得一见的技术明星。\n","date":"2019-07-16T20:58:05Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/9.jpg","permalink":"https://lllovol.com/docker-history/","title":"小鲸鱼的成长史"},{"content":"前言 在使用FeignClient的时候，我们很难保证第三方的调用不会出问题，这个时候，可以写一个FallBack类，来对出错的时候进行处理，可以异常上报，也可以进行打点处理，可以不再单独地去做这些事情。\nFeignClient的编写  添加maven依赖。  \t\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.2.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.7.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.openfeign\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;feign-slf4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.7.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 新建一个接口，在上方添加FeignClient注解，在value中使用占位符的方式，对参数进行调用。  \t@FeignClient(name = \u0026quot;gitApi\u0026quot;, url = \u0026quot;${api.server.gitlab.url}\u0026quot;,fallback = GitApiFeignFallBack.class) public interface GitApiFeign { @GetMapping(value = \u0026quot;/{namespace}/-/jobs/{jobId}/trace\u0026quot;) JSONObject getTrace( @PathVariable(\u0026quot;namespace\u0026quot;) String namespace, @PathVariable(\u0026quot;jobId\u0026quot;) Integer jobId, @RequestParam(\u0026quot;private_token\u0026quot;) String accessToken); } @Autowired 注解就能对FeignClient进行使用。  @Autowired GitApiFeign gitApiFeign; FeignClient的Fallback实现 在上方的代码中，可以看见注解中有fallback的选项，这个就是新建这个Client对应的fallback类来实现FeignClient。\n在fallback类的实现代码大致如下，最简单的实现就是在fallBack类中重写一遍Client中的所有方法。\n@Component @Slf4j public class GitApiFeignFallBack implements GitApiFeign { @Override public JSONObject getTrace(String namespace, Integer jobId, String accessToken) { log.error(\u0026quot;调用gitlab api 失败\u0026quot;); return null; } } ","date":"2019-07-11T16:31:53Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/8.jpg","permalink":"https://lllovol.com/fallback/","title":"FeignClient的FallBack处理"},{"content":"前言 最近正式入职，第一周的事情主要就是进行代码的Code Review,将自己曾经的实习时候写的代码看一看，清掉一部分过时的代码。同时也从前辈们的分享中学习到了不少的小细节。 以及看了阿里巴巴的开发规范规约，将一些比较重要的地方、原来没有注意到的地方记录一下。\n测试用例   在写Junit的时候，可以写一个BaseTest,以后test直接继承这个类即可，就不用每次都新建一个类然后在上面重新写上好多注解了。\n @SpringBootTest(classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @RunWith(SpringJUnit4ClassRunner.class) @Slf4j public class BaseTests { }    在写CRUD的测试用例的时候，一定要写成一个闭环，新加了测试用例，最后测试结束的时候一定要删除，防止在数据库中产生脏数据。\n  阿里巴巴的规约阅读笔记  外部正在调用或者二方库依赖的接口（二方库就是公司内部各个服务之间相互依赖的库）不允许修改方法的签名，避免对接口调用方造成影响。 接口过时的时候必须加上**@Deprecated**注解。 Object的equals方法容易报NPE，应该使用常量或者确定有值的对象来使用equals方法。   正例:\u0026ldquo;test\u0026rdquo;.equals(object);\n反例:object.equals(\u0026ldquo;test\u0026rdquo;);\n 所有整型包装类对象之间值的比较，全部使用equals方法比较。   说明:对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产 生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数 据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。\n 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。 定义数据对象DO类时，属性类型要与数据库字段类型相匹配。   正例:数据库字段的 bigint 必须与类属性的 Long 类型相对应。\n反例:某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来 越大，超过 Integer 的表示范围而溢出成为负数。\n 为了防止精度损失，禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。   说明:BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。\n如:BigDecimal g = new BigDecimal(0.1f); 实际的存储值为:0.10000000149\n正例:优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了 Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。\n BigDecimal recommend1 = new BigDecimal(\u0026quot;0.1\u0026quot;); BigDecimal recommend2 = BigDecimal.valueOf(0.1); 所有POJO类属性必须使用包装数据类型。 RPC方法和返回值必须使用包装数据类型。 所有的局部变量推荐使用基本数据类型。   说明:POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。\n正例:数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。 反例:比如显示成交总额涨跌情况，即正负 x%，x为基本数据类型，调用的RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能 够表示额外的信息，如:远程调用失败，异常退出。\n 定义DO、DTO、VO等POJO类的时候，不要设定任何属性的默认值。   反例:POJO 类的createTime默认值为 new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。\n 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。 序列化类新增属性的时候，不要修改serialVersionUID字段避免反序列化失败;如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID的值。 使用索引访问String的split方法得到的数组时，需要做到最后一个分隔符后有误内容的检查，否则有抛IndexOutOfBoundsException的风险    String str = \u0026quot;a,b,c,,\u0026quot;; String[] ary = str.split(\u0026quot;,\u0026quot;); // 预期大于 3，结果是 3 System.out.println(ary.length); 循环体类，字符串的连接方式，使用StringBuilder的append方法进行拓展，或者使用Guava的Joiner来进行拓展。如果使用str=str+“new str”的方式来进行字符串连接的话，每一次循环都会产生一个新的StringBuilder对象然后进行append操作，最后通过toString方法返回String对象，造成内存资源的浪费。   反例\n String str = \u0026quot;start\u0026quot;; for (int i = 0; i \u0026lt; 100; i++) { str = str + \u0026quot;hello\u0026quot;; } 表达异常的分支时，少用if-else方式，这种方式可以改写成:    if (condition) { ... return obj; } // 接着写 else 的业务逻辑代码; 说明:如果非使用 if()\u0026hellip;else if()\u0026hellip;else\u0026hellip;方式表达逻辑，避免后续代码维护困难，请勿超过3层。 正例:超过3层的if-else的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句,即代码逻辑先考虑失败、异常、中断、退出等直接返回的情况，以方法多个出口的方式，解决代码中判断分支嵌套的问题，这是逆向思维的体现。\npublic void findBoyfriend(Man man) { if (man.isUgly()) { System.out.println(\u0026quot;本姑娘是外貌协会的资深会员\u0026quot;); return; } if (man.isPoor()) { System.out.println(\u0026quot;贫贱夫妻百事哀\u0026quot;); return; } if (man.isBadTemper()) { System.out.println(\u0026quot;银河有多远，你就给我滚多远\u0026quot;); return; } System.out.println(\u0026quot;可以先交往一段时间看看\u0026quot;); } //he,woman 除常用方法(如getXxx/isXxx)等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。   说明:很多if语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。\n正例:\n // 伪代码如下 final boolean existed = (file.open(fileName, \u0026quot;w\u0026quot;) != null) \u0026amp;\u0026amp; (...) || (...); 在高并发场景中，避免使用”等于”判断作为中断或退出的条件。   如果并发控制没有做好，那么容易产生等值判断被“击穿”的情况，最好使用区间判断来代替。\n反例： 判断剩余奖品数量等于0时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。\n 类、类属性、类方法的注释必须使用Javadoc规范，使用/**内容*/格式，不得使用 // xxx 方式。 所有的抽象方法(包括接口中的方法)必须要用Javadoc注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明:对子类的实现要求，或者调用注意事项，请一并说明。 所有的类都必须添加创建者和创建日期。 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释 使用/* */注释，注意与代码对齐。 所有的枚举类型字段必须要有注释，说明每个数据项的用途。 避免出现重复的代码(Don\u0026rsquo;t Repeat Yourself)，即DRY原则。说明:随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 应用中不可直接使用日志系统(Log4j、Logback)中的API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。  Code Review 使用Response代替Response，list数据为空时后端不要返回NULL而要返回空集合。 DTO（Data Transfer Object）类一般是用于两个系统之间的数据传输，而VO(Value Object)一般是用于后端向前端进行展示的数据对象。 尽量不要使用BeanUtils.copyProperties，可以在目标方法里面写一个构造方法。使用getter和setter，使用上面那个工具类，如果属性有一点不一样的时候，就会出错。 一个方法需要判断是不是为空的时候，可以在入参的时候就进行判断。 尽量不要使用map来进行返回，最好是通过定义对象的方式来进行返回。  ","date":"2019-07-10T23:36:52Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/7.jpg","permalink":"https://lllovol.com/spring11/","title":"SpringBoot开发中的一些小细节(十一)CR笔记、阿里巴巴代码规约"},{"content":"前言 在书写markdown文章的时候，往往需要向其中添加图片的链接，从截图到文件的处理，到链接的获取都会很麻烦。在寻找各种图床工具之后，发现其效果都不是很好（比如要收费开通多个云图床的上传权限），因此本文将介绍另外一种较为简便的处理方式。\n设置Snippet snippet是短文的意思，在ide中常常是指可以通过一小串的命令生成一大段代码或者文字的方式。例如，在sublime中输入lorem+tab。就会生成一大段样例文字\nlorem+tab ==\u0026gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.  而接下来要做的就是要自定义一个snippet：在sublime中，Tools\u0026ndash;\u0026gt;Developer\u0026ndash;\u0026gt;New Snippet 然后就能得到如下的新建snippet 写入自己自定义的代码\n\u0026lt;snippet\u0026gt; \u0026lt;content\u0026gt;\u0026lt;![CDATA[ ![](https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/pics/$1.png) ]]\u0026gt;\u0026lt;/content\u0026gt; \u0026lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --\u0026gt; \u0026lt;tabTrigger\u0026gt;ap\u0026lt;/tabTrigger\u0026gt; \u0026lt;!-- Optional: Set a scope to limit where the snippet will trigger --\u0026gt; \u0026lt;scope\u0026gt;text.html.markdown\u0026lt;/scope\u0026gt; \u0026lt;/snippet\u0026gt;  其中：\n CDATA框住的地方表示自己自定义的代码 $1表示占位符，这就是在生成的代码最后光标所在的位置 tabTrigger表示触发的条件 scope表示的时候这个snippet的作用域（获取方式Tools\u0026ndash;\u0026gt;Developer\u0026ndash;\u0026gt;Show Scope Name）   然后保存在sublime的默认目录下，即可生效了\nmacOS的目录如下 /Users/user_name/Library/Application Support/Sublime Text 3/Packages/User  如何使用  截图，将图片保存到自定义的路径下，复制出其文件名即可 输入ap，tab 粘贴文件名，完成！ 这种方式对于只是日常写blog的我来说，已经方便了太多了  ","date":"2019-06-16T22:16:35Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg","permalink":"https://lllovol.com/snippet/","title":"自定义Snippet提高效率"},{"content":"前言 最近在帮朋友优化一个安卓的应用，使用Android来实现的一个华容道的小游戏。 项目链接\nAndroid Studio的开发项目文件结构图 主要显示的是src文件夹下的结构\n . ├── AndroidManifest.xml ├── java │ └── com │ └── example │ └── huarongdao │ ├── AboutActivity.java │ ├── Block.java │ ├── Dimension.java │ ├── Klotski.java │ ├── KlotskiMapParser.java │ ├── L.java │ ├── Level1Activity.java │ ├── Level2Activity.java │ ├── Level3Activity.java │ ├── Level4Activity.java │ ├── LevelActivity.java │ ├── MainActivity.java │ └── Screen.java └── res ├── drawable ├── drawable-v24 ├── layout ├── mipmap-anydpi-v26 ├── mipmap-hdpi ├── mipmap-mdpi ├── mipmap-xhdpi ├── mipmap-xxhdpi ├── mipmap-xxxhdpi ├── temp-mipmap └── values  AndroidManifest.xml 这个配置文件中主要用来说明整个app都将使用哪一些Activity，同时也可以设置有没有上面的导航栏等功能。\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;manifest xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot; xmlns:tools=\u0026quot;http://schemas.android.com/tools\u0026quot; package=\u0026quot;com.example.huarongdao\u0026quot;\u0026gt; \u0026lt;application android:allowBackup=\u0026quot;true\u0026quot; android:icon=\u0026quot;@mipmap/ic_launcher\u0026quot; android:label=\u0026quot;@string/app_name\u0026quot; android:roundIcon=\u0026quot;@mipmap/ic_launcher_round\u0026quot; android:supportsRtl=\u0026quot;true\u0026quot; android:theme=\u0026quot;@style/AppTheme\u0026quot; tools:ignore=\u0026quot;GoogleAppIndexingWarning\u0026quot;\u0026gt; \u0026lt;activity android:name=\u0026quot;.Level1Activity\u0026quot; android:theme=\u0026quot;@style/AppTheme.NoActionBar\u0026quot; /\u0026gt; \u0026lt;activity android:name=\u0026quot;.Level2Activity\u0026quot; android:theme=\u0026quot;@style/AppTheme.NoActionBar\u0026quot; /\u0026gt; \u0026lt;activity android:name=\u0026quot;.Level3Activity\u0026quot; android:theme=\u0026quot;@style/AppTheme.NoActionBar\u0026quot; /\u0026gt; \u0026lt;activity android:name=\u0026quot;.Level4Activity\u0026quot; android:theme=\u0026quot;@style/AppTheme.NoActionBar\u0026quot; /\u0026gt; \u0026lt;activity android:name=\u0026quot;.AboutActivity\u0026quot; android:theme=\u0026quot;@style/AppTheme.NoActionBar\u0026quot; /\u0026gt; \u0026lt;activity android:name=\u0026quot;.LevelActivity\u0026quot; android:theme=\u0026quot;@style/AppTheme.NoActionBar\u0026quot; /\u0026gt; \u0026lt;activity android:name=\u0026quot;.MainActivity\u0026quot; android:theme=\u0026quot;@style/AppTheme.NoActionBar\u0026quot;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026quot;android.intent.action.MAIN\u0026quot; /\u0026gt; \u0026lt;category android:name=\u0026quot;android.intent.category.LAUNCHER\u0026quot; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; \u0026lt;/application\u0026gt; \u0026lt;/manifest\u0026gt;  Res文件夹下的Layout  ├── layout │ ├── activity_about.xml │ ├── activity_level.xml │ ├── activity_level1.xml │ ├── activity_level2.xml │ ├── activity_level3.xml │ ├── activity_level4.xml │ └── activity_main.xml  在这个文件夹中的，就是app的各个页面的布局文件，在右方有可以直接拖动添加组件，但是拖动而得到的位置，最终都不是那么的准确。 因此一般都主要在代码中体现布局，这是可以最终确定布局是什么样子的。\n目前我常用的布局有：\n RelativeLayout相对布局 ConstraintLayout约束布局  Res的其他配置文件 drawable文件夹  ├── drawable │ ├── aboutbtn.xml │ ├── angry.jpg │ ├── back_icon.jpg │ ├── backimage.jpg │ ├── btn.xml │ ├── cry.jpg │ ├── ic_launcher_background.xml │ ├── levelback.jpg │ └── surprise_icon.jpg  这个文件夹主要用于存放图片的资源文件，可以使用xml来配置图片被点击的时候的动画（press=false或者press=true的时候分别显示哪一张图）\n \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;selector xmlns:android=\u0026quot;http://schemas.android.com/apk/res/android\u0026quot;\u0026gt; \u0026lt;item android:drawable=\u0026quot;@drawable/surprise_icon\u0026quot; android:state_pressed=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;item android:drawable=\u0026quot;@drawable/back_icon\u0026quot; android:state_pressed=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;/selector\u0026gt;  在上面的代码中，android:state_pressed=\u0026ldquo;true\u0026quot;的时候（也就是受到按压的时候），就显示surprise_icon，如果为\u0026quot;false\u0026quot;就显示back_icon\nvalues文件夹  └── values ├── attrs.xml ├── colors.xml ├── dimens.xml ├── strings.xml └── styles.xml  在这些xml文件当中，可以配置Android应用中的各种属性。\n \u0026lt;resources\u0026gt; \u0026lt;dimen name=\u0026quot;fab_margin\u0026quot;\u0026gt;16dp\u0026lt;/dimen\u0026gt; \u0026lt;dimen name=\u0026quot;level_text_size\u0026quot;\u0026gt;24sp\u0026lt;/dimen\u0026gt; \u0026lt;dimen name=\u0026quot;level_text_size_big\u0026quot;\u0026gt;30sp\u0026lt;/dimen\u0026gt; \u0026lt;dimen name=\u0026quot;level_text_width\u0026quot;\u0026gt;192dp\u0026lt;/dimen\u0026gt; \u0026lt;/resources\u0026gt;  但是有一点需要注意的是,在调用的时候不需要加s\n android:textSize=\u0026quot;@dimen/level_text_size\u0026quot;  Java文件夹 在这个文件夹下主要就是用来实现程序主要逻辑的部分。一般开发需要以下几个步骤\n 需要一个类Activity继承AppCompatActivity 重写类中的onCreate方法，将类与对应的Layout绑定（使用R.layout.**__activity） 使用findViewById方法，可以将layout中的各个组件，通过id找到，然后和java对象进行绑定，然后进行相应的操作  例子：监听TextView的点击事件  final TextView aboutGame = findViewById(R.id.about); aboutGame.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: aboutBtn.setBackgroundResource(R.drawable.angry); aboutGame.setTextColor(getResources().getColor(R.color.colorGrey)); break; case MotionEvent.ACTION_UP: aboutBtn.setBackgroundResource(R.drawable.cry); aboutGame.setTextColor(getResources().getColor(R.color.colorb)); break; } return false; } });  ","date":"2019-06-08T16:49:49Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/5.jpg","permalink":"https://lllovol.com/android-idea/","title":"Android开发笔记（一)"},{"content":"前言 从公司回到学校，不多不少刚好一个月了。这一个月，自己都做了些什么？完成了什么目标？结果怎么样？\n学车 真的有点操之过急，四月之前报名的话，就不用刷学时。但是也为时不晚，仔细想一想，等到真正工作上班之后，哪里还会有这么多的时间来练车，工作上的事情也是一堆一堆的。\n 科二，要慢，记准确每一个点。 科三，还没有学，但是一定要好好跟着教练练习。  心境 感觉自己最近总是很容易着急，今天在驾校和隔壁教练起了冲突。\n仔细一想，完全没有必要。\n我是去学车的，并不是去斗嘴的，他莫名其妙的侮辱我，不讲道理，我给他讲道理难道他就会听了吗？非然也。\n以后遇到这种事情，一定要冷静。不置可否，将自己的本职工作做好，已属不易。\n需要锻炼自己的身体， 冲动是魔鬼，心平气和，就像后来宋教练给我说的，要学会吃话。\n多听，好好听完了别人说什么，抓住重点，再进行反问，不要让自己脑子一热，就做出一些让自己后悔的事情。 感觉今天的处世方式，真的很像蔡徐坤。仿佛不容别人质疑自己，容不得一点负面的评价，还要去发律师函，愚蠢。\n别人教练再怎么说，都是长辈，然后和别人教练顶撞了过去，没有必要。 前辈始终是前辈。得罪了这个教练，就算他不负责我，他也始终是教练，得罪了他，对我来讲，能有什么好处？ 没有好处。\n上善若水，大丈夫，能屈能伸。\n对于别人的评价与看法 越来越不喜欢别人对自己的评价，是可爱，而希望是成熟。\n但是这真的很傻，才发现，这种太在意别人评价的事情，才是真的不成熟。 别人能对我有所评价，至少别人是有在关心我（无论正负评价，都是关心，就像明星一样，黑粉也一样是粉丝）。 那些真正对你不理不睬的，才是真的可怕。 让所有人都满意，让所有人都对我有很高的评价，真的能做到吗？不能。\n光是做好自己的事情，就已经很不容易了。\n别人将我捧的高，我的实力也不会因为他的夸赞而突飞猛进；\n别人将我贬的低，我的能力也不会因为他的觊觎而忽然消失。 做好自己\n所有的事情 都取决于自己的 想法与做法 要做事、先做人 ","date":"2019-05-13T13:02:36Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/4.jpg","permalink":"https://lllovol.com/aboutsomething/","title":"随笔杂想"},{"content":"前言 本文主要记录最近工作中关于开发中的一些小技巧以及感悟\n小细节 权重转换百分比的问题 在工作中需要将各个对象所对应的权重转换成百分比，并且要求最后转换出来的百分比，同一类型的相加必须为百分之百，解决思路主要如下\n 将各个类型的对象都分别分类 算出各个类型的总权重 算出每个对象在自己类型下的所占百分比 判断每个类型下的对象百分比相加是否等于100 在List处理的时候，可以将List分割成当前类型，和非当前类型 其中需要注意的是，在算百分比的时候，*100应该写在分子  eg: //这样会一直为0，是错误的 //原因是运算符是从左往右计算 //前面除法算出来之后会直接去尾，不足1就是0，所以最后乘以100结果还是0 percent / totalWeight * 100 //这样是正确的 percent * 100 / totalWeight\ncode:\n private List\u0026lt;GreyDestination\u0026gt; getDestinationsPercent(List\u0026lt;GreyDestination\u0026gt; tempDestinations) { HashMap\u0026lt;String, Integer\u0026gt; serviceAndTotalWeight = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;String, Integer\u0026gt; serviceAndCount = new HashMap\u0026lt;\u0026gt;(); getServiceWeightAndCount(tempDestinations, serviceAndTotalWeight, serviceAndCount); List\u0026lt;GreyDestination\u0026gt; finalDestinations = tempDestinations.stream().map( destination -\u0026gt; { String service = destination.getService(); Integer count = serviceAndCount.get(service); if (count == 1) { destination.setPercent(100); } else { Integer totalWeight = serviceAndTotalWeight.get(service); if (totalWeight == 0) { totalWeight = 1; } destination.setPercent(destination.getWeight() * 100 / serviceAndTotalWeight.get(service)); } return destination; } ).collect(Collectors.toList()); for (String service : serviceAndCount.keySet()) { if (serviceAndCount.get(service) \u0026gt; 1) { List\u0026lt;GreyDestination\u0026gt; collectService = finalDestinations.stream().filter(destination -\u0026gt; destination.getService().equals(service)).collect(Collectors.toList()); List\u0026lt;GreyDestination\u0026gt; collectRest = finalDestinations.stream().filter(destination -\u0026gt; !destination.getService().equals(service)).collect(Collectors.toList()); Integer firstPercet= 100; for (int i = 1; i \u0026lt; collectService.size(); i++) { firstPercet = firstPercet-collectService.get(i).getPercent(); } GreyDestination firstDestination = collectService.get(0); firstDestination.setPercent(firstPercet); collectService.set(0, firstDestination); collectService.addAll(collectRest); finalDestinations=collectService; } } return finalDestinations; } private void getServiceWeightAndCount(List\u0026lt;GreyDestination\u0026gt; tempDestinations, HashMap\u0026lt;String, Integer\u0026gt; serviceAndTotalWeight, HashMap\u0026lt;String, Integer\u0026gt; serviceAndCount) { for (GreyDestination tempDestination : tempDestinations) { String service = tempDestination.getService(); Integer weight = tempDestination.getWeight(); //存储每个service的count if (serviceAndCount.containsKey(service)) { serviceAndCount.put(service, serviceAndCount.get(service) + 1); } else { serviceAndCount.put(service, 1); } //增加每个Service的total weight if (serviceAndTotalWeight.containsKey(service)) { serviceAndTotalWeight.put(service, serviceAndTotalWeight.get(service) + weight); } else { serviceAndTotalWeight.put(service, weight); } } }  公共基础父类 例如 分页模块，应该在父类定制一个最简单的模型，然后在各个业务Service中继承的时候，分别定制化各个服务中特有的特征，已达到方法真正的可扩展性和可复用性。\n单例模式 这个常见的设计模式，主要是用来保证这个对象，只会被实例化一次，比如在线程池中的时候\n泛型 三种类型   泛型接口（写在接口名之后）\n public interface List\u0026lt;E\u0026gt; extends Collection\u0026lt;E\u0026gt;    泛型类（将泛型写在类名之后）\n class Test\u0026lt;T\u0026gt;{ private T data; }    泛型方法（将泛型写在方法返回值之前）\n public static \u0026lt;T extends Comparable\u0026gt; void sort(T[] arr, int left, int right)    实例code  package QuickSort; import com.google.common.base.Joiner; /** * Created by ymk on 2019/3/29. * 这个类主要是用来实现快速排序的 */ public class QuickSort { public static \u0026lt;T extends Comparable\u0026gt; void sort(T[] arr, int left, int right) { if (left \u0026gt;= right) return; int i = left, j = right; T key = arr[i]; while (i \u0026lt; j) { while (arr[j].compareTo(key) \u0026gt;= 0 \u0026amp;\u0026amp; i \u0026lt; j) { j--; } //j找到第一个比key小的值,i和j交换值 swap(arr,i,j); while (arr[i].compareTo(key) \u0026lt;= 0 \u0026amp;\u0026amp; i \u0026lt; j) { i++; } //i找到第一个比key大的值,i和j交换值 swap(arr,i,j); } //开始递归 sort(arr,left,i); sort(arr,i+1,right); } public static \u0026lt;T\u0026gt; void swap(T[] arr, int i, int j) { T temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public static void main(String[] args) { Integer[] arr={1,2,325,52,34,5346,23,23,56,74,34,634,74,34}; Joiner joiner = Joiner.on(\u0026quot;,\u0026quot;); System.out.println(joiner.join(arr)); sort(arr,0,arr.length-1); System.out.println(joiner.join(arr)); } }  分布式锁的问题 最近工作中的后台服务，部署在了测试环境中的两个节点上，然后执行同一个定时任务的时候，虽然都写了在更新之前先删除库中信息，然后再将新的数据入库的操作，但是实际部署之后，还是会出现数据的冗余，原因应该是在某一瞬间，两个服务同时删除了库，然后同时插入了相同的数据。虽然过一段时间后就数据再次就正常了，但是这还是一个问题\n Java分布式锁\n 可以使用分布式锁，将锁放在redis当中（分布式问题之所以复杂，就是因为网络延迟和网络不可靠的问题）setnx ，get等等（有可能会出现阻塞的情况，比如在操作的时候宕机了，来不及释放），具体有机会的时候，实践一下吧\n顺便复习一下死锁的四个必要条件：\n 排他性 请求和保持资源 不剥夺资源 形成等待环路  ","date":"2019-03-29T17:19:15Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/3.jpg","permalink":"https://lllovol.com/spring10/","title":"SpringBoot开发中的一些小细节(十）泛型、分布式锁"},{"content":"前言 排序问题实现过很多次了，但是如何保证随机的乱序呢？这就是洗牌问题了（Shuffle）\n 洗牌算法FisherYates原理\n 洗牌问题 Fisher-Yates shuffle算法 首先来看看Collection里面的方法 code：\n /** * Created by ymk on 2019/3/28. * 这个算法主要是用来实现洗牌算法的 */ public class FisherYates { public static void main(String[] args) { Integer[] raw = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; List\u0026lt;Integer\u0026gt; pokers = Arrays.asList(raw); Joiner joiner= Joiner.on(\u0026quot;,\u0026quot;); System.out.println(joiner.join(pokers)); Collections.shuffle(pokers); System.out.println(joiner.join(pokers)); } }  输出：\n 1,2,3,4,5,6,7,8,9,10,11,12,13 5,9,1,12,7,8,2,10,11,6,3,4,13  源码实现  public static void shuffle(List\u0026lt;?\u0026gt; list) { Random rnd = r; if (rnd == null) r = rnd = new Random(); // harmless race. shuffle(list, rnd); } private static Random r; @SuppressWarnings({\u0026quot;rawtypes\u0026quot;, \u0026quot;unchecked\u0026quot;}) public static void shuffle(List\u0026lt;?\u0026gt; list, Random rnd) { int size = list.size(); if (size \u0026lt; SHUFFLE_THRESHOLD || list instanceof RandomAccess) { for (int i=size; i\u0026gt;1; i--) swap(list, i-1, rnd.nextInt(i)); } else { Object arr[] = list.toArray(); // Shuffle array for (int i=size; i\u0026gt;1; i--) swap(arr, i-1, rnd.nextInt(i)); // Dump array back into list // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method ListIterator it = list.listIterator(); for (int i=0; i\u0026lt;arr.length; i++) { it.next(); it.set(arr[i]); } } }  为什么优秀？ 如果简单粗暴的随机抽取不够好呢？这就和昨天的钢条问题一样，在简单随机抽取的过程中就有可能出现重复的位置，就等于浪费了一次抽取。而使用了Fisher-Yates方法之所以优秀，就是在原理上保证了不会出现浪费次数，每一次抽卡的范围都在慢慢变小 自己实现  package Shuffle; import com.google.common.base.Joiner; import java.util.*; /** * Created by ymk on 2019/3/28. * 这个算法主要是用来实现洗牌算法的 */ public class FisherYates { public static void byMyWayFisherYates(Integer[] raw) { Random rnd = new Random(); //nextInt(n)生成的值范围是[0,n)的 for (int i = raw.length; i\u0026gt;1; i--) { swap(raw,i-1,rnd.nextInt(i)); } } public static void swap(Integer[] raw, int i, int j) { Integer temp = raw[i]; raw[i] = raw[j]; raw[j] = temp; } public static void main(String[] args) { Integer[] raw = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; List\u0026lt;Integer\u0026gt; pokers = Arrays.asList(raw); Joiner joiner = Joiner.on(\u0026quot;,\u0026quot;); System.out.println(joiner.join(pokers)); Collections.shuffle(pokers); System.out.println(joiner.join(pokers)); Integer[] newRaw = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; System.out.println(joiner.join(newRaw)); byMyWayFisherYates(newRaw); System.out.println(joiner.join(newRaw)); } }  ","date":"2019-03-28T11:00:40Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg","permalink":"https://lllovol.com/shuffle/","title":"Shuffle"},{"content":"前言 动态规划是算法中的一大类，是一个求解最优解的值的问题\n 本文内容主要来自于 《算法导论第三版第四部分第15章 动态规划》\n 四个基本步骤 我们通常需要四个步骤来设计一个动态规划算法：\n 1.刻画一个最优解的结构特征 2.递归地定义最优解的值。 3.计算最优解的值，通常采用自定向上的算法 4.利用计算出的信息构造一个最优解  钢条切割问题 问题描述 给定一段长度为n的英寸的钢条，和一个价格表pi（i=1,2,\u0026hellip;,n）,求切割钢条的切割方案，是的销售收益rn最大。（如果长度为n英寸的钢条价格pn足够大，最优解可能就是完全不需要切割）\n问题处理 长度为n英寸的钢条共有2^(n-1)种不同的切割方案，因为在距离钢条左端i（i=1,2,\u0026hellip;,n-1）英寸的地方，我们总是可以选择切割或者不切割。 这时候rn=max(pn,r1+r[n-1],r2+r[n-2],r[n-1]+r1)，相当于，我们将问题分割了，首先将钢条切割了，切割成了长度为i和n-i的两端，然后求解这两端的ri和r[n-i]\n这样，我们就能通过组合两个相关子问题的最优解，并在所有可能的两端切割方案中选取组合收益的最大者，构成原问题的最优解。 这样，我们称钢条切割问题满足最优子结构（optimal substructure）的性质：问题的最优解由相关问题的最优解组合而成，而这些子问题可以独立求解。\n除此之外，我们可以将钢条从左边切割下长度为i的一段，然后只对右边剩下的长度为n-i的一段继续进行切割（递归求解），对左边的一段则不再进行切割，\n而不做任何切割的方案，可以描述为：第一段的长度为n，收益为pn，剩余部分的长度为0，对应的收益为r0=0。\n伪代码实现（自顶向下的方法）  CUT-ROD（p,n) 1\tif n == 0 2\treturn 0; 3 q = min_num 4 for i = 1 to n 5 q=max(q,p[i]+CUT-ROD(p,n-i)) 6 return q  CUT-ROD优化 上方的方法，在n变大的时候，程序运行时间会变得特别特别慢，原因是，它会反复的使用相同的参数值，对自身进行递归调用，等价于他在反复求解相同的子问题。如果将上面函数的递归调用树画出来，将会有2^(n-1)个叶节点。全部展开，必将成为一个指数级增长的趋势。上面的朴素递归算法，效率低，就是这个问题，反复求解了相同的子问题。\n因此，动态规划要求仔细安排求解的顺序，对每个子问题，之求解一次，并将结果保存下来。因此，对于每个子问题的解，咱们只求一次，并且将结果保存下来，之后再遇到相同的子问题，就可以直接求出解，因此，动态规划方法，就是付出了额外的内存空间，来节省计算时间，这就是典型的时空权衡的例子。下面是两个优化算法的伪代码\n带备忘的自顶向下法（top-down with memoization） 过程会保存每个子问题的解，通常保存在一个数组或者散列表当中。当需要一个子问题的解的时候，首先检查一下是否已经保存过此解。\n MEMOIZED-CUT-ROD(p,n) 1 let r[0..n]be a new array 2 for i = 0 to n 3 r[i] = min_num 4 return MEMOIZED-CUT-ROD-AUX(p,n,r); MEMOIZED-CUT-ROD-AUX(p,n,r) 1 if r[n]\u0026gt;=0 2 return r[n] 3 if n == 0 4 q = 0 5 else q = min_num 6\tfor i = 1 to n 7 q=max(q,p[i]+MEMOIZED-CUT-ROD-AUX(p,n-i,r)) 8 r[n]=q 9 return q  自底向上的方法  BOTTOM-UP-CUT-ROD(p,n) 1 let r[0..n] be a new array 2 r[0] = 0 3 for j = 1 to n 4 q=min_num 5\tfor i = 1 to j 6 q = max(q,p[i]+r[j-i]) 7 r[j]=q 8 return r[n]  结语 算法之大，博大精深，吾之所见，沧海一粟\n路漫漫其修远兮，吾将上下而求索\n","date":"2019-03-27T20:38:15Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/1.jpg","permalink":"https://lllovol.com/dynamic-programming/","title":"Dynamic Programming-钢条切割问题"},{"content":"前言 本文主要记录最近工作中关于开发中的一些小技巧以及感悟\n小细节 String转Long 使用Long.parseLong,而不是Long.getLong\nGuava库 Joiner 超好用的Guava库，主要用于字符串的拼接，可以自动在中间加上分隔符\n String yamlStart = \u0026quot;---\\n\u0026quot;; String yamlEnd = \u0026quot;...\\n\u0026quot;; Joiner joinerContent = Joiner.on(\u0026quot;...\\n---\\n\u0026quot;).skipNulls(); return Joiner.on(\u0026quot;\u0026quot;).join(yamlStart, joinerContent.join(yamlList), yamlEnd);  Splitter 可以很方便的将字符串分割成对应的数据结构\n //将source进行处理 List\u0026lt;String\u0026gt; tempSource = Splitter.on(\u0026quot;,\u0026quot;).splitToList(param.getSource());  String占位符的用法 原来：\n String title = \u0026quot;[\u0026quot; + characterName + \u0026quot;][\u0026quot; + task.getEnv() + \u0026quot;][\u0026quot; + pipelineStage.getService() + \u0026quot;]\u0026quot;;  改进：\n String title = String.format(\u0026quot;[%s][%s][%s]\u0026quot;,  线程中的问题 不能直接使用Autowired，需要定义了成员变量之后，使用外界已经加载好的service作为入参传入初始化这个线程，如果每一个线程都启一个service的话，资源消耗会很大。 （仅仅是我暂时这么理解，TODO 搞清楚原因）\n数据入库的操作 建议先入队列，然后再入库\nConfiguration的问题 定义了两个configuration，一个masterClient，一个jobClient 然后有个地方使用了@Autowired来进行配置（一个在外层service，一个是另外一个service），这时候就出现了冲突，开始报错。配置一定要清晰\n重复代码的问题 在mac中，如果是在同一个类中的重复冗余的代码，可以使用option+command加上m，可以将重复代码进行抽离。如果是在不同的类中，可以使用将重复方法抽离到父类的方法，或者是抽离到静态工具类的方法。避免重复代码的最好的方式，就是在编码的时候，尽量不要使用复制粘贴的方式来进行编码，而应该想办法，提高自己的代码的可复用性和可扩展性。\n小感悟 工作不知不觉已经是第七个月，但是自己的能力，还有薪资，都是处于一个“穷”的状态，俗话说得好，穷则独善其身。现在的我，还没有资格去管别人的事情，能将自己的事情做好就已经不错了。\n","date":"2019-03-24T17:23:42Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/9.jpg","permalink":"https://lllovol.com/spring9/","title":"SpringBoot开发中的一些小细节(九）Guava库"},{"content":"前言 在前天的时候，java12都出了，但是我还在用java6的陈旧的编码方式，需要改进到java8的流式编程，此文主要是用来记录流式编程的积累\n java8 新特性\n 个人的主要理解 java真正的支持了函数式的编程，同时加入了streamApi来进行支持\n Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。 Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 Stream编程\n 总而言之，流式操作主要分为了中间操作和最终操作\nIntermediate 操作 非最终操作，也就是中间操作\n map (mapToInt, flatMap 等) filter distinct sorted peek limit skip parallel sequential unordered  Terminal 操作 最终操作\n forEach forEachOrdered toArray reduce collect min max count anyMatch allMatch noneMatch findFirst findAny iterator  Short-circuiting 操作 短程巡回操作\n anyMatch allMatch noneMatch findFirst findAny limit  实操例子 将一个列表/数组进行处理进行转换 例子如下：\n Set\u0026lt;Integer\u0026gt; collect = projects .stream() .map(CustomProject::getId) .collect(Collectors.toSet());  代码翻译：\n projects是CustomProject的一个List 然后map()进行一个映射 将其中的id属性去除， collect()可以转换成另外的数据结构集合  filter过滤和forEach 例子如下：\n all.stream().filter(greyTask -\u0026gt; greyTask.getType() == GreyTaskType.PERSON ).forEach(greyTask1 -\u0026gt; { List\u0026lt;String\u0026gt; source = greyTask1.getSource(); source.stream().filter(username -\u0026gt; username.startsWith(\u0026quot;B-\u0026quot;)).forEach(bUser -\u0026gt; { bUser = \u0026quot;B-\u0026quot; + 处理bUser的代码; }); source.stream().filter(userId -\u0026gt; userId.startsWith(\u0026quot;C-\u0026quot;)).forEach(cUser -\u0026gt; { cUser = \u0026quot;C-\u0026quot; + 处理cUser的代码; }); greyTask1.setSource(source); });  转换成map 例子如下：\n List\u0026lt;Person\u0026gt; list = new ArrayList(); list.add(new Person(\u0026quot;1001\u0026quot;, \u0026quot;小A\u0026quot;)); list.add(new Person(\u0026quot;1002\u0026quot;, \u0026quot;小B\u0026quot;)); list.add(new Person(\u0026quot;1003\u0026quot;, \u0026quot;小C\u0026quot;)); //将list转换map Map\u0026lt;String, String\u0026gt; map = list.stream().collect(Collectors.toMap(Person::getId, Person::getName));  但是有一点需要注意，就是Collectors中的tomap 方法，value值也是不允许重复的，如果想要转成HashMap的话，还是使用forEach比较方便\n处理String类型的String 对List类型进行处理的时候，需要重新返回一个List，因为String都是final的\n List\u0026lt;String\u0026gt; collectUserB = source.stream().filter(username -\u0026gt; username.startsWith(\u0026quot;B-\u0026quot;)).map(bUser -\u0026gt; { bUser = \u0026quot;B-\u0026quot; + userService.getPerson(bUser.replace(\u0026quot;B-\u0026quot;, \u0026quot;\u0026quot;)).getDisplayName(); return bUser; }).collect(Collectors.toList());  ","date":"2019-03-21T11:08:24Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/8.jpg","permalink":"https://lllovol.com/stream/","title":"Java8流式编程"},{"content":"前言 RocketMQ，是一种延时队列，主要的应用场景，就是消费者可以延时消费消息，比如在双11的时候,一瞬间有太多请求全部打在服务器上，服务器就会瞬间瘫痪，本文主要就是记录前辈分享的Rocket源码的时候笔记和一些感悟\n主要功能  负载均衡 消费模式 消费拉取 消费进度反馈 消费过滤 延迟队列  分享主要内容笔记 打字速度有限，只能记录下简单的一些片段供参考\n 有一个架构，轮询，可用性高，一致性要求没那么高 消息的一个流程：生产者发了一个消息，到了breaker之后，到了commitlog。有一个G的大小，实际发送的大小，顺序写的，io性能会很好，会被放到消费者的queue里面 ，小了之后，总要发到某一个topic里面 发一个消息的话，需要新建一个主题，需要制定一个queue的数量，每一个queue就是一个负载均衡，表示当前这个queue，消费到什么位置了。集群消息，一人拿一个。被负载的queue，同一个topic下的消息都是不同的 消费者可以对同一个topic下面的某几个队列进行消费，多个不同的consumer 设置min是核心线程数，是固定的，但是她的队列是无限的，所以这个地方没有什么用 缓存超过10000个，会改变线程池的大小，会做对应的限制 msgListener就是传的一个回调 会有一个offsetStore会存，存到本地和远程 还有消息的消费逻辑，注册到客户端的，生成clientId 封装了一些拉取消息的api，通过路由信息 worker发出请求，然后又一个线程池，来进行序列化和相应，消费的话会再七环到对应consumer的线程池 有各种组件，然后讲讲启动之后，都做了哪些事情 基本上都是通过定时消息去驱动的，很少是通过事件去驱动的， 找nameserver,然后去找server的信息 更新consumer消费的一个队列offset 都不是实时的更新的，是每一个五秒钟才刷新一次的 广播消费的，消费的queue是全部，订阅，不是分发，每一个rebalance里面，都处理了一个queue，实现了一个拍照 如果没有存，就是首次消费，如果是last，就会从，rocket是经常清消息的，发消息，然后消费 消费，就是拉取消息，就是放一条消息，就可以进行拉取，会先做一些验证，然后做一些限流，只不过限流是做一些delay，顺序消息，需要设置一下是不是第一次，然后获取订阅信息，然后调用对应的pullapi，然后去发一条消息，拉倒请求之后，就会有callback，去封装一下，找到了消息了，然后有一个真正的消息处理类 处理的流程 如果全部消费成功了之后，就会找到maxOffset，如果没有的话，就会去更新最小的那一个，这就是整个的一个消费流程  自行延展 MQ是高并发系统的核心组件之一，能够提高业务效率和系统的稳定性，主流的MQ有Rocketmq、kafka、Rabbitmq\n Rocketmq原理\u0026amp;最佳实践 主要对比如下\n ","date":"2019-03-19T10:54:01Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/7.jpg","permalink":"https://lllovol.com/rocketmq/","title":"RocketMQ源码分享笔记"},{"content":"前言 主要用来记录整理最近一周工作学习中遇到，学到的一些小知识，积少成多，聚沙成塔\n小细节 Swagger-ui显示枚举类型的时候 定义的枚举类型的头上不需要加一些莫名其妙的注解，就可以在Swagger-ui界面自动生成\n public enum GreyTaskType { SCALE, PERSON, DEMAND, HOST ; }  Swagger-ui的参数显示的问题 这个是在帮忙解决朋友的问题的时候发现的，其实就是Getter的问题，他定义了俩Getter，这样就会有俩参数跑出来了。\n双向的验证 在两个模块相互依赖的时候，一方在进行某些操作的时候，需要判断另一方的状态，同样，另一方在进行某些操作的时候，也需要对这边的状态进行判断。 （主要是在删除和发布操作的时候）\nBurp Suite和Kali系统 能够用于web应用攻击的，主要使用这个工具来进行网络安全方面的测试。而Kali系统主要就是黑客使用的系统了，用于网络渗透\nSpring cloud配置中心 能够使用这个工具，实现项目发布在不同环境的情况下， 自行加载对应环境下的配置，而不再用手动修改\n配置的优先级顺序：  配置中心的/-(env).yml （一般不存在） 配置中心的application-env.yml （一般不存在） 配置中心的 /-test.yml 配置中心的application-test.yml 配置中心的 /.yml 配置中心的application.yml 项目内的application.yml  从上到下，优先级依次降低\ndebug的时候的细节 在debug的时候，停到某一行的时候，可以按optional+f8，可以单独对函数进行调试，包括修改参数等等操作\n栈和队列有什么区别 吃多了拉就是队列，吃多了吐就是栈（段子区看到的23333对栈和队列最形象生动的解释了）\nJava中的装箱和拆箱 这个是一个前辈教授于我的，同时还推荐了一些书籍给我\nspring 相关书籍推荐 spring boot 编程思想 原生类型，装箱和拆箱（int 和Integer） https://www.cnblogs.com/dolphin0520/p/3780005.html\n为什么会有装箱和拆箱 我的理解，是将一个基本类型装箱，变成一个类，比如int 比那成Integer，这样做了之后，就能赋予这个类其他的各种方法和函数操作。\n当然这只是我很浅显的理解，下面是我在网上查阅相关的资料所了解到原因\n 为什么会有装箱和拆箱 深入浅出java装箱和拆箱\n  将一个基本类型包装成一个类， 可以使得这个类有很多可以调用的方法 java还不算纯面向对象的语言，真正的面向对象，是没有基本数据类型的 在java的泛型中，基本类型是不能够作为泛型参数的，因此需要使用包装类的类型解决泛型参数的问题 这也是早期java的设计缺陷，基本的数据类型是数据，不是对象，也不是Object的子类，因此需要装箱，才能和其他的Object子类公用一个接口  基本数据类型和对应的包装类    基本数据类型 包装类     int（4字节） Integer   byte（1字节） Byte   short（2字节） Short   long（8字节） Long   float（4字节） Float   double（8字节） Double   char（2字节） Character   boolean（未定） Boolean    装箱和拆箱的过程  装箱过程：通过调用包装器的valueOf方法实现的 拆箱过程：通过调用包装器的xxxValue方法实现的。（xxx代表对应的基本数据类型）。  其他注意点  通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。有面试题考察Integer A=100，B=100，问A==B结果是什么，答案是true，但是如果是200的话，答案就是false。原因就是前面所说的那样。 Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现，因此上面那一点里面的题，如果是200.0的话，答案都是false。原因是因为，在某个范围内的整型数值的个数是有限的，但是浮点数的个数可以说是无数个。（Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。而Double、Float的实现方式是类似的） Boolean类型，在遇到上面的问题的时候，答案都是true Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别，前者不会触发自动装箱，后者会触发自动装箱，其次，在一般情况下，第二种执行方式在执行效率和资源占用方面优于第一种情况 对于包装类型，equals函数不会触发自动转换，  ","date":"2019-03-14T17:03:05Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg","permalink":"https://lllovol.com/spring8/","title":"SpringBoot开发中的一些小细节(八)装箱与拆箱，基本数据类型与包装类"},{"content":"前言 CRUD是平常业务开发过程中最常接触到的，因此想通过阅读这个最常接触模块的代码，使得自己能够更加深入的了解Spring，提升自己的技术能力，而不是只会CRUD，却都不知道它是怎么实现的。\nHibernate  Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm（Object Relational Mapping）框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，完成数据持久化的重任。Hibernate百科\n JPA  JPA诞生的缘由是为了整合第三方ORM框架，建立一种标准的方式，百度百科说是JDK为了实现ORM的天下归一，目前也是在按照这个方向发展，但是还没能完全实现。在ORM框架中，Hibernate是一支很大的部队，使用很广泛，也很方便，能力也很强，同时Hibernate也是和JPA整合的比较良好，我们可以认为JPA是标准，事实上也是，JPA几乎都是接口，实现都是Hibernate在做，宏观上面看，在JPA的统一之下Hibernate很良好的运行。\n我们都知道，在使用持久化工具的时候，一般都有一个对象来操作数据库，在原生的Hibernate中叫做Session，在JPA中叫做EntityManager，在MyBatis中叫做SqlSession，通过这个对象来操作数据库。我们一般按照三层结构来看的话，Service层做业务逻辑处理，Dao层和数据库打交道，在Dao中，就存在着上面的对象。那么ORM框架本身提供的功能有什么呢？答案是基本的CRUD，所有的基础CRUD框架都提供，我们使用起来感觉很方便，很给力，业务逻辑层面的处理ORM是没有提供的，如果使用原生的框架，业务逻辑代码我们一般会自定义，会自己去写SQL语句，然后执行。在这个时候，Spring-data-jpa的威力就体现出来了，ORM提供的能力他都提供，ORM框架没有提供的业务逻辑功能Spring-data-jpa也提供，全方位的解决用户的需求。使用Spring-data-jpa进行开发的过程中，常用的功能，我们几乎不需要写一条sql语句。\n  博文地址 JPA官方文档  应用实例 在大家的日常开发中都用到了很多，再次就不细致列举了，详情可以查看另外一篇博文\n Spring开发的小细节（六）\n 源码解析 Repository  @Indexed public interface Repository\u0026lt;T, ID\u0026gt; { }  CrudRepository 主要接口 CurdRepository\n public interface CrudRepository\u0026lt;T, ID\u0026gt; extends Repository\u0026lt;T, ID\u0026gt; { \u0026lt;S extends T\u0026gt; S save(S var1); \u0026lt;S extends T\u0026gt; Iterable\u0026lt;S\u0026gt; saveAll(Iterable\u0026lt;S\u0026gt; var1); Optional\u0026lt;T\u0026gt; findById(ID var1); boolean existsById(ID var1); Iterable\u0026lt;T\u0026gt; findAll(); Iterable\u0026lt;T\u0026gt; findAllById(Iterable\u0026lt;ID\u0026gt; var1); long count(); void deleteById(ID var1); void delete(T var1); void deleteAll(Iterable\u0026lt;? extends T\u0026gt; var1); void deleteAll(); }  MongoRepository\n @NoRepositoryBean public interface MongoRepository\u0026lt;T, ID\u0026gt; extends PagingAndSortingRepository\u0026lt;T, ID\u0026gt; , QueryByExampleExecutor\u0026lt;T\u0026gt; { \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; saveAll(Iterable\u0026lt;S\u0026gt; var1); List\u0026lt;T\u0026gt; findAll(); List\u0026lt;T\u0026gt; findAll(Sort var1); \u0026lt;S extends T\u0026gt; S insert(S var1); \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; insert(Iterable\u0026lt;S\u0026gt; var1); \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; findAll(Example\u0026lt;S\u0026gt; var1); \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; findAll(Example\u0026lt;S\u0026gt; var1, Sort var2); }  接口实现 除了SimpleKeyValueRepository的实现之外，还有SimpleMongoRepository、SimpleLdapRepository等的实现\n这里主要是看的是最Mongo的SimpleMongoRepository的接口实现\n public class SimpleMongoRepository\u0026lt;T, ID\u0026gt; implements MongoRepository\u0026lt;T, ID\u0026gt; { //定义了Mongo里面的各种操作的方法 private final MongoOperations mongoOperations; private final MongoEntityInformation\u0026lt;T, ID\u0026gt; entityInformation; public SimpleMongoRepository(MongoEntityInformation\u0026lt;T, ID\u0026gt; metadata , MongoOperations mongoOperations) { Assert.notNull(metadata, \u0026quot;MongoEntityInformation must not be null!\u0026quot;); Assert.notNull(mongoOperations, \u0026quot;MongoOperations must not be null!\u0026quot;); this.entityInformation = metadata; this.mongoOperations = mongoOperations; } public \u0026lt;S extends T\u0026gt; S save(S entity) { Assert.notNull(entity, \u0026quot;Entity must not be null!\u0026quot;); if(this.entityInformation.isNew(entity)) { this.mongoOperations.insert(entity, this.entityInformation.getCollectionName()); } else { this.mongoOperations.save(entity, this.entityInformation.getCollectionName()); } return entity; } public \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; saveAll(Iterable\u0026lt;S\u0026gt; entities) { Assert.notNull(entities, \u0026quot;The given Iterable of entities not be null!\u0026quot;); Streamable source = Streamable.of(entities); boolean allNew = source.stream().allMatch((it) -\u0026gt; { return this.entityInformation.isNew(it); }); if(allNew) { List result = (List)source.stream().collect(Collectors.toList()); this.mongoOperations.insert(result, this.entityInformation.getCollectionName()); return result; } else { return (List)source.stream().map(this::save).collect(Collectors.toList()); } } public Optional\u0026lt;T\u0026gt; findById(ID id) { Assert.notNull(id, \u0026quot;The given id must not be null!\u0026quot;); return Optional.ofNullable(this.mongoOperations .findById(id , this.entityInformation.getJavaType() , this.entityInformation.getCollectionName())); } public boolean existsById(ID id) { Assert.notNull(id, \u0026quot;The given id must not be null!\u0026quot;); return this.mongoOperations.exists(this.getIdQuery(id) , this.entityInformation.getJavaType() , this.entityInformation.getCollectionName()); } public long count() { return this.mongoOperations.getCollection(this .entityInformation .getCollectionName()).count(); } public void deleteById(ID id) { Assert.notNull(id, \u0026quot;The given id must not be null!\u0026quot;); this.mongoOperations.remove(this.getIdQuery(id) , this.entityInformation.getJavaType() , this.entityInformation.getCollectionName()); } public void delete(T entity) { Assert.notNull(entity, \u0026quot;The given entity must not be null!\u0026quot;); this.deleteById(this.entityInformation.getRequiredId(entity)); } public void deleteAll(Iterable\u0026lt;? extends T\u0026gt; entities) { Assert.notNull(entities, \u0026quot;The given Iterable of entities not be null!\u0026quot;); entities.forEach(this::delete); } public void deleteAll() { this.mongoOperations.remove(new Query() , this.entityInformation.getCollectionName()); } public List\u0026lt;T\u0026gt; findAll() { return this.findAll(new Query()); } public Iterable\u0026lt;T\u0026gt; findAllById(Iterable\u0026lt;ID\u0026gt; ids) { return this.findAll(new Query((new Criteria(this.entityInformation .getIdAttribute())) .in((Collection)Streamable .of(ids) .stream() .collect(StreamUtils.toUnmodifiableList())))); } public Page\u0026lt;T\u0026gt; findAll(Pageable pageable) { Assert.notNull(pageable, \u0026quot;Pageable must not be null!\u0026quot;); Long count = Long.valueOf(this.count()); List list = this.findAll((new Query()).with(pageable)); return new PageImpl(list, pageable, count.longValue()); } public List\u0026lt;T\u0026gt; findAll(Sort sort) { Assert.notNull(sort, \u0026quot;Sort must not be null!\u0026quot;); return this.findAll((new Query()).with(sort)); } public \u0026lt;S extends T\u0026gt; S insert(S entity) { Assert.notNull(entity, \u0026quot;Entity must not be null!\u0026quot;); this.mongoOperations.insert(entity, this.entityInformation.getCollectionName()); return entity; } public \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; insert(Iterable\u0026lt;S\u0026gt; entities) { Assert.notNull(entities, \u0026quot;The given Iterable of entities not be null!\u0026quot;); List list = (List)Streamable.of(entities) .stream().collect(StreamUtils.toUnmodifiableList()); if(list.isEmpty()) { return list; } else { this.mongoOperations.insertAll(list); return list; } } public \u0026lt;S extends T\u0026gt; Page\u0026lt;S\u0026gt; findAll(Example\u0026lt;S\u0026gt; example, Pageable pageable) { Assert.notNull(example, \u0026quot;Sample must not be null!\u0026quot;); Assert.notNull(pageable, \u0026quot;Pageable must not be null!\u0026quot;); Query q = (new Query((new Criteria()).alike(example))).with(pageable); List list = this.mongoOperations.find(q , example.getProbeType() , this.entityInformation.getCollectionName()); return PageableExecutionUtils.getPage(list, pageable, () -\u0026gt; { return this.mongoOperations.count(q , example.getProbeType() , this.entityInformation.getCollectionName()); }); } public \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; findAll(Example\u0026lt;S\u0026gt; example, Sort sort) { Assert.notNull(example, \u0026quot;Sample must not be null!\u0026quot;); Assert.notNull(sort, \u0026quot;Sort must not be null!\u0026quot;); Query q = (new Query((new Criteria()).alike(example))).with(sort); return this.mongoOperations.find(q , example.getProbeType() , this.entityInformation.getCollectionName()); } public \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; findAll(Example\u0026lt;S\u0026gt; example) { return this.findAll(example, Sort.unsorted()); } public \u0026lt;S extends T\u0026gt; Optional\u0026lt;S\u0026gt; findOne(Example\u0026lt;S\u0026gt; example) { Assert.notNull(example, \u0026quot;Sample must not be null!\u0026quot;); Query q = new Query((new Criteria()).alike(example)); return Optional.ofNullable( this.mongoOperations.findOne(q , example.getProbeType() , this.entityInformation.getCollectionName())); } public \u0026lt;S extends T\u0026gt; long count(Example\u0026lt;S\u0026gt; example) { Assert.notNull(example, \u0026quot;Sample must not be null!\u0026quot;); Query q = new Query((new Criteria()).alike(example)); return this.mongoOperations.count(q , example.getProbeType() , this.entityInformation.getCollectionName()); } public \u0026lt;S extends T\u0026gt; boolean exists(Example\u0026lt;S\u0026gt; example) { Assert.notNull(example, \u0026quot;Sample must not be null!\u0026quot;); Query q = new Query((new Criteria()).alike(example)); return this.mongoOperations.exists(q , example.getProbeType() , this.entityInformation.getCollectionName()); } private Query getIdQuery(Object id) { return new Query(this.getIdCriteria(id)); } private Criteria getIdCriteria(Object id) { return Criteria.where(this.entityInformation.getIdAttribute()).is(id); }findInRange(pageable.getOffset(), pageable.getPageSize(), pageable.getSort(), this.entityInformation.getJavaType()); private List\u0026lt;T\u0026gt; findAll(@Nullable Query query) { return query == null?Collections.emptyList():this.mongoOperations. find(query , this.entityInformation.getJavaType() , this.entityInformation.getCollectionName()); } }  ","date":"2019-03-11T19:28:16Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/5.jpg","permalink":"https://lllovol.com/springdatajpa/","title":"源码阅读SpringDataJPA"},{"content":"前言 IPC（Inter-Process Communication，进程间通信）\n有时候我们需要在不同的程序之间，也就是不同的进程之间进行通讯，那么都有些什么方式呢？通过查阅相关资料，主要有信号、管道、消息队列、共享内存等等\n 进程间通信的方式\n 常见的通讯方式  套接字Socket：套接字是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 信号量：信号量是一种计数器，主要是用来控制多个进程对共享资源的访问，在锁机制中应用比较多，保证在一个进程对一个资源进行访问的时候，其他进程不能对其进行资源访问 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 共享内存：内存共享是最快的IPC方式（SharedMemory）。就是映射一段其他进程也能够进行访问的内存。这一段内存虽然是由一个进程进行创建，但是多个进程都能进行访问。通常和信号量配合使用，来实现进程之间的同步和通信。 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n以上的任何一点都可以单独拿出来做一篇文章，路漫漫其修远兮  文章中已经写得很好了：）站在了巨人的肩膀上\n","date":"2019-03-05T16:22:56Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/4.jpg","permalink":"https://lllovol.com/inter-process/","title":"进程间通信的方式"},{"content":"前言 最近需要做一个将java对象转换成yaml文件格式的工作，由于手动进行操作的话效率会很低下，因此再找有没有合适的包可以使用。最后找到的工具就是yamlBeans,本文主要是翻译整理yamlBeans中的一部分信息\n yamlBeans官网\nyaml文档的学习\n 添加依赖 将下列代码添加到pom文件当中\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.esotericsoftware.yamlbeans\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;yamlbeans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Yaml反序列化为常见数据结构 所谓的反序列化，就是将yaml格式的文件，转换为java的常见数据结构 主要使用的类是YamlReader，然后可以将yaml文档转换为HashMap，ArrayList,还有Strings类型。\nyaml：\nname: Nathan Sweet age: 28 address: 4011 16th Ave S phone numbers: - name: Home number: 206-555-5138 - name: Work number: 425-555-2306  code:\nYamlReader reader = new YamlReader(new FileReader(\u0026quot;contact.yml\u0026quot;)); Object object = reader.read(); System.out.println(object); Map map = (Map)object; System.out.println(map.get(\u0026quot;address\u0026quot;));  Yaml反序列化为POJO 将yaml文档反序列化为pojo(plain ordinary java object)\nYaml and java class:\nname: Nathan Sweet age: 28 public class Contact { public String name; public int age; }  Code:\nYamlReader reader = new YamlReader(new FileReader(\u0026quot;contact.yml\u0026quot;)); Contact contact = reader.read(Contact.class); System.out.println(contact.age);  序列化为Yaml文档 这个地方就是与上方的反着来的，就是将java的常见的数据结构（HashMap,Sring,ArrayList都是可以的）或者pojo转换为yaml的文档，这里主要使用到的类是YamlWriter()\nexample:\nString yaml=\u0026quot;\u0026quot;; StringWriter stringWriter = new StringWriter(); YamlWriter writer = new YamlWriter(stringWriter); try { writer.write(greyTask); writer.close(); } catch (YamlException e) { log.error(\u0026quot;Grey Yaml Error\u0026quot;,e); } yaml = stringWriter.toString(); return yaml;  上方的是我自己写的例子，YamlWriter的构造函数所需要的参数，是一个writer（可以是fileWriter也可以是StringWriter，当然其他类型的writer也是可以的）\n输出的图像如下(fileWriter的)： 设置tag 有的时候tag会特别长，这个时候，就可以将自定义设置tag\ncode:\nYamlWriter writer = new YamlWriter(new FileWriter(\u0026quot;output.yml\u0026quot;)); writer.getConfig().setClassTag(\u0026quot;contact\u0026quot;, Contact.class); writer.write(contact); writer.close();  result:\n!contact name: Nathan Sweet age: 28  锚点Anchor 当出现指向同一个对象的时候，就会使用锚点\nyaml:\noldest friend: \u0026amp;1 !contact name: Bob age: 29 best friend: *1  上面的yaml文件中，\u0026amp;1 ！contact相当于定义了contact为1，然后使用*1来进行引用。默认来讲，yamlWriter在进行转换的时候，如果遇到了相同的对象会自动的输出锚点。\nContact contact = new Contact(); contact.name = \u0026quot;Bob\u0026quot;; contact.age = 29; Map map = new HashMap(); map.put(\u0026quot;oldest friend\u0026quot;, contact); map.put(\u0026quot;best friend\u0026quot;, contact);  ","date":"2019-02-22T21:46:09Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/3.jpg","permalink":"https://lllovol.com/yamlbeans/","title":"Yaml和Java对象之间的相互转换"},{"content":"前言 过年后第一次开始更新啦，这一篇主要就用来总结年后以来有意思，有用的一些信息\n在Controller中的一些注解 Controller的类型 主要有两种，一种是普通的,通常是被使用服务于web页面的。默认，你的controller方法返回的是一个string串，是表示要展示哪个模板页面或者是要跳转到哪里去。\n@Controller  另外一种是专门用在编写API的时候，返回一个JSON，或者是XML等等。然后方法返回的是可以是一个对象，或者是一个可以被序列化的对象。\n@RestController  路由的类型 这里的路由就是指http method。（GET,POST,PUT,PATCH,DELETE）。\n@GetMapping @PostMapping @PutMapping @PatchMapping @DeleteMapping  同时，在Controller上面可以加上一个@RequestMapping，可以将所有类型路由的前缀都放在上面\n@RestController @Slf4j @Api(tags = \u0026quot;11. xxxxx\u0026quot;) @RequestMapping(\u0026quot;/api/v1\u0026quot;) @RequiredArgsConstructor public class DataController { private final DataService dataService; @ApiOperation(\u0026quot;11.1 xxxx\u0026quot;) @GetMapping(\u0026quot;/statistics\u0026quot;) public Response\u0026lt;DataDeployDto\u0026gt; deployTask(@Validated DataParam query){ log.info(\u0026quot;data Query {}\u0026quot;, JSONObject.toJSON(query)); return ResponseUtil.makeSuccess(dataService.deployData(query)); } }  在Controller内的传参的注解 @ApiOperation(\u0026quot;1.1 创建业务线\u0026quot;) @PostMapping(\u0026quot;/save\u0026quot;) public Response save(@RequestBody @Validated CustomProductAddParam customProductAddDto) { log.info(\u0026quot;save() {}\u0026quot;, JSONObject.toJSON(customProductAddDto)); customProductService.save(customProductAddDto, true); return ResponseUtil.makeSuccess(null); }  @RequestBody 就是要求传的数据是一个json格式的body传入的，这样前端会比较麻烦，因此在不需要的时候可以将这个注解取消掉\n有@RequestBody\n无@RequestBody\n@Validated 就是在传参的时候需要判断验证，比如是不是为空什么（NotNull）\n空指针的问题 这是个老问题了，前面什么都没传的时候，到后端的时候是变成的null，CollectionUtils.isEmpty()可以用来判断Collection是空还是null，源码实现如下\npublic static boolean isEmpty(Collection coll) { return (coll == null || coll.isEmpty()); }  Int到Long的转换 Long count = (long) all.size();  强制转换int到long，注意括号里面是小写\nMongoDBTemplate的查询分页 @Override public PagerData\u0026lt;GreyTask\u0026gt; list(GreyTaskListParam param) { Criteria criteria = new Criteria(); if (StringUtils.isNotEmpty(param.getName())) { criteria.and(\u0026quot;name\u0026quot;).regex(param.getName()); } if (StringUtils.isNotEmpty(param.getType().toString())) { criteria.and(\u0026quot;type\u0026quot;).is(param.getType()); } Query query = new Query(); query.addCriteria(criteria) .with(new Sort(Sort.Direction.DESC, \u0026quot;createTime\u0026quot;)) .skip(param.getSkip()).limit(param.getPageSize()); List\u0026lt;GreyTask\u0026gt; all = greyTaskRepo.findAll(query); Long count = (long) all.size(); return new PagerData\u0026lt;\u0026gt;(all, count, param.getPageSize(), param.getPageNo()); }  阿里云域名备案 会有一个验证短信，要自己上网页去验证，不要因为自己疏忽就忘了，然后就被打回来了QAQ，开始以为是什么骚扰短信呢\nKali Linux 黑客专用的系统，有空的时候可以看看，学习一下系统安全知识\nGFW 自己搭的vpn突然用不了，后来发现就是被墙了（ip banned），解决方式，就是换一个ip\n","date":"2019-02-20T11:35:51Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg","permalink":"https://lllovol.com/spring7/","title":"SpringBoot开发中的一些小细节(七)Controller路由以及分页查询"},{"content":"两种标签 Spring中的标签的包括默认的标签和自定义的标签两种，而这两种标签的用法和解析方式存在着很大的不同。\n默认标签的解析 默认标签的解析是在parseDefaultElement函数中进行的，函数中的功能逻辑一目了然，分别对4种不同的标签做了不同的处理：\n import alias bean beans  bean标签的解析以及注册 在4种标签的解析中，对bean的解析最为复杂也最为重要。因此由此深入，如果将此标签的解析过程理解了，其他标签的解析自然也会迎刃而解。\nprocessBeanDefinition（ele,delegate） /** * Process the given bean element, parsing the bean definition * and registering it with the registry. */ protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(\u0026quot;Failed to register bean definition with name '\u0026quot; + bdHolder.getBeanName() + \u0026quot;'\u0026quot;, ele, ex); } // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); } }   首先委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析，返回BeanDefinitionHolder类型的实例bdHolder。在这个方法之后，bdHolder实例已经包含了我们配置中的各种属性了，例如class、name、id、alias之类的属性了。 当返回的bdHolder不为空的情况下，如果存在默认标签下的子节点下再有自定义属性，还需要在此对自定义标签进行解析。 解析完成后，需要对解析后的bdHolder进行注册，同样，注册操作委托给了BeanDefinitionReaderUtils的registerBeanDefinition方法。 最后发出响应时间，通知相关的监听器，在这个时候，这个bean已经加载完成了。  解析BeanDefinition /** * Parses the supplied {@code \u0026lt;bean\u0026gt;} element. May return {@code null} * if there were errors during parse. Errors are reported to the * {@link org.springframework.beans.factory.parsing.ProblemReporter}. */ @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) { return parseBeanDefinitionElement(ele, null); } /** * Parses the supplied {@code \u0026lt;bean\u0026gt;} element. May return {@code null} * if there were errors during parse. Errors are reported to the * {@link org.springframework.beans.factory.parsing.ProblemReporter}. */ @Nullable public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) { //解析id的属性 String id = ele.getAttribute(ID_ATTRIBUTE); //解析name的属性 String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); //分割name的属性 List\u0026lt;String\u0026gt; aliases = new ArrayList\u0026lt;\u0026gt;(); if (StringUtils.hasLength(nameAttr)) { String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); } String beanName = id; if (!StringUtils.hasText(beanName) \u0026amp;\u0026amp; !aliases.isEmpty()) { beanName = aliases.remove(0); if (logger.isDebugEnabled()) { logger.debug(\u0026quot;No XML 'id' specified - using '\u0026quot; + beanName + \u0026quot;' as bean name and \u0026quot; + aliases + \u0026quot; as aliases\u0026quot;); } } if (containingBean == null) { checkNameUniqueness(beanName, aliases, ele); } //对标签中其他属性的解析过程 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); if (beanDefinition != null) { if (!StringUtils.hasText(beanName)) { try { //如果bean没有beanName，就使用默认方法生成beanName if (containingBean != null) { beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); } else { beanName = this.readerContext.generateBeanName(beanDefinition); // Register an alias for the plain bean class name, if still possible, // if the generator returned the class name plus a suffix. // This is expected for Spring 1.2/2.0 backwards compatibility. String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null \u0026amp;\u0026amp; beanName.startsWith(beanClassName) \u0026amp;\u0026amp; beanName.length() \u0026gt; beanClassName.length() \u0026amp;\u0026amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) { aliases.add(beanClassName); } } if (logger.isDebugEnabled()) { logger.debug(\u0026quot;Neither XML 'id' nor 'name' specified - \u0026quot; + \u0026quot;using generated bean name [\u0026quot; + beanName + \u0026quot;]\u0026quot;); } } catch (Exception ex) { error(ex.getMessage(), ele); return null; } } String[] aliasesArray = StringUtils.toStringArray(aliases); return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); } return null; }  在当前层，完成的主要工作如下：\n 1.提取了元素中的id和name属性 2.进一步解析其他所有属性并封装至AbstractBeanDefinition类型的实例中 3.如果检测到bean没有指定beanName，那么使用默认的规则为此Bean生成BeanName 4.将获取到的信息封装到BeanDefinitionHolder的实例中  接下来我们接着来看一下步骤2中的对标签其他属性的解析过程：\n/** * Parse the bean definition itself, without regard to name or aliases. May return * {@code null} if problems occurred during the parsing of the bean definition. */ @Nullable public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, @Nullable BeanDefinition containingBean) { this.parseState.push(new BeanEntry(beanName)); //解析class属性 String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) { className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); } //解析parent属性 String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) { parent = ele.getAttribute(PARENT_ATTRIBUTE); } try { //使用className和parent创建一个用于承载各种属性的AbstractBeanDefinition实例 bd AbstractBeanDefinition bd = createBeanDefinition(className, parent); //硬编码解析默认bean的各种属性 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); //提取description bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); //解析元数据 parseMetaElements(ele, bd); //解析lookup-method属性 parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); //解析replace-method属性 parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); //解析构造函数参数 parseConstructorArgElements(ele, bd); //解析property子元素 parsePropertyElements(ele, bd); //解析qualified子元素 parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; } catch (ClassNotFoundException ex) { error(\u0026quot;Bean class [\u0026quot; + className + \u0026quot;] not found\u0026quot;, ele, ex); } catch (NoClassDefFoundError err) { error(\u0026quot;Class that bean class [\u0026quot; + className + \u0026quot;] depends on not found\u0026quot;, ele, err); } catch (Throwable ex) { error(\u0026quot;Unexpected failure during bean definition parsing\u0026quot;, ele, ex); } finally { this.parseState.pop(); } return null; }  bean标签的所有属性，不论是常用的还是不常用的我们都按到了，尽管有些复杂的属性需要进一步解析。接下来主要就是看一些复杂标签属性的解析。\n创建用于属性承载的BeanDefinition（CreateBeanDefinition） BeanDefinition是一个接口，在Spring中存在三种实现：RootBeanDefinition，ChildBeanDefinition,GenericBeanDefinition。三种实现方式均集成了AbstractBeanDefinition，其中BeanDefinition是配置文件元素标签的内部表示形式。（元素标签拥有class、scope、lazy-init等配置属性，而BeanDefinition咋提供了相应的beanClass、scope、LazyInit属性，BeanDefinition和中的属性是一一对应的。其中RootBeanDefinition是最常用的实现类）。\n在配置文件中可以定义父和子，父使用RootBeanDefinition来表示，子使用ChildBeanDefinition来表示，而没有父的就用RootBeanDefinition来表示。AbstractBeanDefinition对两者共同的类信息进行抽象。 Spring通过BeanDefinition将配置文件中的配置信息转化为容器的内部表示，然后将这些BeanDefinition注册到BeanDefinitionRegistry当中。\n要解析属性，首先要创建用于承载属性的实例，也就是创建GenericBeanDefinition类型的实例，而 AbstractBeanDefinition bd = createBeanDefinition(className, parent);就是实现这个功能\n/** * Create a new GenericBeanDefinition for the given parent name and class name, * eagerly loading the bean class if a ClassLoader has been specified. * @param parentName the name of the parent bean, if any * @param className the name of the bean class, if any * @param classLoader the ClassLoader to use for loading bean classes * (can be {@code null} to just register bean classes by name) * @return the bean definition * @throws ClassNotFoundException if the bean class could not be loaded */ public static AbstractBeanDefinition createBeanDefinition( @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException { GenericBeanDefinition bd = new GenericBeanDefinition(); bd.setParentName(parentName); if (className != null) { if (classLoader != null) { //如果classLoader不为空，则使用以传入的classLoader同一虚拟机加载类对象，否则只是记录ClassName bd.setBeanClass(ClassUtils.forName(className, classLoader)); } else { bd.setBeanClassName(className); } } return bd; }  解析各种属性(parseBeanDefinitionAttributes方法) 在上一步，创建了Bean信息的承载实例字后，就可以进行bean信息的各种属性的解析了。我们进入到parseBeanDefinitionAttributes方法。\n/** * Apply the attributes of the given bean element to the given bean * definition. * @param ele bean declaration element * @param beanName bean name * @param containingBean containing bean definition * @return a bean definition initialized according to the bean element attributes */ public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName, @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) { //判断是否是单例的属性，如果有的话需要报错 if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) { error(\u0026quot;Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration\u0026quot;, ele); } //解析scope属性 else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) { bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE)); } else if (containingBean != null) { // Take default from containing bean in case of an inner bean definition. //如果在嵌入beanDefinition情况下且没有单独制定scope属性的时候则使用父类默认的属性 bd.setScope(containingBean.getScope()); } //解析Abstract属性 if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) { bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE))); } //解析lazy-Init属性 String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE); if (DEFAULT_VALUE.equals(lazyInit)) { lazyInit = this.defaults.getLazyInit(); } bd.setLazyInit(TRUE_VALUE.equals(lazyInit)); //解析autowire属性 String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE); bd.setAutowireMode(getAutowireMode(autowire)); //解析depend-on的属性 if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) { String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE); bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS)); } //解析autowireCandidate属性 String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE); if (\u0026quot;\u0026quot;.equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) { String candidatePattern = this.defaults.getAutowireCandidates(); if (candidatePattern != null) { String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern); bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName)); } } else { bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate)); } //解析primary属性 if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) { bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE))); } //解析init-method属性 if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) { String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE); bd.setInitMethodName(initMethodName); } else if (this.defaults.getInitMethod() != null) { bd.setInitMethodName(this.defaults.getInitMethod()); bd.setEnforceInitMethod(false); } //解析destroy-method属性 if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) { String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE); bd.setDestroyMethodName(destroyMethodName); } else if (this.defaults.getDestroyMethod() != null) { bd.setDestroyMethodName(this.defaults.getDestroyMethod()); bd.setEnforceDestroyMethod(false); } //解析factory-method属性 if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) { bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE)); } //解析factory-bean属性 if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) { bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE)); } return bd; }  我们可以看到，这个方法完成了对所有bean属性的解析。\n解析子元素meta meta属性的使用 \u0026lt;bean id=\u0026quot;myTestBean\u0026quot; class=\u0026quot;bean.myTestBean\u0026quot;\u0026gt; \u0026lt;meta key = \u0026quot;testStr\u0026quot; value = \u0026quot;aaaaaaaaa\u0026quot;\u0026gt; \u0026lt;/bean\u0026gt;  这段代码并不会体现在MyTestBean的属性当中，而是一个额外的声明，当需要使用里面的信息的时候可以通过BeanDefinition的getAttribute(key)的方法获取\n对meta属性的解析代码如下 public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) { //获取当前节点 NodeList nl = ele.getChildNodes(); for (int i = 0; i \u0026lt; nl.getLength(); i++) { //提取meta Node node = nl.item(i); if (isCandidateElement(node) \u0026amp;\u0026amp; nodeNameEquals(node, META_ELEMENT)) { Element metaElement = (Element) node; String key = metaElement.getAttribute(KEY_ATTRIBUTE); String value = metaElement.getAttribute(VALUE_ATTRIBUTE); //使用key和value构造BeanMetadataAttribute BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value); attribute.setSource(extractSource(metaElement)); //记录信息 attributeAccessor.addMetadataAttribute(attribute); } } }  解析子元素lookup-method 这个属性不是很常用，通常称这个为获取器注入。（P44）\n解析子元素replaced-method 方法替换：可以在运行时用新的方法替换现有的方法。replaced-method不但可以动态返回实体bean，而且还能动态地更改原有方法的逻辑。（P46）\n解析子元素constructor-arg 对构造函数进行的解析（P48）\n解析子元素property p53\n解析子元素qualifier p54\nAbstractBeanDefinition属性 至此完成了XML文档到GenericBeanDefinition的转换。但是Generic只是子类实现，大部分通用的属性都是保存在AbstractBeanDefinition这个类中的。下面查看了一下spring boot的AbstractBeanDefinition,和书中的spring 的差别还是很大的\n/** * Base class for concrete, full-fledged {@link BeanDefinition} classes, * factoring out common properties of {@link GenericBeanDefinition}, * {@link RootBeanDefinition}, and {@link ChildBeanDefinition}. * * \u0026lt;p\u0026gt;The autowire constants match the ones defined in the * {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory} * interface. * * @author Rod Johnson * @author Juergen Hoeller * @author Rob Harrop * @author Mark Fisher * @see GenericBeanDefinition * @see RootBeanDefinition * @see ChildBeanDefinition */ @SuppressWarnings(\u0026quot;serial\u0026quot;) public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor implements BeanDefinition, Cloneable { /** * Constant for the default scope name: {@code \u0026quot;\u0026quot;}, equivalent to singleton * status unless overridden from a parent bean definition (if applicable). */ public static final String SCOPE_DEFAULT = \u0026quot;\u0026quot;; /** * Constant that indicates no autowiring at all. * @see #setAutowireMode */ public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO; /** * Constant that indicates autowiring bean properties by name. * @see #setAutowireMode */ public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME; /** * Constant that indicates autowiring bean properties by type. * @see #setAutowireMode */ public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE; /** * Constant that indicates autowiring a constructor. * @see #setAutowireMode */ public static final int AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR; /** * Constant that indicates determining an appropriate autowire strategy * through introspection of the bean class. * @see #setAutowireMode * @deprecated as of Spring 3.0: If you are using mixed autowiring strategies, * use annotation-based autowiring for clearer demarcation of autowiring needs. */ @Deprecated public static final int AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT; /** * Constant that indicates no dependency check at all. * @see #setDependencyCheck */ public static final int DEPENDENCY_CHECK_NONE = 0; /** * Constant that indicates dependency checking for object references. * @see #setDependencyCheck */ public static final int DEPENDENCY_CHECK_OBJECTS = 1; /** * Constant that indicates dependency checking for \u0026quot;simple\u0026quot; properties. * @see #setDependencyCheck * @see org.springframework.beans.BeanUtils#isSimpleProperty */ public static final int DEPENDENCY_CHECK_SIMPLE = 2; /** * Constant that indicates dependency checking for all properties * (object references as well as \u0026quot;simple\u0026quot; properties). * @see #setDependencyCheck */ public static final int DEPENDENCY_CHECK_ALL = 3; /** * Constant that indicates the container should attempt to infer the * {@link #setDestroyMethodName destroy method name} for a bean as opposed to * explicit specification of a method name. The value {@value} is specifically * designed to include characters otherwise illegal in a method name, ensuring * no possibility of collisions with legitimately named methods having the same * name. * \u0026lt;p\u0026gt;Currently, the method names detected during destroy method inference * are \u0026quot;close\u0026quot; and \u0026quot;shutdown\u0026quot;, if present on the specific bean class. */ public static final String INFER_METHOD = \u0026quot;(inferred)\u0026quot;; @Nullable private volatile Object beanClass; //bean的作用范围，对应bean属性scope @Nullable private String scope = SCOPE_DEFAULT; private boolean abstractFlag = false; private boolean lazyInit = false; private int autowireMode = AUTOWIRE_NO; private int dependencyCheck = DEPENDENCY_CHECK_NONE; @Nullable private String[] dependsOn; private boolean autowireCandidate = true; private boolean primary = false; private final Map\u0026lt;String, AutowireCandidateQualifier\u0026gt; qualifiers = new LinkedHashMap\u0026lt;\u0026gt;(0); @Nullable private Supplier\u0026lt;?\u0026gt; instanceSupplier; private boolean nonPublicAccessAllowed = true; private boolean lenientConstructorResolution = true; @Nullable private String factoryBeanName; @Nullable private String factoryMethodName; @Nullable private ConstructorArgumentValues constructorArgumentValues; @Nullable private MutablePropertyValues propertyValues; @Nullable private MethodOverrides methodOverrides; @Nullable private String initMethodName; @Nullable private String destroyMethodName; private boolean enforceInitMethod = true; private boolean enforceDestroyMethod = true; private boolean synthetic = false; private int role = BeanDefinition.ROLE_APPLICATION; @Nullable private String description; @Nullable private Resource resource; /** * Create a new AbstractBeanDefinition with default settings. */ protected AbstractBeanDefinition() { this(null, null); } /** * Create a new AbstractBeanDefinition with the given * constructor argument values and property values. */ protected AbstractBeanDefinition(@Nullable ConstructorArgumentValues cargs, @Nullable MutablePropertyValues pvs) { this.constructorArgumentValues = cargs; this.propertyValues = pvs; } /** * Create a new AbstractBeanDefinition as a deep copy of the given * bean definition. * @param original the original bean definition to copy from */ protected AbstractBeanDefinition(BeanDefinition original) { setParentName(original.getParentName()); setBeanClassName(original.getBeanClassName()); setScope(original.getScope()); setAbstract(original.isAbstract()); setLazyInit(original.isLazyInit()); setFactoryBeanName(original.getFactoryBeanName()); setFactoryMethodName(original.getFactoryMethodName()); setRole(original.getRole()); setSource(original.getSource()); copyAttributesFrom(original); if (original instanceof AbstractBeanDefinition) { AbstractBeanDefinition originalAbd = (AbstractBeanDefinition) original; if (originalAbd.hasBeanClass()) { setBeanClass(originalAbd.getBeanClass()); } if (originalAbd.hasConstructorArgumentValues()) { setConstructorArgumentValues(new ConstructorArgumentValues(original.getConstructorArgumentValues())); } if (originalAbd.hasPropertyValues()) { setPropertyValues(new MutablePropertyValues(original.getPropertyValues())); } if (originalAbd.hasMethodOverrides()) { setMethodOverrides(new MethodOverrides(originalAbd.getMethodOverrides())); } setAutowireMode(originalAbd.getAutowireMode()); setDependencyCheck(originalAbd.getDependencyCheck()); setDependsOn(originalAbd.getDependsOn()); setAutowireCandidate(originalAbd.isAutowireCandidate()); setPrimary(originalAbd.isPrimary()); copyQualifiersFrom(originalAbd); setInstanceSupplier(originalAbd.getInstanceSupplier()); setNonPublicAccessAllowed(originalAbd.isNonPublicAccessAllowed()); setLenientConstructorResolution(originalAbd.isLenientConstructorResolution()); setInitMethodName(originalAbd.getInitMethodName()); setEnforceInitMethod(originalAbd.isEnforceInitMethod()); setDestroyMethodName(originalAbd.getDestroyMethodName()); setEnforceDestroyMethod(originalAbd.isEnforceDestroyMethod()); setSynthetic(originalAbd.isSynthetic()); setResource(originalAbd.getResource()); } else { setConstructorArgumentValues(new ConstructorArgumentValues(original.getConstructorArgumentValues())); setPropertyValues(new MutablePropertyValues(original.getPropertyValues())); setResourceDescription(original.getResourceDescription()); } } /** * Override settings in this bean definition (presumably a copied parent * from a parent-child inheritance relationship) from the given bean * definition (presumably the child). * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;Will override beanClass if specified in the given bean definition. * \u0026lt;li\u0026gt;Will always take {@code abstract}, {@code scope}, * {@code lazyInit}, {@code autowireMode}, {@code dependencyCheck}, * and {@code dependsOn} from the given bean definition. * \u0026lt;li\u0026gt;Will add {@code constructorArgumentValues}, {@code propertyValues}, * {@code methodOverrides} from the given bean definition to existing ones. * \u0026lt;li\u0026gt;Will override {@code factoryBeanName}, {@code factoryMethodName}, * {@code initMethodName}, and {@code destroyMethodName} if specified * in the given bean definition. * \u0026lt;/ul\u0026gt; */ public void overrideFrom(BeanDefinition other) { if (StringUtils.hasLength(other.getBeanClassName())) { setBeanClassName(other.getBeanClassName()); } if (StringUtils.hasLength(other.getScope())) { setScope(other.getScope()); } setAbstract(other.isAbstract()); setLazyInit(other.isLazyInit()); if (StringUtils.hasLength(other.getFactoryBeanName())) { setFactoryBeanName(other.getFactoryBeanName()); } if (StringUtils.hasLength(other.getFactoryMethodName())) { setFactoryMethodName(other.getFactoryMethodName()); } setRole(other.getRole()); setSource(other.getSource()); copyAttributesFrom(other); if (other instanceof AbstractBeanDefinition) { AbstractBeanDefinition otherAbd = (AbstractBeanDefinition) other; if (otherAbd.hasBeanClass()) { setBeanClass(otherAbd.getBeanClass()); } if (otherAbd.hasConstructorArgumentValues()) { getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues()); } if (otherAbd.hasPropertyValues()) { getPropertyValues().addPropertyValues(other.getPropertyValues()); } if (otherAbd.hasMethodOverrides()) { getMethodOverrides().addOverrides(otherAbd.getMethodOverrides()); } setAutowireMode(otherAbd.getAutowireMode()); setDependencyCheck(otherAbd.getDependencyCheck()); setDependsOn(otherAbd.getDependsOn()); setAutowireCandidate(otherAbd.isAutowireCandidate()); setPrimary(otherAbd.isPrimary()); copyQualifiersFrom(otherAbd); setInstanceSupplier(otherAbd.getInstanceSupplier()); setNonPublicAccessAllowed(otherAbd.isNonPublicAccessAllowed()); setLenientConstructorResolution(otherAbd.isLenientConstructorResolution()); if (otherAbd.getInitMethodName() != null) { setInitMethodName(otherAbd.getInitMethodName()); setEnforceInitMethod(otherAbd.isEnforceInitMethod()); } if (otherAbd.getDestroyMethodName() != null) { setDestroyMethodName(otherAbd.getDestroyMethodName()); setEnforceDestroyMethod(otherAbd.isEnforceDestroyMethod()); } setSynthetic(otherAbd.isSynthetic()); setResource(otherAbd.getResource()); } else { getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues()); getPropertyValues().addPropertyValues(other.getPropertyValues()); setResourceDescription(other.getResourceDescription()); } } /** * Apply the provided default values to this bean. * @param defaults the defaults to apply */ public void applyDefaults(BeanDefinitionDefaults defaults) { setLazyInit(defaults.isLazyInit()); setAutowireMode(defaults.getAutowireMode()); setDependencyCheck(defaults.getDependencyCheck()); setInitMethodName(defaults.getInitMethodName()); setEnforceInitMethod(false); setDestroyMethodName(defaults.getDestroyMethodName()); setEnforceDestroyMethod(false); } /** * Specify the bean class name of this bean definition. */ @Override public void setBeanClassName(@Nullable String beanClassName) { this.beanClass = beanClassName; } /** * Return the current bean class name of this bean definition. */ @Override @Nullable public String getBeanClassName() { Object beanClassObject = this.beanClass; if (beanClassObject instanceof Class) { return ((Class\u0026lt;?\u0026gt;) beanClassObject).getName(); } else { return (String) beanClassObject; } } /** * Specify the class for this bean. */ public void setBeanClass(@Nullable Class\u0026lt;?\u0026gt; beanClass) { this.beanClass = beanClass; } /** * Return the class of the wrapped bean, if already resolved. * @return the bean class, or {@code null} if none defined * @throws IllegalStateException if the bean definition does not define a bean class, * or a specified bean class name has not been resolved into an actual Class */ public Class\u0026lt;?\u0026gt; getBeanClass() throws IllegalStateException { Object beanClassObject = this.beanClass; if (beanClassObject == null) { throw new IllegalStateException(\u0026quot;No bean class specified on bean definition\u0026quot;); } if (!(beanClassObject instanceof Class)) { throw new IllegalStateException( \u0026quot;Bean class name [\u0026quot; + beanClassObject + \u0026quot;] has not been resolved into an actual Class\u0026quot;); } return (Class\u0026lt;?\u0026gt;) beanClassObject; } /** * Return whether this definition specifies a bean class. */ public boolean hasBeanClass() { return (this.beanClass instanceof Class); } /** * Determine the class of the wrapped bean, resolving it from a * specified class name if necessary. Will also reload a specified * Class from its name when called with the bean class already resolved. * @param classLoader the ClassLoader to use for resolving a (potential) class name * @return the resolved bean class * @throws ClassNotFoundException if the class name could be resolved */ @Nullable public Class\u0026lt;?\u0026gt; resolveBeanClass(@Nullable ClassLoader classLoader) throws ClassNotFoundException { String className = getBeanClassName(); if (className == null) { return null; } Class\u0026lt;?\u0026gt; resolvedClass = ClassUtils.forName(className, classLoader); this.beanClass = resolvedClass; return resolvedClass; } /** * Set the name of the target scope for the bean. * \u0026lt;p\u0026gt;The default is singleton status, although this is only applied once * a bean definition becomes active in the containing factory. A bean * definition may eventually inherit its scope from a parent bean definition. * For this reason, the default scope name is an empty string (i.e., {@code \u0026quot;\u0026quot;}), * with singleton status being assumed until a resolved scope is set. * @see #SCOPE_SINGLETON * @see #SCOPE_PROTOTYPE */ @Override public void setScope(@Nullable String scope) { this.scope = scope; } /** * Return the name of the target scope for the bean. */ @Override @Nullable public String getScope() { return this.scope; } /** * Return whether this a \u0026lt;b\u0026gt;Singleton\u0026lt;/b\u0026gt;, with a single shared instance * returned from all calls. * @see #SCOPE_SINGLETON */ @Override public boolean isSingleton() { return SCOPE_SINGLETON.equals(scope) || SCOPE_DEFAULT.equals(scope); } /** * Return whether this a \u0026lt;b\u0026gt;Prototype\u0026lt;/b\u0026gt;, with an independent instance * returned for each call. * @see #SCOPE_PROTOTYPE */ @Override public boolean isPrototype() { return SCOPE_PROTOTYPE.equals(scope); } /** * Set if this bean is \u0026quot;abstract\u0026quot;, i.e. not meant to be instantiated itself but * rather just serving as parent for concrete child bean definitions. * \u0026lt;p\u0026gt;Default is \u0026quot;false\u0026quot;. Specify true to tell the bean factory to not try to * instantiate that particular bean in any case. */ public void setAbstract(boolean abstractFlag) { this.abstractFlag = abstractFlag; } /** * Return whether this bean is \u0026quot;abstract\u0026quot;, i.e. not meant to be instantiated * itself but rather just serving as parent for concrete child bean definitions. */ @Override public boolean isAbstract() { return this.abstractFlag; } /** * Set whether this bean should be lazily initialized. * \u0026lt;p\u0026gt;If {@code false}, the bean will get instantiated on startup by bean * factories that perform eager initialization of singletons. */ @Override public void setLazyInit(boolean lazyInit) { this.lazyInit = lazyInit; } /** * Return whether this bean should be lazily initialized, i.e. not * eagerly instantiated on startup. Only applicable to a singleton bean. */ @Override public boolean isLazyInit() { return this.lazyInit; } /** * Set the autowire mode. This determines whether any automagical detection * and setting of bean references will happen. Default is AUTOWIRE_NO, * which means there's no autowire. * @param autowireMode the autowire mode to set. * Must be one of the constants defined in this class. * @see #AUTOWIRE_NO * @see #AUTOWIRE_BY_NAME * @see #AUTOWIRE_BY_TYPE * @see #AUTOWIRE_CONSTRUCTOR * @see #AUTOWIRE_AUTODETECT */ public void setAutowireMode(int autowireMode) { this.autowireMode = autowireMode; } /** * Return the autowire mode as specified in the bean definition. */ public int getAutowireMode() { return this.autowireMode; } /** * Return the resolved autowire code, * (resolving AUTOWIRE_AUTODETECT to AUTOWIRE_CONSTRUCTOR or AUTOWIRE_BY_TYPE). * @see #AUTOWIRE_AUTODETECT * @see #AUTOWIRE_CONSTRUCTOR * @see #AUTOWIRE_BY_TYPE */ public int getResolvedAutowireMode() { if (this.autowireMode == AUTOWIRE_AUTODETECT) { // Work out whether to apply setter autowiring or constructor autowiring. // If it has a no-arg constructor it's deemed to be setter autowiring, // otherwise we'll try constructor autowiring. Constructor\u0026lt;?\u0026gt;[] constructors = getBeanClass().getConstructors(); for (Constructor\u0026lt;?\u0026gt; constructor : constructors) { if (constructor.getParameterCount() == 0) { return AUTOWIRE_BY_TYPE; } } return AUTOWIRE_CONSTRUCTOR; } else { return this.autowireMode; } } /** * Set the dependency check code. * @param dependencyCheck the code to set. * Must be one of the four constants defined in this class. * @see #DEPENDENCY_CHECK_NONE * @see #DEPENDENCY_CHECK_OBJECTS * @see #DEPENDENCY_CHECK_SIMPLE * @see #DEPENDENCY_CHECK_ALL */ public void setDependencyCheck(int dependencyCheck) { this.dependencyCheck = dependencyCheck; } /** * Return the dependency check code. */ public int getDependencyCheck() { return this.dependencyCheck; } /** * Set the names of the beans that this bean depends on being initialized. * The bean factory will guarantee that these beans get initialized first. * \u0026lt;p\u0026gt;Note that dependencies are normally expressed through bean properties or * constructor arguments. This property should just be necessary for other kinds * of dependencies like statics (*ugh*) or database preparation on startup. */ @Override public void setDependsOn(@Nullable String... dependsOn) { this.dependsOn = dependsOn; } /** * Return the bean names that this bean depends on. */ @Override @Nullable public String[] getDependsOn() { return this.dependsOn; } /** * Set whether this bean is a candidate for getting autowired into some other bean. * \u0026lt;p\u0026gt;Note that this flag is designed to only affect type-based autowiring. * It does not affect explicit references by name, which will get resolved even * if the specified bean is not marked as an autowire candidate. As a consequence, * autowiring by name will nevertheless inject a bean if the name matches. * @see #AUTOWIRE_BY_TYPE * @see #AUTOWIRE_BY_NAME */ @Override public void setAutowireCandidate(boolean autowireCandidate) { this.autowireCandidate = autowireCandidate; } /** * Return whether this bean is a candidate for getting autowired into some other bean. */ @Override public boolean isAutowireCandidate() { return this.autowireCandidate; } /** * Set whether this bean is a primary autowire candidate. * \u0026lt;p\u0026gt;If this value is {@code true} for exactly one bean among multiple * matching candidates, it will serve as a tie-breaker. */ @Override public void setPrimary(boolean primary) { this.primary = primary; } /** * Return whether this bean is a primary autowire candidate. */ @Override public boolean isPrimary() { return this.primary; } /** * Register a qualifier to be used for autowire candidate resolution, * keyed by the qualifier's type name. * @see AutowireCandidateQualifier#getTypeName() */ public void addQualifier(AutowireCandidateQualifier qualifier) { this.qualifiers.put(qualifier.getTypeName(), qualifier); } /** * Return whether this bean has the specified qualifier. */ public boolean hasQualifier(String typeName) { return this.qualifiers.keySet().contains(typeName); } /** * Return the qualifier mapped to the provided type name. */ @Nullable public AutowireCandidateQualifier getQualifier(String typeName) { return this.qualifiers.get(typeName); } /** * Return all registered qualifiers. * @return the Set of {@link AutowireCandidateQualifier} objects. */ public Set\u0026lt;AutowireCandidateQualifier\u0026gt; getQualifiers() { return new LinkedHashSet\u0026lt;\u0026gt;(this.qualifiers.values()); } /** * Copy the qualifiers from the supplied AbstractBeanDefinition to this bean definition. * @param source the AbstractBeanDefinition to copy from */ public void copyQualifiersFrom(AbstractBeanDefinition source) { Assert.notNull(source, \u0026quot;Source must not be null\u0026quot;); this.qualifiers.putAll(source.qualifiers); } /** * Specify a callback for creating an instance of the bean, * as an alternative to a declaratively specified factory method. * \u0026lt;p\u0026gt;If such a callback is set, it will override any other constructor * or factory method metadata. However, bean property population and * potential annotation-driven injection will still apply as usual. * @since 5.0 * @see #setConstructorArgumentValues(ConstructorArgumentValues) * @see #setPropertyValues(MutablePropertyValues) */ public void setInstanceSupplier(@Nullable Supplier\u0026lt;?\u0026gt; instanceSupplier) { this.instanceSupplier = instanceSupplier; } /** * Return a callback for creating an instance of the bean, if any. * @since 5.0 */ @Nullable public Supplier\u0026lt;?\u0026gt; getInstanceSupplier() { return this.instanceSupplier; } /** * Specify whether to allow access to non-public constructors and methods, * for the case of externalized metadata pointing to those. The default is * {@code true}; switch this to {@code false} for public access only. * \u0026lt;p\u0026gt;This applies to constructor resolution, factory method resolution, * and also init/destroy methods. Bean property accessors have to be public * in any case and are not affected by this setting. * \u0026lt;p\u0026gt;Note that annotation-driven configuration will still access non-public * members as far as they have been annotated. This setting applies to * externalized metadata in this bean definition only. */ public void setNonPublicAccessAllowed(boolean nonPublicAccessAllowed) { this.nonPublicAccessAllowed = nonPublicAccessAllowed; } /** * Return whether to allow access to non-public constructors and methods. */ public boolean isNonPublicAccessAllowed() { return this.nonPublicAccessAllowed; } /** * Specify whether to resolve constructors in lenient mode ({@code true}, * which is the default) or to switch to strict resolution (throwing an exception * in case of ambiguous constructors that all match when converting the arguments, * whereas lenient mode would use the one with the 'closest' type matches). */ public void setLenientConstructorResolution(boolean lenientConstructorResolution) { this.lenientConstructorResolution = lenientConstructorResolution; } /** * Return whether to resolve constructors in lenient mode or in strict mode. */ public boolean isLenientConstructorResolution() { return this.lenientConstructorResolution; } /** * Specify the factory bean to use, if any. * This the name of the bean to call the specified factory method on. * @see #setFactoryMethodName */ @Override public void setFactoryBeanName(@Nullable String factoryBeanName) { this.factoryBeanName = factoryBeanName; } /** * Return the factory bean name, if any. */ @Override @Nullable public String getFactoryBeanName() { return this.factoryBeanName; } /** * Specify a factory method, if any. This method will be invoked with * constructor arguments, or with no arguments if none are specified. * The method will be invoked on the specified factory bean, if any, * or otherwise as a static method on the local bean class. * @see #setFactoryBeanName * @see #setBeanClassName */ @Override public void setFactoryMethodName(@Nullable String factoryMethodName) { this.factoryMethodName = factoryMethodName; } /** * Return a factory method, if any. */ @Override @Nullable public String getFactoryMethodName() { return this.factoryMethodName; } /** * Specify constructor argument values for this bean. */ public void setConstructorArgumentValues(ConstructorArgumentValues constructorArgumentValues) { this.constructorArgumentValues = constructorArgumentValues; } /** * Return constructor argument values for this bean (never {@code null}). */ @Override public ConstructorArgumentValues getConstructorArgumentValues() { if (this.constructorArgumentValues == null) { this.constructorArgumentValues = new ConstructorArgumentValues(); } return this.constructorArgumentValues; } /** * Return if there are constructor argument values defined for this bean. */ @Override public boolean hasConstructorArgumentValues() { return (this.constructorArgumentValues != null \u0026amp;\u0026amp; !this.constructorArgumentValues.isEmpty()); } /** * Specify property values for this bean, if any. */ public void setPropertyValues(MutablePropertyValues propertyValues) { this.propertyValues = propertyValues; } /** * Return property values for this bean (never {@code null}). */ @Override public MutablePropertyValues getPropertyValues() { if (this.propertyValues == null) { this.propertyValues = new MutablePropertyValues(); } return this.propertyValues; } /** * Return if there are property values values defined for this bean. * @since 5.0.2 */ @Override public boolean hasPropertyValues() { return (this.propertyValues != null \u0026amp;\u0026amp; !this.propertyValues.isEmpty()); } /** * Specify method overrides for the bean, if any. */ public void setMethodOverrides(MethodOverrides methodOverrides) { this.methodOverrides = methodOverrides; } /** * Return information about methods to be overridden by the IoC * container. This will be empty if there are no method overrides. * \u0026lt;p\u0026gt;Never returns {@code null}. */ public MethodOverrides getMethodOverrides() { if (this.methodOverrides == null) { this.methodOverrides = new MethodOverrides(); } return this.methodOverrides; } /** * Return if there are method overrides defined for this bean. * @since 5.0.2 */ public boolean hasMethodOverrides() { return (this.methodOverrides != null \u0026amp;\u0026amp; !this.methodOverrides.isEmpty()); } /** * Set the name of the initializer method. * \u0026lt;p\u0026gt;The default is {@code null} in which case there is no initializer method. */ public void setInitMethodName(@Nullable String initMethodName) { this.initMethodName = initMethodName; } /** * Return the name of the initializer method. */ @Nullable public String getInitMethodName() { return this.initMethodName; } /** * Specify whether or not the configured init method is the default. * \u0026lt;p\u0026gt;The default value is {@code false}. * @see #setInitMethodName */ public void setEnforceInitMethod(boolean enforceInitMethod) { this.enforceInitMethod = enforceInitMethod; } /** * Indicate whether the configured init method is the default. * @see #getInitMethodName() */ public boolean isEnforceInitMethod() { return this.enforceInitMethod; } /** * Set the name of the destroy method. * \u0026lt;p\u0026gt;The default is {@code null} in which case there is no destroy method. */ public void setDestroyMethodName(@Nullable String destroyMethodName) { this.destroyMethodName = destroyMethodName; } /** * Return the name of the destroy method. */ @Nullable public String getDestroyMethodName() { return this.destroyMethodName; } /** * Specify whether or not the configured destroy method is the default. * \u0026lt;p\u0026gt;The default value is {@code false}. * @see #setDestroyMethodName */ public void setEnforceDestroyMethod(boolean enforceDestroyMethod) { this.enforceDestroyMethod = enforceDestroyMethod; } /** * Indicate whether the configured destroy method is the default. * @see #getDestroyMethodName */ public boolean isEnforceDestroyMethod() { return this.enforceDestroyMethod; } /** * Set whether this bean definition is 'synthetic', that is, not defined * by the application itself (for example, an infrastructure bean such * as a helper for auto-proxying, created through {@code \u0026lt;aop:config\u0026gt;}). */ public void setSynthetic(boolean synthetic) { this.synthetic = synthetic; } /** * Return whether this bean definition is 'synthetic', that is, * not defined by the application itself. */ public boolean isSynthetic() { return this.synthetic; } /** * Set the role hint for this {@code BeanDefinition}. */ public void setRole(int role) { this.role = role; } /** * Return the role hint for this {@code BeanDefinition}. */ @Override public int getRole() { return this.role; } /** * Set a human-readable description of this bean definition. */ public void setDescription(@Nullable String description) { this.description = description; } /** * Return a human-readable description of this bean definition. */ @Override @Nullable public String getDescription() { return this.description; } /** * Set the resource that this bean definition came from * (for the purpose of showing context in case of errors). */ public void setResource(@Nullable Resource resource) { this.resource = resource; } /** * Return the resource that this bean definition came from. */ @Nullable public Resource getResource() { return this.resource; } /** * Set a description of the resource that this bean definition * came from (for the purpose of showing context in case of errors). */ public void setResourceDescription(@Nullable String resourceDescription) { this.resource = (resourceDescription != null ? new DescriptiveResource(resourceDescription) : null); } /** * Return a description of the resource that this bean definition * came from (for the purpose of showing context in case of errors). */ @Override @Nullable public String getResourceDescription() { return (this.resource != null ? this.resource.getDescription() : null); } /** * Set the originating (e.g. decorated) BeanDefinition, if any. */ public void setOriginatingBeanDefinition(BeanDefinition originatingBd) { this.resource = new BeanDefinitionResource(originatingBd); } /** * Return the originating BeanDefinition, or {@code null} if none. * Allows for retrieving the decorated bean definition, if any. * \u0026lt;p\u0026gt;Note that this method returns the immediate originator. Iterate through the * originator chain to find the original BeanDefinition as defined by the user. */ @Override @Nullable public BeanDefinition getOriginatingBeanDefinition() { return (this.resource instanceof BeanDefinitionResource ? ((BeanDefinitionResource) this.resource).getBeanDefinition() : null); } /** * Validate this bean definition. * @throws BeanDefinitionValidationException in case of validation failure */ public void validate() throws BeanDefinitionValidationException { if (hasMethodOverrides() \u0026amp;\u0026amp; getFactoryMethodName() != null) { throw new BeanDefinitionValidationException( \u0026quot;Cannot combine static factory method with method overrides: \u0026quot; + \u0026quot;the static factory method must create the instance\u0026quot;); } if (hasBeanClass()) { prepareMethodOverrides(); } } /** * Validate and prepare the method overrides defined for this bean. * Checks for existence of a method with the specified name. * @throws BeanDefinitionValidationException in case of validation failure */ public void prepareMethodOverrides() throws BeanDefinitionValidationException { // Check that lookup methods exists. if (hasMethodOverrides()) { Set\u0026lt;MethodOverride\u0026gt; overrides = getMethodOverrides().getOverrides(); synchronized (overrides) { for (MethodOverride mo : overrides) { prepareMethodOverride(mo); } } } } /** * Validate and prepare the given method override. * Checks for existence of a method with the specified name, * marking it as not overloaded if none found. * @param mo the MethodOverride object to validate * @throws BeanDefinitionValidationException in case of validation failure */ protected void prepareMethodOverride(MethodOverride mo) throws BeanDefinitionValidationException { int count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName()); if (count == 0) { throw new BeanDefinitionValidationException( \u0026quot;Invalid method override: no method with name '\u0026quot; + mo.getMethodName() + \u0026quot;' on class [\u0026quot; + getBeanClassName() + \u0026quot;]\u0026quot;); } else if (count == 1) { // Mark override as not overloaded, to avoid the overhead of arg type checking. mo.setOverloaded(false); } } /** * Public declaration of Object's {@code clone()} method. * Delegates to {@link #cloneBeanDefinition()}. * @see Object#clone() */ @Override public Object clone() { return cloneBeanDefinition(); } /** * Clone this bean definition. * To be implemented by concrete subclasses. * @return the cloned bean definition object */ public abstract AbstractBeanDefinition cloneBeanDefinition(); @Override public boolean equals(Object other) { if (this == other) { return true; } if (!(other instanceof AbstractBeanDefinition)) { return false; } AbstractBeanDefinition that = (AbstractBeanDefinition) other; if (!ObjectUtils.nullSafeEquals(getBeanClassName(), that.getBeanClassName())) return false; if (!ObjectUtils.nullSafeEquals(this.scope, that.scope)) return false; if (this.abstractFlag != that.abstractFlag) return false; if (this.lazyInit != that.lazyInit) return false; if (this.autowireMode != that.autowireMode) return false; if (this.dependencyCheck != that.dependencyCheck) return false; if (!Arrays.equals(this.dependsOn, that.dependsOn)) return false; if (this.autowireCandidate != that.autowireCandidate) return false; if (!ObjectUtils.nullSafeEquals(this.qualifiers, that.qualifiers)) return false; if (this.primary != that.primary) return false; if (this.nonPublicAccessAllowed != that.nonPublicAccessAllowed) return false; if (this.lenientConstructorResolution != that.lenientConstructorResolution) return false; if (!ObjectUtils.nullSafeEquals(this.constructorArgumentValues, that.constructorArgumentValues)) return false; if (!ObjectUtils.nullSafeEquals(this.propertyValues, that.propertyValues)) return false; if (!ObjectUtils.nullSafeEquals(this.methodOverrides, that.methodOverrides)) return false; if (!ObjectUtils.nullSafeEquals(this.factoryBeanName, that.factoryBeanName)) return false; if (!ObjectUtils.nullSafeEquals(this.factoryMethodName, that.factoryMethodName)) return false; if (!ObjectUtils.nullSafeEquals(this.initMethodName, that.initMethodName)) return false; if (this.enforceInitMethod != that.enforceInitMethod) return false; if (!ObjectUtils.nullSafeEquals(this.destroyMethodName, that.destroyMethodName)) return false; if (this.enforceDestroyMethod != that.enforceDestroyMethod) return false; if (this.synthetic != that.synthetic) return false; if (this.role != that.role) return false; return super.equals(other); } @Override public int hashCode() { int hashCode = ObjectUtils.nullSafeHashCode(getBeanClassName()); hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.scope); hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.constructorArgumentValues); hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.propertyValues); hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.factoryBeanName); hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.factoryMethodName); hashCode = 29 * hashCode + super.hashCode(); return hashCode; } @Override public String toString() { StringBuilder sb = new StringBuilder(\u0026quot;class [\u0026quot;); sb.append(getBeanClassName()).append(\u0026quot;]\u0026quot;); sb.append(\u0026quot;; scope=\u0026quot;).append(this.scope); sb.append(\u0026quot;; abstract=\u0026quot;).append(this.abstractFlag); sb.append(\u0026quot;; lazyInit=\u0026quot;).append(this.lazyInit); sb.append(\u0026quot;; autowireMode=\u0026quot;).append(this.autowireMode); sb.append(\u0026quot;; dependencyCheck=\u0026quot;).append(this.dependencyCheck); sb.append(\u0026quot;; autowireCandidate=\u0026quot;).append(this.autowireCandidate); sb.append(\u0026quot;; primary=\u0026quot;).append(this.primary); sb.append(\u0026quot;; factoryBeanName=\u0026quot;).append(this.factoryBeanName); sb.append(\u0026quot;; factoryMethodName=\u0026quot;).append(this.factoryMethodName); sb.append(\u0026quot;; initMethodName=\u0026quot;).append(this.initMethodName); sb.append(\u0026quot;; destroyMethodName=\u0026quot;).append(this.destroyMethodName); if (this.resource != null) { sb.append(\u0026quot;; defined in \u0026quot;).append(this.resource.getDescription()); } return sb.toString(); } }  ","date":"2019-01-17T11:56:50Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/1.jpg","permalink":"https://lllovol.com/spring-source-code-2/","title":"《Spring源码深度解析》读后感(二)Bean的标签解析"},{"content":"前言 这个系列主要是用来记录自己读这本书的一些笔记和想法的记录，不过买书好像买错了，应该买spring boot的相关解读的书籍，这是spring的深入解读的书。吃了一亏，不过这也是spring boot的前身，其中的源码也是有价值的。\n首先开始的，是整个spring当中最核心的用法，但是却十分重要的一个部分\u0026ndash;容器。大道至简，大音希声。\n容器的基本用法 bean是spring中最核心的东西，因为spring就像一个大水桶，而bean就像是水桶中的水，水桶脱离了水便没有了什么用处。而spring 的目的，就是让我们的bean，能够成为纯粹的POJO（plain ordinary java object）。 需要：\n  一个成员属性\n  这个属性的getter\n  这个属性的setter 然后在配置文件xml当中添加相关的bean\n \u0026lt;bean id=\u0026quot;myTestBean\u0026quot; class=\u0026quot;bean.MyTestBean\u0026quot;/\u0026gt;    然后就可以在测试代码中使用我们所测试的bean了\n容器的基础XmlBeanFactory 代码如下\n BeanFactory bf= new XmlBeanFactory(new ClassPathResource(\u0026quot;beanFactoryTest.xml\u0026quot;));  实现流程 首先调用了ClassPathResource的构造函数 来构造了Resource资源文件的实例对象，然后后续的资源处理就可以使用Resource提供的各种服务来操作了。然后当我们有了Resource之后，就可以进行XmlBeanFactory的初始化了。\n与之同理，对于不同来源的资源文件都有相应的Resource实现。有了Resource接口之后便可以对所有资源文件进行统一的处理。例如\n Resource resource=new ClassPathResource(\u0026quot;beanFactoryTest.xml\u0026quot;); InputStream inputStream=resource.getInputStream();  XmlBeanDefinition 然后，当Resource的相关类完成了对配置文件进行封住后配置文件的读取工作就全权交给XmlBeanDefinition来处理了。\n（ignoreDependencyInterface（）函数的主要功能是忽略给定接口的自动装配功能） (时序图书 p20)\n 封装资源文件。 获取输入流 通过构造的InputSource实例和Resource实例继续调用函数doLoadbeanDefinitions  支撑着整个Spring容器部分的实现基础 然后就是3个步骤，支撑着整个Spring容器部分的实现基础\n 获取对XML文件的验证模式 加载XML文件，并得到对应的Document 根据返回的Document注册Bean信息  doRegisterBeanDefinitions(root) 然后，又通过一系列的处理之后，终于可以到了核心逻辑的底部doRegisterBeanDefinitions(root)\n终于开始真正的解析了。\n 处理profile（profile可以让我们在配置文件中部署配置两套配置来适用于测试环境和开发环境，在springboot中变成了bootstrap.yml中的一种属性） 模板模式的使用（解析前后的函数preProcessXml（）和postProcessXml（）并没有实现，顺便复习一下面向对象的三大特性：封装多态继承，五大原则：单一功能原则，开闭原则，里氏代换原则，依赖原则，接口分离原则，迪米特原则） pariseBeanDefinitions方法来对bean进行解析，然后并注册BeanDefinition  因为在Spring中的xml配置中有两大类Bean的声明：默认的和自定义的。在以后的文章中将会提及。\n","date":"2019-01-15T17:06:53Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/8.jpg","permalink":"https://lllovol.com/spring-source-code/","title":"《Spring源码深度解析》读后感(一)Spring的容器Bean"},{"content":"前言 本文主要总结于如下的官方文档的部分内容，如有翻译不当理解不当的地方，欢迎留言指正\nSpring官方文档\nSpring JDBC官方文档\nSpring MongoDB官方文档\nJPA JAVA Persistence API，java持久化的api\n JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易地掌握。JPA基于非侵入式原则设计，因此可以很容易地和其它框架或者容器集成。\n MongoDB与JDBC mongoDB和JDBC（JAVA DATABASE CONNECTIVITY）最顶级的抽象类CrudRepository有很多相似的地方，下面就来看看CrudRepository和MongoRepository的对比，根据源码来看看两者之间的关系\nMongoRepository @NoRepositoryBean public interface MongoRepository\u0026lt;T, ID\u0026gt; extends PagingAndSortingRepository\u0026lt;T, ID\u0026gt;, QueryByExampleExecutor\u0026lt;T\u0026gt; { @Override \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; saveAll(Iterable\u0026lt;S\u0026gt; entites); @Override List\u0026lt;T\u0026gt; findAll(); @Override List\u0026lt;T\u0026gt; findAll(Sort sort); \u0026lt;S extends T\u0026gt; S insert(S entity); \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; insert(Iterable\u0026lt;S\u0026gt; entities); @Override \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; findAll(Example\u0026lt;S\u0026gt; example); @Override \u0026lt;S extends T\u0026gt; List\u0026lt;S\u0026gt; findAll(Example\u0026lt;S\u0026gt; example, Sort sort); }  CrudRepository public interface CrudRepository\u0026lt;T, ID extends Serializable\u0026gt; extends Repository\u0026lt;T, ID\u0026gt; { \u0026lt;S extends T\u0026gt; S save(S entity); Optional\u0026lt;T\u0026gt; findById(ID primaryKey); Iterable\u0026lt;T\u0026gt; findAll(); long count(); void delete(T entity); boolean existsById(ID primaryKey); // … more functionality omitted. }  两者的接口函数真的很相似\n如果继续往上追根溯源，我们会发现：\npublic interface MongoRepository\u0026lt;T, ID\u0026gt; extends PagingAndSortingRepository\u0026lt;T, ID\u0026gt;, QueryByExampleExecutor\u0026lt;T\u0026gt;  MongoRepository继承了PagingAndSortingRepository这个接口，这个接口主要是用来实现查询的分页的功能，点进去再仔细一看，就会发现：\npublic interface PagingAndSortingRepository\u0026lt;T, ID\u0026gt; extends CrudRepository\u0026lt;T, ID\u0026gt;  这个时候，就会发现MongoRepository的最上层，就是CrudRepository，由此可见，CrudRepository就是MongoRepository的最上层的抽象类，因此两者之间有这么多相似的地方也就没有什么奇怪了。但是因为MongoDb是一种非关系型的数据库，因此实现的方式才会有所区别。\nCrudRepository派生的查询（Derive的 Query） 在CrudRepository中有派生的count以及派生的delete等其他的查询，这样可以通过自定义的驼峰的形式来进行的CRUD等操作。\nDerived Count Query interface UserRepository extends CrudRepository\u0026lt;User, Long\u0026gt; { long countByLastname(String lastname); }  Derived Delete Query interface UserRepository extends CrudRepository\u0026lt;User, Long\u0026gt; { long deleteByLastname(String lastname); List\u0026lt;User\u0026gt; removeByLastname(String lastname); }  MongoRepository中派生的查询 既然MongoRepository是CrudRepository的派生类，那么应该也可以实现相应的派生的自定义的CRUD操作\n这个Repository proxy有两种方式来派生出来查询的query\n使用Name来生成Query  By deriving the query from the method name directly.\n 例子 public interface CustomProjectRepo extends MongoRepository\u0026lt;CustomProject,Integer\u0026gt; { List\u0026lt;CustomProject\u0026gt; findByIdInAndNameRegex(List\u0026lt;Integer\u0026gt; ids, String name); List\u0026lt;CustomProject\u0026gt; findByIdIn(List\u0026lt;Integer\u0026gt; ids); List\u0026lt;CustomProject\u0026gt; findByName(String name); Optional\u0026lt;CustomProject\u0026gt; findByPathWithNamespace(String pathWithNamespace); List\u0026lt;CustomProject\u0026gt; findByNamespaceIdIn(List\u0026lt;Integer\u0026gt; groupIds); }  无需自己另外实现，函数会自行的解析，重上到下的依次实现的功能：\n id在ids中，并且名字符合name的正则的的CustomProject id在ids中的CustomProject 找到对应name的CustomProject 找到指定pathWithNamespace的CustomProject 找到namespaceId匹配groupIds中的CustomProject  基本用法 这种机制来创造MongoDB Query,很方便，只需要相应的前缀加上相应的名字，使用java标准的命名方式（驼峰的方式）,该机制就会自动的开始解析：\n find\u0026hellip;By read\u0026hellip;By query\u0026hellip;By get\u0026hellip;By  除此之外，这些语句还能够包含其他更加深层次的表达式，比如：\n Distinct 去重 IgnoreCase 无视大小写 OrderBy\u0026hellip;Asc 按照某个属性升序 OrderBy\u0026hellip;Desc 按照某个属性降序 Between 在\u0026hellip;之间 LessThan 少于 GreaterThan 多于 Like 模糊查询  第一个By是当做最基础的查询语句的基础，除此之外，还可以使用And和Or来连接表达式\n歧义处理 List\u0026lt;Person\u0026gt; findByAddressZipCode(ZipCode zipCode);  可能会被解析成AddressZipCode当成一个字段，AddressZip Code,也有可能Address ZipCode.为了解决这种歧义，MongoRepository使用了下划线来手动设置\nList\u0026lt;Person\u0026gt; findByAddress_ZipCode(ZipCode zipCode);  这也是为什么下划线被设置成了保留字，而推荐用户使用标准java命名方式的原因\n特殊参数处理 可以传入特殊的参数，比如Pageable和sort,可以动态的设置分页和排序，例子:\nPage\u0026lt;User\u0026gt; findByLastname(String lastname, Pageable pageable); Slice\u0026lt;User\u0026gt; findByLastname(String lastname, Pageable pageable); List\u0026lt;User\u0026gt; findByLastname(String lastname, Sort sort); List\u0026lt;User\u0026gt; findByLastname(String lastname, Pageable pageable);  第一种返回page的方式在查询的结果集比较庞大的时候，代价也就会特别大，因此可以选择返回Slice,Slice可以知道下一个slice是否是有用的，能够在大的数量级下产生作用。\n限制结果集的数量 就像在数据查询的时候，可以查第一条或者若干条和最上面的一条或者若干条，MongoDBRepository也可以实现这个功能，同时也可以实现分页和排序的功能\nUser findFirstByOrderByLastnameAsc(); User findTopByOrderByAgeDesc(); Page\u0026lt;User\u0026gt; queryFirst10ByLastname(String lastname, Pageable pageable); Slice\u0026lt;User\u0026gt; findTop3ByLastname(String lastname, Pageable pageable); List\u0026lt;User\u0026gt; findFirst10ByLastname(String lastname, Sort sort); List\u0026lt;User\u0026gt; findTop10ByLastname(String lastname, Pageable pageable);  手动定义来生成Query  This section covers repository customization and how fragments form a composite repository.\n 当需要的方法不能直接通过派生的机制直接派生的时候，就需要自己手动定义了，步骤如下\n定义自定义接口 interface CustomizedUserRepository { void someCustomMethod(User user); }  实现自定义接口中的函数 class CustomizedUserRepositoryImpl implements CustomizedUserRepository { public void someCustomMethod(User user) { // Your custom implementation } }  原始库的修改 集成自定义的接口即可\ninterface UserRepository extends CrudRepository\u0026lt;User, Long\u0026gt;, CustomizedUserRepository { // Declare query methods here }  总结 还有MongoTemplate的方式来实现各种Query，但是由于工作中遇到过了一次bug，mongo中的其中一个库的数据突然不见了，由于mongo没有什么特定的sql语句可以查询，而且使用的是mongoTemplate，出现的地方很多，排查bug的时候耗费了很大的精力。从那之后，前辈就推荐使用repo的方式来进行对mongoDB的Crud操作了。\n","date":"2019-01-08T10:51:00Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/7.jpg","permalink":"https://lllovol.com/spring6/","title":"SpringBoot开发中的一些小细节(六)JPA"},{"content":"RT 响应时间 response time相应时间\n响应时间是提交请求和返回该请求的响应之间使用的时间。\n主要包括：\n 数据库查询的时间 将字符传到终端上面所花的时间 访问web页面所花的时间  对于没有并发的系统而言，响应时间是一个合理并且准确的性能指标。但是响应时间的绝对值并不能反应性能的高低，软件的性能高低实际取决于用户对于该响应时间的接受度。 这就像是恋爱中的感情一样，你回复消息的快慢并不能反应你有多么爱她，而是取决于她对于你的这些行为的接受程度。TPS 每秒事物处理量 Transaction Per Second 吞吐量的（Throughput），吞吐量是指系统在单位时间内处理请求的数量。\n对于单应用系统而言，吞吐量和响应时间严格成反比。单应用使用响应时间来作为衡量的指标，但是对于并发系统而言，通常需要吞吐量作为性能指标。因为在一个并发系统下，当一个用户一个请求的时间为t,但是n个用户一同请求往往不是n*t（可能大，可能小，需要看具体的情况）。一个并发系统如果配置合理，相应时间应该不会随着用户的增多而线性增加。因此才将吞吐量作为并发系统的性能衡量指标。一般而言，对于不同用户规模和不同的用户模式的系统，如果系统的最大吞吐量大致相同的话，可以判断两个系统的数据处理能力基本相同。\n并发用户数 并发用户数指的是系统最大可以承受的正常使用系统功能的用户数。这个指标比TPS更加笼统，但是也更加的直观。但是这是一个非常不准确的指标，比如一个直播的弹幕网站，用户可以登录，正常发送弹幕，但是如果都挤在了一个直播间，同一时间发送一大堆弹幕，这时候的服务器可能就会崩了。而且用户在线的时候，大部分时间都在阅读信息，只有小部分的再发送请求，这样的情况是很多的。这项指标很大情况下取决于用户的行为模式。\nQPS 每秒查询数量 Query Per Second\n 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）摘自cnblog\n ","date":"2019-01-07T15:23:02Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg","permalink":"https://lllovol.com/qps/","title":"关于吞吐量的一些小知识"},{"content":"Code Review 这一周主要是一个前辈的code Review，在此期间能学到很多新的东西，也能看到自己的不足\n变量名的命名 禁止使用拼音，真的显得很没有水平，而且可读性会非常差，除非这个对象真的只有拼音名字\n关于异常的抛出  异常不要怕抛出的多，有异常一定要打出来，不然出了错都不知道是什么地方出的错 禁止一个Exception就把一大段代码的所有异常给吞了 异常一定要用log.error()将栈给打出来  StringBuffer、StringBuilder和String 运行速度：执行速度，在这方面运行速度快慢为：StringBuilder \u0026gt; StringBuffer \u0026gt; String String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。\nString str=\u0026quot;abc\u0026quot;+\u0026quot;de\u0026quot;; StringBuilder stringBuilder=new StringBuilder().append(\u0026quot;abc\u0026quot;).append(\u0026quot;de\u0026quot;); System.out.println(str); System.out.println(stringBuilder.toString());  这种情况下除外，String的速度会比StringBuilder要快，因为第一行等价于String str=\u0026ldquo;abcde\u0026rdquo;。\n在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。\n使用的情况 String：适用于少量的字符串操作的情况\nStringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况\nStringBuffer：适用多线程下在字符缓冲区进行大量操作的情况\n代码复用性 都是http的请求的话，封装成一个功能函数就好了，不用每次都写一个http的函数，复用性太低。而且最好的方式是使用feign的方式，更加的漂亮\n正则和alike有什么区别吗？ 好像用alike好一点，但是mongo里面好像只有正则，其实都可以\nStream流的方式 主要用在将一个list转成另外一个list或者map转map的时候用的，入参一个，出参一个 list.stream().map（）使用java的，都能实现，主要是map可以不用写那么多代码。map(CustomVersion::new).collect(Collectors.toList()); 这个new 就是要创造一个传入的参数的构造函数\n数据库的CRUD 查询的时候注意 不建议使用findAll，最好做一个分页，看一下表有多大，除非是表小，而且不会有爆炸性的数据增长的时候可以用。其他时候最好都有分页\n删除的时候 最好是确认了可以保存了，然后再去删，这个，不应该一来就删了\nprofile 想了解应用运行的状态，在什么环境下的，应该去看activity的profile\nspring: profiles: active: debug  上面是在bootstrap.yml中的，下面是如何使用\n@Value(\u0026quot;${spring.profiles.active}\u0026quot;) String active; log.info(\u0026quot;start kubernetes watch,active:{}\u0026quot;,active);  将mongoTemplate改为repo的形式  官方文档\n 相当的方便，好处就是出问题的时候，可以找到对应的表的对应的repo类，快速排查问题。\n如果想要自定义函数的话，需要自定义一个接口，再实现之后，用repo来继承自定义的接口。\n如果直接实现repo的接口的话，需要重写很多函数。\n在实现的时候部分代码，记得加上上面的两个注解\n@Repository @RequiredArgsConstructor public class CustomizeProjectRepoImpl implements CustomizeProjectRepo { @Autowired MongoTemplate mongoTemplate; @Override public void updateDeployToYesByIds(List\u0026lt;Integer\u0026gt; ids) { Query query = Query.query(Criteria.where(\u0026quot;id\u0026quot;).in(ids)); Update update = Update.update(\u0026quot;deployOrNot\u0026quot;, YesOrNot.YES.getValue()); mongoTemplate.updateMulti(query, update, CustomProject.class); } }  ","date":"2019-01-05T17:05:33Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg","permalink":"https://lllovol.com/spring5/","title":"SpringBoot开发中的一些小细节(五)String、StringBuffer和StringBuilder、"},{"content":"“取法于上，仅得为中，取法为中，故为其下”。  在读AI Ries和Jack Trout的这一本《定位》之前，我对“定位”这个词，第一个感觉，就是唐太宗的这句话，当然这只是仅仅是站在个人的层面，对自己的一种定位。在追求探索一件事情的时候，需要将目标放的高与长远一点。在读完《定位》之后，我对定位这个词有了新的理解。\n回想近代社会的发展史，其实也就是人们的定位的一次次的更新和迭代：十八世纪六十年代，瓦特改良了蒸汽机，手工劳动的转变为了大机器生产，是第一次的工业革命，人类的生产力得到了极大的提高，这时候生产力的定位，是靠着有这熟练经验的技工总结而来的；十九世纪下半叶，蒸汽时代逐渐接受，人们逐渐开始进入电气时代，这时候生产力的定位，和第一次有着巨大的不同，是科学技术真正的开始带来生产力的巨大变革；而在第二次世界大战结束之后，人类进入了第三次的生产力革命，信息技术的革命，技术更迭日新月异，瞬息万变的时代，而现在的定位，正是书中所着重介绍的，可以植入人们心智的一种定位。\n因此书中举了很多关于企业的例子，美国的香烟品牌如何使用定位抢占市场份额，航空公司的成长，福特公司生产汽车优劣等等。虽然这本书的作者，Jack Trout最早是在上个世纪70年代的时候提出来的定位这个概念，书中有不少例子都不是那么的新，甚至还会存在打脸的情况，但是最后的结果都在印证书中的观点的正确性。例如《TIME》的名字，作者最开始并不那么看好，认为这名字不是很好，销量不如《每周周刊》，虽然随着时间的不断积累，展示出来的结果恰恰相反，但是也在一定程度上印证了书中的观点，有一个好名字的重要性。预测失误只是当时的作者并不认为这是一个好的名字。\n现在的中国，已经成长为世界上第二大的经济体，改革开放以来，中国的实体经济，主要都是靠着廉价的劳动力成本来进行的驱动，但是随着时代的发展，人们物质生活水平都在不断的提高，对精神需求方面以及环境保护方面，都有了非常大的变化。而在现如今的社会市场状况下，已经不是当初那个靠着产品来驱动的时代了。而应该就是书中所说的“定位的时代”。\n通读全书，定位主要有以下几个方面。\n确定领导者地位  成为第一就是进入顾客心智的主要途径，成为第一个进入人们心智某个领域的产品，给自己确定一个定位。在给自己定位之前，还必须明确当前自己的定位，不要去尝试去挑战那些已经是第一领导者的人，那需要更多宣传和更高的质量，然后对于后来者来说，都是很难同时兼顾的事情。如果是成功成为了领导者，那么就要遵循领导者的准则，以潜在用户的标准来建立领导地位，然后对竞争对手进行全面的拦截，同时保证自己产品的实力，对竞争对手提出来新的概念的时候做出迅速的回应，以保持自己的领导者地位。书中说，成为第一很难，保持第一很简单。但我觉得，这两者都并非易事，但是成为领导者之后，确实可以通过占有更大的资源份额，做出更大发展。就这一点来看，我们公司现在已经做到了，但是需要努力工作，才能保持优势。在公益筹款平台方面，我询问我的朋友们，他们第一反应就是我们公司。\n跟随者的方式  如果不能成为领导者，那么就需要使用跟随者的方式，找到一个未被其他人占据的“空位”。例如同一个产品的高价定位，或者低价定位，或者性别定位，但是有一个陷阱，就是永远不要想着满足所有人的需求。这一点无论是做产品，还是做人做事，都是一样的道理，人的精力是有限的，将目标之事专注的完成了已经就不是一件易事。除此之外，还可以给竞争对手重新定位。个人理解，就是进行一种比较性的定位，找出自己具有优势而对手却薄弱的方面，进行定位，虽然这么做不是那么厚道，但是却真实有效。但是现实就是如此，对竞争对手少许的“贬低”，比自己大量的“自吹自擂”更加有意义。诚实和公正的重新定位，才能让竞争对手不敢怠慢。\n产品的定位品牌  然后就是书中很重要的一个方面，就是自己的产品的定位品牌。一是拥有一个优秀的好名字，一个优秀的名字本身，在这个传播过渡的社会中就具有巨大的威力，例如水滴，完美符合众筹的这个概念，无论是点滴汇成江河海洋，还是滴水石穿，从古诗意境上面分析，这就是一个非常好的意象。一个响亮，接近通用而又带有描述性的名字，本身就可以阻击对手进入我们的领域。取名字真的是一门学问，就像一个好的名字会伴随一个人的终生，一个名字也将是一个产品最重要的牌面。二就是书中所提到的无名陷阱，有些名字冗长的公司企图使用缩写来简化自己的名字，然而往往适得其反，最后使得用户完全不知道这个缩写词所代指的到底是什么，除非足够幸运，缩写词刚好也是公司主要业务的体现这样的尤为特殊的情况，例如漫威电影中的神盾局Strategic Homeland Intervention, Enforcement and Logistics Division缩写刚好是S.H.I.E.L.D，这么幸运的事情，还是很难强求的。三就是不要企图将第一个成功的品牌名字无限的重复使用，使用一个名字不断延伸自己的产品种类，这样的坏处是，用户在看见这个名字的时候，会疑惑这到底指的是什么产品。当把一个成功产品的名字使用到多个新产品中的时候，其实是在消耗成功产品的寿命。看完此书之后，我才明白，为什么竹子好课不叫水滴好课，国际化项目不叫水滴国际而叫Deeda。总结来讲，品牌名就像是橡皮筋，它可以拉伸，但是又临界点，它拉的越长，就越脆弱。\n个人定位  上面都是关于企业产品的定位，而对个人而言，也可以拥有自己的定位。首先是定义自己，给自己一个唯一确定的定位，个人觉得这是一个很难的命题，需要随着时间阶段的推移和自身的成长做出长远和短期的定位目标（OKR），例如现在我对自己的定位，就是做一个认真踏实的后端实习生，将来的定位，就是成为一个后端研发专业的工程师。然后就是拥有一个好名字，这一点需要感谢我的母亲，给我取了一个好名字，而我自身也需要用自己的行动来将这个名字赋予新的意义，更加具有辨识度。然后就是找一匹优秀的马，换言之，就是寻找一个能够提升自己的事业的公司与愿意培养自己的领导。我很幸运，在实习的时候能够来到这个充满活力和无限未来可能性的公司，同时也有很多优秀的前辈给予我悉心的培养、耐心的指导，在过去半年里让我成长很大。\n你好2019  18再见，19你好！新的一年里，从零开始，新生再战！\n","date":"2019-01-01T01:29:23Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/1.jpg","permalink":"https://lllovol.com/positioning/","title":"《定位》"},{"content":"Code Review 这周被点名来做code view了来着，然后昨天晚上做了一个小时的code review，还是相当紧张，然后今天改了一天代码 特此总结\nApplicationListener 这个地方原来主要实现的功能是spring3中的功能，在启动了整个项目之后，让watch pods和watch service启动并且只启动一次。\n（启动一个单线程，回调函数，生命周期） 原来的做法是使用spring task在应用启动之后，就启动一次然后一直运行\n// @Scheduled(cron = \u0026quot;${schedule.kubeService}\u0026quot;) @Scheduled(fixedDelay = 999999999) protected void gitlabProjectTask() { kubernetesService.collectServices(); customServiceService.bindServiceAndProject(); kubernetesService.watchServices(); } // @Scheduled(cron = \u0026quot;${schedule.kubePod}\u0026quot;) // @Scheduled(cron = \u0026quot;0 0,14 6,18 * * ? \u0026quot;) //taskexecutor // ScheduledExecutorTask // new 一个单线程一直跑就可以了 @Scheduled(fixedDelay = 999999999) public void collectPod() { kubernetesService.collectPods(); kubernetesService.watchPods(); }  现在使用的是ApplicationListener\npublic class KubernetesServiceImpl implements KubernetesService, ApplicationListener\u0026lt;ApplicationReadyEvent\u0026gt; { //生命周期 @Override public void onApplicationEvent(ApplicationReadyEvent event) { collectServices(); customServiceService.bindServiceAndProject(); watchServices(); collectPods(); watchPods(); } }  这样既可\n这样就可以在线程启动的时候异步的启动这些服务\n使用注解（to do）或者继承ApplicationListenerMongoDB的修改操作方式 在修改mongoTemplate的update的时候，会发现使用update的话，会需要修改很多的key值，这样的操作不如直接全部删了然后全部再加进去\nQuery query = Query.query(Criteria.where(\u0026quot;classId\u0026quot;).is(\u0026quot;1\u0026quot;)); Student student = new Student(\u0026quot;1\u0026quot;, \u0026quot;lisi\u0026quot;, 18, \u0026quot;man\u0026quot;); Update update = new Update(); //update.push(\u0026quot;Students\u0026quot;, student); update.addToSet(\u0026quot;Students\u0026quot;, student); mongoTemplate.upsert(query, update, \u0026quot;class\u0026quot;);  使用Strings的时候nullOrEmpty的判断 Strings.isNullOrEmpty(username)\n推荐使用的是Apache的StringUtil或者google的\n不能使用 username.equals(\u0026quot;\u0026quot;)\n如何只在debug的时候才开始打印日志 log.debug(\u0026quot;user: {}\u0026quot;, username); if (log.isDebugEnabled()) { for (Map.Entry\u0026lt;String, CustomServiceDeployDto\u0026gt; stringCustomServiceDeployDtoEntry : serviceAndTag.entrySet()) { log.debug(\u0026quot; service and tags: {}\u0026quot;, JSONObject.toJSON(stringCustomServiceDeployDtoEntry)); } }  泛型警告的问题 将redisTemplate修改为StringRedisTemplate\n返回空的集合应该使用 Collections.emptyList()\nbug修复 历史记录刷新的时候，value是一个map，而map中的service的值没有\n","date":"2018-12-28T17:12:32Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/5.jpg","permalink":"https://lllovol.com/spring4/","title":"SpringBoot开发中的一些小细节(四)CR笔记ApplicationListener等等"},{"content":"前言 最近主要在获取到的k8s中的相关service和pod的信息的变化，将原来全量获取数据的方式改进为增量的方式，此篇主要记录使用过程中遇到的坑和相信的解决方式\nKubernetesClient的包的依赖的引用 使用的是fabric8的kubernetes-client，添加如下依赖即可\n\u0026lt;!--在pom.xml文件--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.fabric8\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;kubernetes-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  配置文件配置相关的属性 application.yml文件 添加k8s集群的主机url,token\napi: server: k8s: key: \u0026quot;kubernetes.auth.token\u0026quot; token: \u0026quot;***********************************\u0026quot; url: \u0026quot;https://10.0.0.0:6443\u0026quot;  这里就有一个坑，就是这个token,由于kubernetes的安全机制，原来获取到的token都只有一天的时效，第二天都需要重新更新一个新的token\n这样是肯定不行的，解决的方式有大概下面几种：\n 使用证书的方式，需要三个文件，CaCertFile,ClientCertFile,ClientKeyFile 获取一种长效的永久的token，这个需要的权限比较高，需要找到kubernetes的负责人，拥有的权限比较高的人\n（查看本地的token,cd ~/.kube,然后cat config,就能看到自己本地的token） 使用账号密码进行登录  configuration的实现 在configuration文件夹下面新建一个class，取名为KubernetesConfig\n主要文件内容如下\n@Setter @Configuration @ConfigurationProperties(prefix = \u0026quot;api.server\u0026quot;) public class KubernetesConfig { private K8s k8s; private static final int REQUEST_TIMEOUT = 3 * 1000; private static final int CONNECTION_TIMEOUT = 3 * 1000; @Bean(\u0026quot;kubernetesClient\u0026quot;) public KubernetesClient kubernetesClient() { Config config = new ConfigBuilder() .withMasterUrl(k8s.getUrl()) .withOauthToken(k8s.getToken()) .withTrustCerts(true) .removeFromTlsVersions(TlsVersion.TLS_1_0) .removeFromTlsVersions(TlsVersion.TLS_1_1) .removeFromTlsVersions(TlsVersion.TLS_1_2) .withRequestTimeout(REQUEST_TIMEOUT) .withConnectionTimeout(CONNECTION_TIMEOUT) .build(); KubernetesClient client = new DefaultKubernetesClient(config); return client; } @Bean(\u0026quot;k8s\u0026quot;) public K8s getK8s() { return k8s; } @Setter @Getter public static class K8s { private String token; private String key; private String url; } }  以上是使用的是token的方式，进行的登录\n还可以使用证书的方式：   将需要的三个证书文件放到项目当中，右键copy path,然后删除src前面的路径\n  将上面代码中的.withOauthToken(k8s.getToken())替换为\n.withCaCertFile(\u0026ldquo;src/main/resources/CaCert.crt\u0026rdquo;)\n.withClientCertFile(\u0026ldquo;src/main/resources/ClientCert.crt\u0026rdquo;)\n.withClientKeyFile(\u0026ldquo;src/main/resources/ClientKey.key\u0026rdquo;)\n  还可以使用账号密码的方式进行登录：   将上面代码中的.withOauthToken(k8s.getToken())替换为\n.withUsername(\u0026ldquo;username\u0026rdquo;)\n.withPassword(\u0026ldquo;password\u0026rdquo;)\n  使用KubernetesClient实现watch的功能 kubernetesClient.services().inAnyNamespace().watch(new Watcher\u0026lt;Service\u0026gt;() { @Override public void eventReceived(Action action, Service service) { log.debug(\u0026quot;service watch action:{}\u0026quot;,action); log.debug(\u0026quot;service watch service:{}\u0026quot;,service.toString()); log.debug(\u0026quot; \u0026quot;); } @Override public void onClose(KubernetesClientException e) { } });  主要的功能实现都在这个event类中实现了，如果想watch pod的话，只需要将services()换成pods()即可\n主要的坑是在何处实现？ 原本的kubernetes中相关的信息收集，是在定时任务中实现的\n但是kubernetes的watch就已经相当于是一个线程了，如果做到让这个功能随着服务的启动而直接就启动了呢？\n我的处理方式，依然是使用的定时任务，不过是将定时任务的时间，设置了一个特别长的间隔，这样就算是只启动了一次了\n代码如下：\n@Scheduled(fixedDelay = 999999999) public void collectPod() { kubernetesService.watchPods(); }  ","date":"2018-12-25T15:08:35Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/4.jpg","permalink":"https://lllovol.com/spring3/","title":"SpringBoot开发中的一些小细节(三)KubernetesClient的使用与配置"},{"content":"背景 晚上 青果灵动的CEO刘睿（julao）来到了我们公司进行了一场演讲\n（以下都是按照julao的“我”）\n正题 其实是周三\n做了十五年了\n青果这家公司已经做了10年了\n每个人对游戏都有自己的价值观，所以这只是一次分享\np1 有人没有玩过游戏嘛？请举手 （有零星几个人举手）\n玩过俄罗斯方块嘛？\n玩过剪刀石头布吗？\n拼多多使用游戏化的方法，成功？ 其实并不是，拼多多并不是游戏化的方式成功了。\n这一次的分享只是一次学习的回报\n关于游戏化的建议： 不要做，我做了十五年，都没有搞清楚游戏化是什么，每一个游戏都有自己的逻辑\np2 游戏仅仅是娱乐？ 毁三观：  英国【报销门】，做一些假报销，==》卫报的游戏（调查你处议员的开支） 大概是个什么样的游戏呢？  登录这个游戏，就可以看到可能和议会有关的图片都上传扫描上去，然后可以看见其他的玩家打上的留言和标签， 所有人可以根据这些图片找出线索， 这仅仅只是一个游戏，并没有什么物质上的奖励，调查的结果又28名议员和这个案子有关。\n给我们一个非常重要的启示：20000名个玩家，为什么要去参加? 社会正义感？ 为什么游戏的这种方式会有效？    p3 光晕3中的人类保卫战（HALO3） 这是微软做的一个游戏，也是一个系列，是个在线联网的游戏 1500w名玩家发动的活动，人类保卫战。\n565天，消灭了一百e的外星人，平均每天1175个，每小时73万个。\n然后他们的成就被记录在 MUSEUM OF HUMANITY，做了个纪录片\n里面所有的故事和画面都是虚拟的，但是唤起的感情是真实的\np4 重新认识一下游戏 俄罗斯方块：你知道你终究都会失败，这个游戏是没有胜利者的，这个游戏是为了输才玩的\n内容并不新鲜，得分并没有奖励，so 为什么我们要玩俄罗斯方块？\n人类的大脑进化到今天，大概过了四十万年\n从经验\n到规律\n到指导行为\neg:为什么可以一边听演讲一边打字记下笔记？\n为什么我们知道桌上的水是水？\n游戏比现实更可预测！\n这就是为什么游戏那么吸引人的一个重要的前提\n游戏更加的不耐（进度反馈和不耐）\n人脑只有体重的5%，但是消耗了25%的能量，所以这是为什么甜食这么受人们喜欢的原因\np5 追女孩是一件很难的事情 但是如果谈恋爱有进度条\n我们的生物性，决定了我们的社会性\n（游戏红） 游戏好玩就和脂肪很香一样，都是植入了DNA的东西\np6 游戏是积极的！ 玩游戏超过12小时的举手！但是玩游戏是很累的！加微信\n因为游戏是个很累的一种事情\n再说自我决定论：\n人类有三个需求：能力需求，自主需求，关系需求\n 能力需求，又叫做掌控力，是积极处理与外部环境关系的能力\u0026ndash;hold住\n（偷懒和做能做的事情，是人的先天性的东西，就是做的顺手） 关系需求，涉及社会联系与家庭成员、朋友以及他人互动的愿望\u0026ndash;有人点赞\n（人类存在的意义就是被看到） 自主需求，是人自我设定的使命，是于个人价值观统一的\u0026ndash;目标达成  游戏里面有四个大的特征\n 目标：玩家努力达成的具体结果 规则：玩家如何实现目标作出的限制 反馈：告诉玩家距离实现目标还有多远 自愿：玩家要了解并愿意接受目标和规则（相当重要）   游戏，是自愿尝试克服种种不必要的障碍。 \u0026ndash;哲学家（xxx）\n 我定义的游戏：\n玩家在游戏中探索、学习和改进 自愿从事不必要的艰苦工作\n900个zelda，宝石，呀哈哈，我相当的肝！我真的很看重自己的成果\n玩游戏是一种最积极的人生态度\n玩的对立面不是艰苦工作\n不是游戏带来了空虚\n而是在游戏结束\n进入现实时迷失了方向\n（连续玩了36个小时，一睁眼就过去了，整个体验的过程中会无聊吗？不可能的，在过程中会获得到自己想要的东西）\n我承认游戏是有害的，因为游戏和现实是有很大的落差的\np7 游戏化  不是名词替换 不是营销包装 不是积分换奖励 不是比赛和排行榜 （趣头条？都不是什么新鲜的东西\n以上都只是游戏化的一种手段  游戏化，是一种新的目标管理  从外在目标向内在目标转变 游戏过程，本身就是奖励   （我知道在美国有一个学校，一个小学，整个学校的管理都是一种游戏化的管理，每天放学的时候，告诉同学：明天一早，学校会在博物馆中放5个信封，每个信封里面有一个任务。只要来到博物馆中前五的同学，才能完成这样的任务。没有奖励，但是有很多学生参加。这只是因为过程） （号召全员去跑步，打卡制，不太好。有个企业做的很好，跑向月球计划，超级远，“因为你今天跑了5公里，咱们公司离月球又近了一点”） （水滴筹，很羡慕，因为咱们先天性就能找到我们的价值，互助也是被，不建议把帮助别人，变成你怎么样就给你一块钱，你怎么样就罚你一块钱。市场关系（你给我钱我就干），社会关系（在宏大事情中的参与度））\n p8 参与要自愿 提供选择性而不是强制性\n（不能提供一个，你不怎么样就会怎么样）\n游戏化有一定是长期的\n游戏化就是设计游戏本身\nQ\u0026amp;A  Q:对外挂的态度和看法？\nA:外挂就是系统的漏洞 Q:为什么游戏是648？\nA:因为当初苹果规定的，那时候1刀汇率是6.48rmb Q:给竹子好课的游戏化的建议？\nA:做一个雷达，学习之后增加属性，增加反馈。不过不建议什么都做游戏化  ","date":"2018-12-21T19:24:46Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/3.jpg","permalink":"https://lllovol.com/share/","title":"大咖分享-对游戏的看法"},{"content":"Code Review 让大家对代码质量的标准是在一个线上， 是一个相互学习的过程。 blog主要是用来记录当时的笔记与自己的一些感想\n用户中心的接口，需要查用户之前捐过的一些订单 ContextUtil.getUserId(()不建议使用 限制了使用线程的场景，可能每一段代码执行的线程可能不在一起了 讲究的是 变量来源应该是外部的,参数是传入的 swing local ？本地的东西 context 在子线程中是无法工作的，Util这个工具类，不应该涉及到线程这种复杂的东西\ninterceptor， implements HandlerMethodargumentResolver，//可以直接解析参数（将token解析的过程，就放到这个里面了） (@LoginUidAttribute String uid)  拿到userId的，isDelete()可以不用判断 解决泛型，warning 加 PageHelper是用的swing local mapper上面的select 一定要体现一个sql,查询条件一定要解耦，不要太复杂了 不要写太多的if OrderBizMapper.xml 这样可以更好的去维护索引\n不建议使用copyProperties，只要一个属性对不上可能就会 使用long不建议使用int，java中一直诟病的，就是java中的对象看不出来到底是不是long null 新的语言都解决了 null会不会有问题的东西。 创建一个 optional约定就是，可能为null int 是不能为null的 interger是可以为null的 这样可以增加代码的意义的传递，这个就是一种约定 ，使用原生的类型比较好\n链式的一个使用的方式，每一个点放一个行,因为一个点就表示一个操作了 order.stream() .map(OrderBizVo::new) .collect(Collection.toList())这样会更加java 8一点 .map() .distinct() .collect(Collections.toList()) //就可以  返回给前端最好返回是一个空的集合而不是一个null，这样前端会更好处理一点 每一个表建表的时候都需要加一个 isDelete update 不涉及索引的，不能一味使用 查sql，一般不应该根据sql来加，先是业务来看怎么查的？（冲突与建议）查询的时候只能将sql交给dba，沟通的简洁 连点增加锁的操作，token不用放在数据库中，这种没必要持久化的东西，就放到redis中 为什么是double check? 是处理单例的时候才会使用double check，早起的java处理指令重排的时候，会导致一个check会被跳过去的，所以才处理了double check （在说什么？我怎么开始听不懂了），两次的话，就总有一次会成功\ne.printStackTrace()是禁止的 使用\nlog.error(\u0026quot;\u0026quot;,{},e);  token的延长时间 一个是长效token,一个是短效的token,这样子的话会更加安全一点\n左边代码行的地方右键使用annotation 可以看见是谁写的代码 这个功能就很尴尬啊（原来是可以知道代码是谁写的啊）\n不要在异常中处理业务逻辑 每次抛异常的时候，会把栈中的东西都抛出去，使用runtimeException来处理（对性能要求高的时候，code优先，返回ErrorCode）\n批量长链接转短链接url 使用key value，放在redis中，同时可以存在db，在上边加一个缓存加一层redis toC查询的过程\n连续插入 上一个请求insert来了，马上又来了一个 批量 insert ignore 就行了，插进去就行了 通过一个id，md5（效率很快）的碰撞概率，smartcode 短连接然后就可以返回给 这个算法的奥义是六位，然后保证不会重复\n The MD5 message-digest algorithm is a widely used hash function producing a 128-bit hash value. Although MD5 was initially designed to be used as a cryptographic hash function, it has been found to suffer from extensive vulnerabilities. 维基百科\n 我们尽量不要使用事物，transaction，并发性会很低 这是一定可以避免的，使用最终一致性 更新很多表的问题，应该很少出问题 后台打log,都会有专门的人来进行数据的修复，不要为了这个牺牲性能 （先跑，然后就人来修） 使用事物的话，还会对数据库造成锁的问题 事务的话应该尽量的小\n批量更新的建议 整个这个东西，最开始的时候一定要分批的去搞 超过100个的时候就是一批？\nredis redis 有pipeling来做，速度会比较快 zSet是排序， mSet是大量的，但是好像没有超时的时间， 批量写缓存\nStringUtils 有isEmpty(),也有isNotEmpty()\n","date":"2018-12-20T20:01:33Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg","permalink":"https://lllovol.com/spring2/","title":"SpringBoot开发中的一些小细节(二)CR笔记"},{"content":"概览 平时学习工作中，总会使用到各种各样的数据结构，map、set、LinkedHashMap等等，虽然在使用的过程中对此有了一定的了解，但是感觉还是不是很通透。故此写一篇blog用于总结java中的数据结构。\nJava的容器类 Java中的容器类按照大的来分，主要可以分为：\n collection：存储着对象的集合 map：存储着key，value的键值对 接下来的主要就分别以上面两个类别展开进行整理  Collection List    List类别 特点     ArrayList 基于动态数组实现，支持随机访问，允许所有元素包括null   Vector 与ArrayList相似，但是Vector是线程安全的（同步的）   LinkedList 基于双向链表，只能顺序访问，可以快速的再链表中插入和删除元素（栈[Stack]、队列[Queue]、双向队列[Deque]）。没有同步方法   Stack 继承自Vector，实现一个后进先出的堆栈。额外提供了5个方法使得Vector可以被当做堆栈使用：push,pop,peek,empty,search。刚刚创建的时候是空栈     和LinkedList一样，ArrayList也是非同步的（unsynchronized）。一般情况下使用这两个就可以了，因为非同步，所以效率比较高。 如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。 几种java容器\n 有几个问题\n ArrayList的扩容操作？  每一次扩容都会扩容到原来的1.5倍，使用grow()方法，第一次添加元素的时候分配10个对象空间，当添加到第11个元素的时候，就会扩容到原来的1.5倍，当添加到16个元素的时候，就会扩容到原来的15*1.5的大小，等等。每一次扩容都是通过Array.copyof(elementData,newCapacity)来实现的，会消耗大量的资源，代价比较大，因此在知道大致对象大小的时候，提前设置好ArrayList的大小是非常明智的选择。（old+old\u0026raquo;1)\n 为什么Vector是线程安全的？  Set    Set类别 特点     SortSet(TreeSet) 基于红黑树有序，TreeSet是set的一种变体，是可以实现排序等功能的集合 O(logN)   HashSet 基于hash表实现，可以看成一个只有key的HashMap O(1) ，不允许重复，无序，允许存在null(最多一个)   LinkedHashSet 具有HashSet的查找效率，且内部使用了双向链表维护了元素的插入顺序,保证了集合的有序性     写了 HashMap 和 HashSet，然后我们可以看到 HashSet 的方法基本上都是基于 HashMap 来实现的，说白了，HashSet内部的数据结构就是一个 HashMap，其方法的内部几乎就是在调用 HashMap 的方法。 LinkedHashSet 首先我们需要知道的是它是一个 Set 的实现，所以它其中存的肯定不是键值对，而是值。此实现与 HashSet 的不同之处在于，LinkedHashSet 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。 看到上面的介绍，是不是感觉其与 HashMap 和 LinkedHashMap 的关系很像？LinkedHashSet就是使用LinkedHashMap来实现的。 注意，此实现不是同步的。如果多个线程同时访问链接的哈希Set，而其中至少一个线程修改了该 Set，则它必须保持外部同步。\n Queue 队列与Stack的区别在于，Stack的删除与添加都在队尾进行，而Queue删除在队头，添加在队尾\n   Queue类别 特点     LinkedList 基于双向链表，只能顺序访问，可以快速的再链表中插入和删除元素   PriorityQueue 基于堆结构实现，可以用来实现优先队列    Map HashMap HashMap实际上就是java中最基本的两个结构所实现的：数组和指针。通俗的说，就是数组和链表的结合体。（HashMap如何实现）\n 每一个Entry的结构中包含了 key,value, int hash,和下一个Entry的指针next 然后构造HashMap的时候，会初始化一个数组 table=new Entry[capacity] 由此看来，entry就是键值对，另外还包含了写一个next的Entry指针，由此构成了链表 在我们想要查找某一个元素的时候，只需要key和hash值，就能知道这个元素在什么位置，而不用去遍历链表，优化了查询的效率 HashMap的底层数组总是2的n次幂，这样的好处是可以让不同的key算出来的index相同的几率较小，那么数据在数组上的分布就会比较均匀 从HashMap中get元素的时候，先计算出key的hashcode，然后找到数组中对应位置的某一元素，然后通过key的equals方法在对应的位置链表中找到需要的元素   当 HashMap 中的元素越来越多的时候，hash 冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对 HashMap 的数组进行扩容，数组扩容这个操作也会出现在 ArrayList 中，这是一个常用的操作，而在 HashMap 数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是 resize。\n  那么 HashMap 什么时候进行扩容呢？当 HashMap 中的元素个数超过数组大小 *loadFactor时，就会进行数组扩容，loadFactor的默认值为 0.75，这是一个折中的取值。也就是说，默认情况下，数组大小为 16，那么当 HashMap 中元素个数超过 160.75=12 的时候，就把数组的大小扩展为 216=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 HashMap 中元素的个数，那么预设元素的个数能够有效的提高 HashMap 的性能。\n 初始容量为16，负载因此为0.75，只要超过了16*0.75=12的时候，就会进行扩容到原来的两倍\n遍历的时候最好使用map.entrySet().iterator()的方式，效率比较高 HashMap是非同步的。\n解决hash冲突的方法：\n   方法 内容     开放地址法 按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素（线性探查法、平方探查法、双散列函数探查法）   链地址法（拉链法） jdk1.7 全都是单链表来存储同义词，jdk1.8之后，如果链表的长度大于8，会转换为红黑树来存储   再哈希法 同时构造多个不同的哈希函数，直到冲突不再产生，但是增加了计算时间   建立公共溢出区 将哈希表分为公共表和溢出表，当溢出发生的时候，将所有的溢出输出统一放到溢出区    HashTable  与HashMap特别的相似，但是HashTable是线程安全的（如果想使用一个线程安全的HashMap,可以使用Collections类中的synchronizedMap()方法） HashTable不允许null（key value 都不行），HashMap允许一个null的key,若干的value的null  LinkedHashMap LinkedHashMap是HashMap的一个子类，它保留了插入时候的顺序，如果需要在输出的时候保持和输入的顺序时相同，就使用本结构（一言：有序的HashMap）\n 维护着一个云星宇所有条目的双重链接列表。这个链接定义了迭代顺序，可以是插入顺序或者是访问顺序 和HashMap一样，都是不同步的 可以实现LRU缓存（Least Recently Used),把最近最少使用的数据溢出，让给最新读取的数据。  ConcurrentHashMap ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。（基于java的内存机制（mark））(没有ConcurrentHashTable这个类)\nSortedMap(TreeMap) SortedMap mapA = new TreeMap(); Comparator comparator = new MyComparator(); SortedMap mapB = new TreeMap(comparator);  能够自然排序的一个map，用的并不是那么多\n参考网站    动画演绎Java常用数据结构 java集合学习指南 解决哈希冲突的常用方法  ","date":"2018-12-16T22:23:46Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/1.jpg","permalink":"https://lllovol.com/java/","title":"Java中的容器类"},{"content":"原来写的代码被CTO抓出来吐槽，发现确实都是一些当初自己没有注意到的地方，打算将这样的小细节一点一点的收集起来，养成更好的编码习惯。\nSlf4j  The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time. 摘自https://www.slf4j.org/\n 在编写Spring的代码的时候，只需要在Class上方添加一个@Slf4j的注解即可。slf4j是facade pattern的典型例子（隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口，又被成为门面模式或者外观模式） 使用的时候，可以使用占位符的方式进行日志的记录，省去了原来自己拼接日志的麻烦。\n log.debug(\u0026quot;wxpushGet() returned: {}\u0026quot; ,result);  但是有一些需要注意的地方。\n 在日常开发调试的时候应该少用log.info()，而应该使用log.debug，不然在上线之后，就会产生很多冗余的信息。 只有在线上部署的时候，关键代码的信息，才使用log.info(),来显示日志的信息。千万不能滥用！ 在catch的抛出错误的时候，使用log.error()。会打印错误以及异常的信息 log.warn(),用于打印潜在的用户的错误可能的信息。  Dto等model的@Data注解 @Data注解，可以实现类的Getter和Setter的同时还有toString方法，没有必要自己再转一次Json(如果只是打印个日志的话)，lombok生成的toString的可读性是很高的\n Lombok 是一种 Java™ 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO Plain Ordinary Java Object）。它通过注解实现这一目的。\n Rest的post和get rest风格不是随便使用get的(这是一个前辈给我说的，有次看了不少相关的文章和介绍，包括get和post到底有什么区别)\n REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。\n 理解Restful架构 Restful Api 设计指南 get和post有什么区别 get和post比较另类的区别（没有区别）   今天前辈在看我的代码的时候，就问我为什么所有的都是get，说实话，当时的我真的是懵逼的。 我脑海中原来get和post区别大概如下：\n get请求要比post快 get用户可以直接修改参数，post是将数据放在request body中，稍微安全一点 get一般是用来请求数据 post一般是用来发送数据  大概就是如上的内容了，然后在读完上面几篇文章后，又有了新的认识：\n get在浏览器回退的时候是无害的，而post会再次请求（应该就是返回上一页面的时候，get秒回，post会重新请求） get请求会被浏览器主动cache,而post不会，除非手动自己设置 get请求只支持url的编码，而post支持多种编码的方式 get请求的参数会被留在浏览器的历史记录当中，但是post不会 get请求的参数有长度限制，但是post没有 get只接受ASCII字符，而post没有限制 get的参数会直接暴露在url上，因此不能用来传递敏感的信息 get的参数通过url来传递，而post是直接放在request body当中的  上面的很多标准答案的概念，其实都是慢慢的通过人员长期使用形成了一部分思维定式，上面的文章之一的观点就有不同的见解：\n 给post加上url传参，给get加上request body,在技术上都是可以实现的，只是不能通过浏览器实现，但是并不是所有的网络服务都是通过浏览器来的 两者都是单纯的源于http协议，只有一丁点根本的区别，一个用于获取数据，一个用于修改数据 get的长度限制，主要是浏览器服务器等，为了防止一些黑客的攻击来进行的限制，和get、post的无关。 可以在get的车里放data,也可以在post车外面放data,但是这样很蠢  ","date":"2018-12-14T19:13:00Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg","permalink":"https://lllovol.com/spring1/","title":"SpringBoot开发中的一些小细节(一)Slf4J、Post和Get的小技巧"},{"content":"概览  实习工作回顾 实习主要产出 没做好的地方 做的好的地方 成长以及收获 个人成长计划  实习工作回顾 从9月17号入职，实习至今，已将近有三个月的时间，全勤，认真负责的完成份内的工作，并且主动承担自己力所能及的其他任务。在海洋前辈的指导下，开发了nintendo，并且独立完成了运维的部分的自动化运维工具。\n实习主要产出 Devops Nintendo平台 从零开始搭建的公司内部自研devops平台\n 负责了gitlab方面的数据收集以及处理部分  获取gitlab的group，project，tag，commit，job分别持久化存储到MongoDb当中，实现相应的CRUD,以及返回数据的分页。 产品线的CRUD。 增加字段判断服务是不是公共服务，是不是需要部署，将服务与产品线相关联。 nintendo增量更新信息，使用gitlab的webhook回调更新tag信息，再通过SpringTask定时任务更新新增的project，并为新的project自动添加hook，实现数据的自动化更新。 通过pipeline，tag，定位到job，取得要运行的jobid，进行发版，实现部署发布服务的最初版本的接口（后期前辈改用了线程去实现，异步的去执行）。 获取gitlab执行job后的日志并进行处理，返回到前端。 改进接口，不传env的显示所有的服务，这样实现同一业务线下的服务可以部署到不同的环境下。   集成ldap，实现了用户的登录与登出，将用户登录状态记录在缓存中并返回一个token，使用redis实现，将来流量大的时候能够解决分布式问题。 nintendo的intercepter拦截器实现，同时记录下用户的操作日志，并且提供了用户的操作日志的模糊查询以及分页。 实现一个服务的tag和commit相关联，使得用户能够知道本次发布都更新了那些信息。 集成企业微信，并与上一个功能结合起来，实现用户发布服务之后，将服务发布的状态与信息发送给相关联的用户。  优化改进企业微信为卡片信息显示的样子。 卡片信息可以直接跳转到指定的服务日志地址进行查看，并且生成对应用户自带的token，实现免登陆直接查看，提高了用户体验。   平台信息显示的优化，将用户从拼音的显示转化为真正的名字来进行显示。 nintendo平台的历史功能部署实现。  每个人发布的tag，会帮他筛选出最近部署的5个服务，显示出最近发布的版本。 使用redis来进行存储对应的username,tag,service。 添加tag push类型的webhook，在tag进行更新的时候，更新对应user的对应的service信息。   nintendo平台一键部署到多环境的功能实现。  Autotool自动化运维工具  Ldap中rds组用户的自动化添加：基于LDAP自身的数据实现，每隔一段时间，遍历各个department，将符合条件的人员放进一个Set,再与rds中原来的用户进行比对，将新的用户添加到rds的members当中。 jumpserver的grey log_select test的跳板机权限的自动化添加：基于ldap和rds组和jumpserver的用户组实现，如果rds的用户组中出现了jumpserver中不存在的用户，自动为其创建一个账户，并且添加test log_select test的权限。  aaa项目升级与完善  将项目升级到Spring Boot 2.0，并且修复由于升级而造成的bug。 给aaa项目添加swagger-ui 企业微信消息发送Api的依赖封装与接口实现。  实现获取Token的接口，使得其他业务的同事能够使用这个token进行文件上传的功能 实现发送普通消息的接口 实现发送卡片信息的接口 实现发送文件信息的接口    没做好的地方  处理问题的方式不够完善和全面，在实现给每个project添加hook的时候，不小心多加了几条重复的数据，第一想法是将所有的hook全部删除，然后被海洋前辈及时制止：* “如果有的项目本身就有一些hook呢？你不能全部都删了。” * 最后改进，在删除的时候，判断是不是需要删除的url，如果匹配成功才执行删除操作。 查询日志的时候，不应该以当前的时间往前倒退一天，正常的操作应该是以一个零点作为时间点来进行查询。 jumpserver自动化运维工具所使用的账号，不应该是我个人的账号，由于原本使用的个人账号，后期因为我更改了密码，导致工具在一段时间内失效。 构建模板样式的工作没有放在值对象外面,这样的设计换不了模板，后来将api的包改为了单纯封装http请求，这样才能保证代码的可维护性和可拓展性。 升级aaa的时候，由于依赖版本的更新，更改代码之后没有进行逻辑方面的测试，就上线发版，导致了新入职的人员没有及时的同步与更新。以后对于线上的操作要万分慎重，无论多么小的改动，都需要进行仔细的测试，再进行提交。  做的好的地方  将公司的核心价值观牢记于心，并且贯彻落实到生活工作中。  用户第一 追求极致 开放心态 拥抱变化 诚信严谨 勤俭敬业   在不明白的地方及时的请教前辈，深知团队协作才能发挥1+1\u0026gt;2的能量。 对于学习工作中学习到的新的知识，会将其记录下来，深知好记性不如烂笔头的道理。 能够积极主动去承担工作中的任务。 对新事物永远保有一颗探索与发现的心，不断学习充实自己。  成长以及收获  熟悉了SpringBoot的框架，Initializer的使用和Swagger的使用，以及Spring的各种映射注解的使用（例如使用@Getter @Setter或者@Data，而不是原来每一次都generate Getter and Setter,一旦成员变量有一些变动，就需要维护很多地方），使用注解调动配置文件中的信息等等。 更加熟练地掌握了java代码的编写，更加熟悉了了解其中HashSet,HashMap以及有序的LinkedHashMap等数据结构（例如使用HashMap实现空间换取时间），使用了mock数据给前端进行同步开发，使用枚举类型来避免魔法数的产生等很多的细节。 更好的代码习惯养成，例如尽量重用对象，尽量使用局部对象，尽量减少对变量的重复计算，减少对象的IO，优化代码的体积等等。 更加熟悉了解了MongoDb这样的非关系型数据库。 更加熟悉了解了redis这样的分布式缓存。 更加熟悉了解了LDAP。 docker以及Kubernetes等关于微服务的相关知识，常用的命令行指令查看pods状态信息和日志。 CI/CD（Continuous Integration/ Continuous Deployment）方面的了解，熟悉了一个项目发布流程和整个生产的生命周期 gitlab,github等团队项目管理工具的使用。 maven构建项目，以及nexus公司私服服务器的使用。 AOP的面向切面的编程思想，将为业务逻辑所公用的逻辑封装起来，减少系统的重复代码，降低模块之间的耦合度，有利于未来的可操作性和可维护性。 提升了对各种官方文档的阅读能力和理解能力。 从刚进公司的龟速一指禅打字，到现在40wpm左右的规范指法打字。 OKR的这种聚焦的工作管理方式。  个人成长计划 不断积累方方面面的知识，主攻后端，也可以懂一点前端知识，也可以懂服务器的搭建，项目的发布等运维相关的知识，也可以懂DBA等等，希望自己能够成为一个全栈复合型的人才。虽然这难度很大，但是也正因为有挑战，才会更有价值。海洋前辈给我说，坚持每周写至少一篇技术型的文档，这将对自己的能力提升有很大帮助，我深表赞同，并将坚持下去。\n “立足于技术，但是不受限于技术，不要给自己设置一个上限”\n 东哥说的这句话，我铭记于心，并将不断丰富充实自己。\n","date":"2018-12-09T17:19:50Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/how-to-start.jpg","permalink":"https://lllovol.com/summary/","title":"实习总结与报告"},{"content":"前言 想给atom安装beautify的插件 使用apm install atom-beautify 和是用preference中的插件安装都失败了\nStart 使用github 克隆到本地，然后安装\n cd ~/.atom/packages git clone https://github.com/Glavin001/atom-beautify.git cd atom-beautify npm install  Success 使用control + alt + b 组合键 即可\n","date":"2018-12-07T17:03:25Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/3.jpg","permalink":"https://lllovol.com/%E5%AE%89%E8%A3%85atom%E7%9A%84atom-beautify/","title":"安装atom的atom-beautify"},{"content":"前言 最近看的一本书的随笔，摘抄与记录\n七个习惯的简要的概要  习惯一，积极主动。由内而外的改变，积极面对一切 习惯二，以终为始。所有的事物都经过了两次创造，先在脑海中酝酿，其次才是实质的创造 习惯三，要事第一。次要的事情不必摆在第一，要事不能放在第二 习惯四，双赢思维。无论工作伙伴还是家庭成员，要从互赖式的角度思考 习惯五，知彼解己。舍弃回答心，改以了解心去聆听别人 习惯六，统合综效。创造第三种选择，是互相尊重的成果，创造式的合作，1+1\u0026gt;2的方式 习惯七，不断更新。身体、精神、智力、社会，不断更新自己  变化的世界不变的原则  恐惧感和不安全感：在现代社会有太多的人保守不安全感的折磨，担心自己失业，担心自己无力养家，也因此助长了一种现象就是：人们不论是在工作还是生活中，都倾向于选择一种零风险的生活，并且逃避和他人互相依赖和合作。（不能说这种想法就是错的，就像元素守恒的道理是一样的，风险和收益往往都是成正比例的，高回报的同时也伴随着高风险，而低风险往往伴随着平平淡淡；而合作的好处更是不言而喻，例如，在现代的敏捷软件开发过程中，出现了pair programming，可以增加纪律性，写出更加优秀的代码。就如同书中所说，我们生活在一个相互依赖的社会中，最辉煌的成就都是靠着互相依赖和合作才能成就的，远远不是个人能力了就能够企及的。） 我现在就想得到：我们必须训练头脑，大量投入，不断磨练，提升自己的竞争力，以免被社会所淘汰。绝对不能就满足于学校的教育。人生处处皆高考，这是我高中班主任最常给我们传授的一句话，而现实也正是如此。 缺乏人生平衡：懂得轻重缓急，抓住生活的重点，客观面对现实 我的定位在哪儿：真正的大事业，通常只会由思维开阔、内涵丰富的头脑，经由忘我的合作精神\u0026ndash;互敬和双赢取得的 渴望理解：想要获得其他人的理解，那么自己需要成为一个聆听着，学会去理解他人 冲突与分歧：采用创造性的合作，找到比双方最初想法都要好的解决方法。  产能平衡的原则 秉承自己内心的价值观，产生自己的自尊自重与自制力，以自己内在的价值标准，而不是以别人的好恶或者与别人的评价的结果，来衡量自己。事情的对错与别人是否发现无关。\n不再让别人影响自己的情绪，反而会更加容易接受变化，因为可以有一些恒久不变的内在的本质，可以作为支柱\n对自己要有耐心，因为自我成长是神圣的，同时也是脆弱的，是人生中最大规模的投资。\n“得之太易者必不受珍惜。唯有付出代价，万物始有价值。上苍深知如何为其产品制定合理的价格”\n待续。有缘再更\n","date":"2018-12-06T10:22:08Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/software.jpg","permalink":"https://lllovol.com/msg/","title":"高效能人士的七个习惯"},{"content":"前言 想要在blog中实现文章评论发布功能，网上百度了很多文章，发现DISQUZ国内网访问速度比较慢，网易评论等平台也被关闭，最后发现了github强大功能，Gitalk。\n Gitalk：一个基于 Github Issue 和 Preact 开发的评论插件 摘自v2ex\n 再一次感受到了开源的强大之处，造就了现如今信息技术的高速发展\n设置OAuth github\u0026gt;右上角settings\u0026gt;Developer Settings\u0026gt;new OAuth App 然后依次输入\n Application name : 一个超厉害的名字 Homepage URL : github page的地址（http://yourname.github.io/） Application description : app的描述（随意） Authorization callback URL : Github api回调的地址，与Homepage URL相同  有一些坑需要注意，如果解析到了自己的域名，就在githubpage中的Repository，找到settings，找到github给你的url 即可获取到对应的clientId和clientSecret 修改post.html 然后在修改项目文件中的_layouts的post.html 找到合适的位置添加如下代码\n\u0026lt;!--Gitalk评论start --\u0026gt; {% if site.gitalk.enable %} \u0026lt;!-- 引入Gitalk评论插件 --\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://unpkg.com/gitalk/dist/gitalk.css\u0026quot;\u0026gt; \u0026lt;script src=\u0026quot;https://unpkg.com/gitalk@latest/dist/gitalk.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026quot;gitalk-container\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var gitalk = new Gitalk({ clientID: '{{site.gitalk.clientID}}', clientSecret: '{{site.gitalk.clientSecret}}', repo: '{{site.gitalk.repo}}', owner: '{{site.gitalk.owner}}', admin: ['{{site.gitalk.admin}}'], distractionFreeMode: {{site.gitalk.distractionFreeMode}}, id: decodeURI(window.location.pathname), }); gitalk.render('gitalk-container'); \u0026lt;/script\u0026gt; {% endif %} \u0026lt;!-- Gitalk end --\u0026gt;  修改_cofig.yaml gitalk: enable: true #是否开启Gitalk评论 clientID: 'your clientId' #生成的clientID clientSecret: 'your clientSecret' #生成的clientSecret repo: 'yourrepo.github.io' #仓库名称 owner: 'yourname' #github用户名 admin: 'yourname' distractionFreeMode: true #是否启用类似FB的阴影遮罩  提交代码 然后\ngit add . git commit -m \u0026quot;your msg\u0026quot; git push  到github上，过一会，刷新github page就可以看见评论功能啦~\n欢迎留言~\n","date":"2018-12-05T18:08:38Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg","permalink":"https://lllovol.com/gitalk/","title":"基于Gitalk实现文章的评论功能"},{"content":"使用github.io来写blog 本就是件很棒的事情，但是每次在想写新的文章的时候，都需要重新复制title和开头的标签，如果能够自动化地完成这件事就好了（重复性的东西工作）\nAbout Rakefile  Rake is a Make-like program implemented in Ruby. Tasks and dependencies are specified in standard Ruby syntax.\n 摘自http://docs.seattlerb.org/rake/\n安装Rake sudo gem install rake  即可\n创建Rakefile 在项目的根目录下\ntouch Rakefile vim Rakefile  然后添加如下代码\ntask :default =\u0026gt; :new require 'fileutils' desc \u0026quot;创建新 post\u0026quot; task :new do puts \u0026quot;请输入要创建的文章文件文件名字：\u0026quot; @url = STDIN.gets.chomp puts \u0026quot;请输入文章的标题：\u0026quot; @name = STDIN.gets.chomp puts \u0026quot;请输入文章的子标题：\u0026quot; @slug = STDIN.gets.chomp puts \u0026quot;请输入文章的分类，以空格分隔：\u0026quot; @categories = STDIN.gets.chomp puts \u0026quot;请输入文章的标签：\u0026quot; @tag = STDIN.gets.chomp @slug = \u0026quot;#{@url}\u0026quot; @slug = @slug.downcase.strip.gsub(' ', '-') @date = Time.now.strftime(\u0026quot;%F\u0026quot;) @post_name = \u0026quot;_posts/#{@date}-#{@slug}.md\u0026quot; if File.exist?(@post_name) abort(\u0026quot;文件名已经存在！创建失败\u0026quot;) end FileUtils.touch(@post_name) open(@post_name, 'a') do |file| file.puts \u0026quot;---\u0026quot; file.puts \u0026quot;layout: post\u0026quot; file.puts \u0026quot;title: #{@name}\u0026quot; file.puts \u0026quot;slug: #{@slug}\u0026quot; file.puts \u0026quot;author: ymkNK\u0026quot; file.puts \u0026quot;date: #{Time.now}\u0026quot; file.puts \u0026quot;categories: #{@categories}\u0026quot; file.puts \u0026quot;tags: #{@tag}\u0026quot; file.puts \u0026quot;img: 1.jpg\u0026quot; file.puts \u0026quot;---\u0026quot; end exec \u0026quot;vim #{@post_name}\u0026quot; end  代码中的author等属性可以自行进行修改\n使用Rakefile生成文章 在项目的根目录下打开命令行\nrake new  依次输入相关的信息就可以在_post下看见新生成的文件啦\n","date":"2018-12-05T01:23:16Z","image":"https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/1.jpg","permalink":"https://lllovol.com/rake/","title":"使用Rakefile实现文章生成器"},{"content":"Just Want to Share and Record Some Useful,Interesting Things !\n","date":"1996-10-14T08:08:08Z","permalink":"https://lllovol.com/welcome/","title":"Welcome"}]