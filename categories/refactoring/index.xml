<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Refactoring on lllovol</title>
    <link>https://lllovol.com/categories/refactoring/</link>
    <description>Recent content in Refactoring on lllovol</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 07 Feb 2022 20:17:32 +0000</lastBuildDate><atom:link href="https://lllovol.com/categories/refactoring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《重构》-代码的坏味道</title>
      <link>https://lllovol.com/p/2022/2/refactoring-chapter3/</link>
      <pubDate>Mon, 07 Feb 2022 20:17:32 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2022/2/refactoring-chapter3/</guid>
      <description>神秘命名 整洁代码最重要的一环就是好的名字，所以我们会深思熟虑如何给函数、模块、变量和类命名，使他们能清晰表面自己的功能和用法。
 需要考虑取一个好的名字  重复代码 如果你在一个以上的地点看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好。
 抽取重复代码，使之能够复用  过长函数 据我们的经验，活得最长、最好的程序，其中的函数都比较短。
短的函数具有更好的阐释力、更易于分享、更多的选择。
函数越长，就越难理解。
每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。
条件表达式和循环常常也是提炼的信号。
 可以考虑使用横屏显示器进行开发，这样潜意识里就不会把一个函数写的过长  过长的参数列表 过长的参数列表本身也经常令人迷惑。
如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数去掉第二个参数。
使用类可以有效地缩短参数列表。
 Go中可以使用struct的方式，来传入较多的参数  全局数据 全局数据是最刺鼻的坏味道之一。
一次又一次，全局数据造成了哪些诡异的bug，而问题的根源却在遥远的别处，想要找到出错的代码难于登天。
良药与毒药的却别在于剂量。有少量的全局数据或许无妨，但数量越多，处理的难度就会指数上升。
 尽量少使用全局变量  可变数据 对数据的修改经常导致出乎意料的结果和难以发现的bug。
如果可变数据的值能在其他地方计算出来，这就是一个特别刺鼻的坏味道。
发散式变化 一旦需要修改，我们希望能够跳到系统的某一点进行修改，只在此处进行修改。如果不能做到这一点，你就能嗅出两种紧密相关的刺鼻味道中的一种了。
 一个类受多种变化的影响  散弹式修改 如果遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是散弹式修改。
 一种变化引发多个类对应改动  依恋情结 所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。
如果一个函数跟另一个模块的函数或者数据交流格外频繁，远胜于在自己所处模块内的交流，这就是依恋情结的典型情况。
 函数对某个类的兴趣高过对自己所处类的兴趣  数据泥团 你常常可以在很多地方看到相同的三四项数据：两个类中相同的字段、许多函数签名中相同的参数。
 两个类中同样的字段、很多函数签名中同样的參数 这种情况汪汪和历史遗留问题相关  基本类型偏执 大多数编程环境都大量使用基本类型，即整数、浮点数和字符串等。
一个有趣的现象：很多程序员不愿意创建对自己的问题域有用的基本类型。
字符串是这种坏味道的最佳培养皿，比如，电话号码不只是一串字符。
重复的switch 我们现在更关注重复的switch：在不同的地方反复使用同样的switch逻辑（可能是以switch/case语句的形式，也可能是以连续的if/else语句的形式）。应该以多态取代条件表达式消除掉。
 例如可以使用策略模式等方式  循环语句 函数作为一等公民以及得到广泛的支持，因此我们可以使用以管道取代循环来让这些老古董退休。
管道操作（如 filter和map）可以帮助我们更快地看清被处理的元素以及他们的动作.</description>
    </item>
    
    <item>
      <title>《重构》-重构的原则</title>
      <link>https://lllovol.com/p/2021/12/refactoring-chapter2/</link>
      <pubDate>Tue, 07 Dec 2021 21:05:58 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2021/12/refactoring-chapter2/</guid>
      <description>前言 本文是一篇关于Martin Fowler《重构：改善既有代码的设计》的第二章读书笔记与总结。
何谓重构 很多一线的实践者会非常随意的使用重构这个词，但是作者会非常严谨地使用重构。
 重构（名词）：对软件内部的结构的一种调整，目的是在不改变可观察行为的前提下，提高其可理解性，降低其修改成本 重构（动词）：使用一系列重构手法，在不改变可观察行为的前提下，调整其结构。  重构的关键在于运用大量微且保持软件行为的步骤，一步步达成大规模的修改。 每个单独的重构呀么很小，要么由若干个小步骤组合而成。这样的好处是，即使重构没有完成，也可以在任何时刻停下来，代码很少进入到不可工作的状态。
重构与性能优化 二者有很多相似之处
 都需要修改代码 都不会改变程序的整体功能  区别
 重构是为了让代码更容易理解，更易于修改。这可能会让程序运行的更快，也可能运行的更慢。 性能优化时，只关心如何让代码程序运行得更快，最终得到的代码有可能更难理解和维护，对此需要有心理准备。  两顶帽子 Kent Beck提出了两顶帽子的比喻。使用重构技术进行软件开发是，可以把自己的时间分配给两种截然不同的行为：
 添加新功能：不应该修改既有的代码，只管添加新功能。同时需要添加测试并且让测试正常运行。 重构：不再添加新的功能，只调整代码的结构。此时不应该添加任何测试，只有在绝对必要的时候才修改测试。  但是在实际的开发过程当中，我实际会经常变换帽子：当我开始添加新功能时候，突然意识到如果把程序结构修改一下，功能添加会容易很多。于是就换上了一顶重构帽子，开始了一会的重构工作。当程序结构调整好了之后，又戴上了原来的帽子。
总之，整个过程中，无论何时何地，都要清楚当前的自己戴的帽子究竟是哪一个，并且了解不同的帽子对编程状态提出的不同的要求
为何重构 重构绝对不是包治百病的灵丹妙药，更不是所谓的“银弹”，但是绝对算是一把银钳子，可以帮你始终良好的控制自己的代码。 重构是一个工具，它能够用于以下几个目的：
重构改进软件的设计 如果没有重构，程序的内部设计（架构）会逐渐的腐败变质。当人们只为了短期目的而修改代码时，经常没有完全理解架构的整体设计，于是代码就逐渐失去了自己的结构。（屎山代码就是这么来的，但是没有办法避免） 越难看出代码的设计意图，就越难保护其设计，腐败的也就越快。经常的重构有助于代码为支持自己该有的形态。 同时，消除重复代码，就可以确定所有事物和行为在代码中只表述一次，这才是优秀设计的根本。
重构使软件更容易理解 虽然代码是在计算机上运行的，编程的核心就是“准确的说出我想要的”，但是除了计算机之外，源码还有其他读者，几个月之后可能会有另外以为程序员尝试读懂我的代码并且进行一些修改。我们很容易就忘记了这个读者，“又不是不能用”，然后这个代码就这么写出来了。而后人可能会花费很多时间来理解和阅读我的代码。
因此，我们需要改变一下开发的节奏，让代码变得更加易于理解。重构可以让代码更加易读。
做一个懒惰的程序员，表现形式之一就是，总是记不住自己写过的代码。对于任何能够立刻查阅的东西，都可以故意不去记它，别把自己的脑袋塞爆了。尽量把需要记住的东西写在代码里。
重构帮助找到bug 重构的时候，能够更加深入的理解代码的所做所谓，并立即把新的理解反映在代码当中。在弄清楚程序结构的同时，必须要做一些假设去验证，因此想不把bug找出来都难。
 Kent Beck：我不是一个特别好的程序员，我只是一个有一些特别好的习惯的还不错的程序员
 重构提高编程速度 最后，前面的一切都归结到了这一点: 重构能够帮助我们更快的开发程序。
这虽然有点违反直觉，因为重构本来就是一件耗费精力的事情。但是如果一个代码全靠补丁来不断的修复，最后就是补丁补补丁，需要考古学家才能弄清楚这个代码到底是怎么个回事。以至于最后，这个系统的负担会不断拖慢新增功能的速度，到最后程序员恨不得重头开始写整个系统。
如果代码很清晰，引入bug的可能性就会很小，即使引入的bug，调试和排查也会容易很多。理想情况下，我的代码库会逐渐严骅成为一个平台，在其上可以容易的构造与其领域相关的新功能。
 设计耐久性假说：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间的保持开发的快速。
 何时重构 编程的每个小时，都应该去做重构。有几种方式可以把重构融入工作过程中。
三次法则  第一次做某件事的时候尽管去做 第二次做类似的事情会产生方案，但是无论如何还是可以去去做 第三次再做类似的事情，就应该去重构  预备性重构：让添加新功能更容易 重构的最佳时机就是在添加新功能之前
帮助理解的重构：使代码更易懂 需要理解代码做什么才能着手修改
 比如看到一段迷惑的代码，自问，能不能重构它，让它看起来一目了然？ 看到结果糟糕的条件判断，想修改，发现函数命名太糟糕了？ 等等，都是重构的机会。哪怕只是修改函数的命名这类重构，只要能够更加清楚的表达出一图，都会是非常有意义的。这些初步的重构，就像是扫去窗上的灰尘，能够让我们看到窗外的风景。  捡垃圾式重构 可以把要重构的点记下来，把更紧急的事情处理之后，抽空来处理这些垃圾。积少成多</description>
    </item>
    
  </channel>
</rss>
