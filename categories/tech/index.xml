<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on lllovol</title>
    <link>https://lllovol.com/categories/tech/</link>
    <description>Recent content in Tech on lllovol</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Dec 2021 14:12:16 +0000</lastBuildDate><atom:link href="https://lllovol.com/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>常用命令行统计指令</title>
      <link>https://lllovol.com/p/2021/12/awk-tool-analysis/</link>
      <pubDate>Tue, 21 Dec 2021 14:12:16 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2021/12/awk-tool-analysis/</guid>
      <description>背景 使用awk快速统计查看自己的常用命令
指令 history --i | awk &#39;{print $4}&#39; | sort | uniq -c | sort -k1,1nr | head -20解析  history -i 查看所有的历史记录 awk &#39;{print $4}&#39; 使用awk分词整理，取到每一行的第四个参数，也就是我们常用的命令 sort 排序 uniq -c 去重计数 sort -k1,1nr 排序 head -20 取前20  效果  ~ &amp;gt; history --i | awk &#39;{print $4}&#39; | sort | uniq -c | sort -k1,1nr | head -204570 git578 rake174 ****test132 ls122 cd118 go80 testcover61 ssh***52 vim35 source28 kinit27 goimports22 gofumpt20 sudo17 brew17 open16 echo15 ssh</description>
    </item>
    
    <item>
      <title>设计模式-Prototype原型模式</title>
      <link>https://lllovol.com/p/2021/9/prototype/</link>
      <pubDate>Thu, 23 Sep 2021 15:21:54 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2021/9/prototype/</guid>
      <description>场景 有一个object，想要生成与之完全相同的复制品，该如何是实现？ 问题：
 私有数据 不想包含具体的包 如果原始的对象只是一个接口，具体类都不知道，怎么处理呢？  方案 将克隆过程，委派给被克隆的实际对象，由实际对象负责clone 因此，只要实现了clone()方法的，就是原型模式
实现  原型（Prototype）接口对clone方法做一个申明，绝大部分情况下，里面只有一个名为clone的方法 具体原型（ConcretePrototype）类实现接口 客户端（Client）可以复制实现了原型接口的任何对象  应用  将自身作为构造函数的参数传入 复制数组
  如果需要复制一些对象，同时又希望代码独立于这些对象所属的具体类 如果子类的区别仅在于对象的初始化方式，那么可以使用该模式减少子类的数量，别人创建这些子类的目的可能只是为了创建特定的对象。  优点  克隆时 无需与所属的具体类耦合 克隆原型 防止反复运行初始化 更方便的生成复杂对象 可以用继承以外的方式来处理复杂对象的不同配置  缺点  克隆博涵循环引用的复杂对象可能会非常麻烦  </description>
    </item>
    
    <item>
      <title>设计模式-Factory工厂模式学习笔记</title>
      <link>https://lllovol.com/p/2021/9/design-pattern-factory/</link>
      <pubDate>Thu, 09 Sep 2021 15:31:14 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2021/9/design-pattern-factory/</guid>
      <description>工厂模式 有点忙，先看看吧</description>
    </item>
    
    <item>
      <title>设计模式-Singleton单例模式学习笔记</title>
      <link>https://lllovol.com/p/2021/9/design-pattern-singleton/</link>
      <pubDate>Thu, 02 Sep 2021 15:50:47 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2021/9/design-pattern-singleton/</guid>
      <description>概要 保证一个类只有一个实例，保证一个进程中，某个类有且仅有一个实例
方案：  构造函数私有化 新建静态构造方法作为构造函数  饿汉式 类加载的时候，就实例化。
懒汉式 第一次使用的时候，再实例化。节省资源，但是需要注意线程安全问题
总结 优点  只有一个实例，避免了重复的内存开销 避免对资源的重复占用  缺点 可以理解为一个全局变量，没有接口，不能继承。违背了SRP职责</description>
    </item>
    
    <item>
      <title>Go Slice切割边界问题</title>
      <link>https://lllovol.com/p/2021/8/go-slice/</link>
      <pubDate>Tue, 31 Aug 2021 21:41:05 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2021/8/go-slice/</guid>
      <description>问题 如下代码
func Test(t *testing.T) { PatchConvey(&amp;#34;test&amp;#34;, t, func () { //your mock code... PatchConvey(&amp;#34;test case1&amp;#34;, func () { var s []int s = append(s, 1, 2, 3) a := s[len(s):] b := s[len(s)] c := s[len(s)+1:] println(a) println(b) println(c) }) }) } 有几个问题：
 a不会报错 b会panic c会panic  原因  b的[len(s)]肯定越界 [:]切割Slice的方式是左闭右开的，  冒号左边如果为空, 默认是0 冒号右边如果为空, 默认是字符串len(s)   a中冒号左边的是len(s), 没有超过右边默认的len(s), 所以不会panic, 这样切出来的就是一个空的slice c中的冒号左边len(s)+1, 超过了右边默认的len(s), 所以会panic  其他知识  如果slice有扩容操作, 那么就会使用新的内存; 如果没有扩容操作, 使用旧的内存 append扩容的时候, slice的cap值会随着go的版本不同而略有不同（1.</description>
    </item>
    
    <item>
      <title>Google SRE解密笔记(一)</title>
      <link>https://lllovol.com/p/2021/8/google-sre/</link>
      <pubDate>Tue, 24 Aug 2021 21:55:29 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2021/8/google-sre/</guid>
      <description>拥抱风险 百分百可靠的服务，是不现实也是没有必要的。 可靠性到达一定值之后，会带来成本的大幅度提升：过分要求稳定性会限制新产品的开发速度和交付速度。
用于对于高可靠性和极端可靠性的感知几乎是没有的。
基于这一点，SRE追求快速创新和高效的服务运营业务之间的风险的平衡，而不是简单的将服务在线时间最大化。
平衡系统的功能、服务和性能
管理风险 </description>
    </item>
    
    <item>
      <title>设计模式-Strategy策略模式学习笔记</title>
      <link>https://lllovol.com/p/2021/8/strategy/</link>
      <pubDate>Sun, 15 Aug 2021 02:12:03 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2021/8/strategy/</guid>
      <description>前言 为什么我们需要设计模式呢？我们日常的设计应该对手头的问题有针对性，同时对将来的问题也要有足够的通用性，同时我们也需要避免重复设计或者尽可能的减少重复设计。但是想以一下子就得到复用性和灵活性好的设计，其实是相当困难的。 而设计模式，就是将对面向对象软件的设计经验作为设计模式记录下来。
设计模式的四个基本要素  模式名称 一个助记的名称 问题 描述了应该在什么时候使用设计模式 解决方案 描述了设计的组成成分，它们之间的相互关系和各自的职责和协作方式 效果 描述了模式应用的效果以及使用模式应该权衡的问题  设计模式的三大分类 我们主要通过两个准则对各种设计模式进行分类：
 目的准则 这个模式是用来完成什么工作的 范围准则 这个模式用于类还是用于对象的 设计模式分类  面向对象的六大原则  单一功能原则 一个类只做一件事情 开闭原则 一个软件实体类，模块和函数应该对扩展开放，对修改关闭 里氏替换原则 子类可以扩展父类的功能，但不能改变父类原有的功能 依赖倒置原则 抽象不应该依赖细节，细节应该依赖于抽象，换一句话说，就是要针对接口编程，不要对实现编程 接口分离原则 系统解开耦合，从而容易重构，更改和重新部署 迪米特原则 一个类应该对自己需要耦合或者调用的类知道得最少，这有点类似于接口隔离原则中的最小接口的概念  Strategy 策略模式 意图 定义一系列的算法，把他们一个个封装起来，并且使他们可以互相替换。同时本模式可以使得算法可以独立于使用它的客户变化而变化
别名 Policy 政策模式
动机 当我们需要对一个正文流进行处理，需要使用许多不同的算法。这个时候，将这些算法那硬编码进使用它们的类当中是不可取的，原因如下：
 客户程序异常庞大同时难以维护 不同的时候需要不同的算法，我们不想支持我们并不使用的算法 当其中某些算法是客户程序难以分割的算法的时候，增加新的算法或者改变现有的算法将十分困难  适用性  许多相关的类只是行为有不同 可以使用多个行为中的一个行为来配置一个类 需要使用一个算法的不同变体 可能会定义一些反映了不同时间、空间等因素权衡的算法，将这些变体实现为类层次 算法使用了客户不应该知道的数据 避免暴露负责的、与算法相关的数据结构 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类当中来代替这些条件语句  结构 图
参与者  Strategy  定义所有支持的算法的公共接口。Context使用这个接口来调用某个ConcreteStrategy定义的算法   ConcreteStrategy  以Strategy为策略是实现某具体的算法   Context  用一个ConcreteStrategy对象来配置 维护一个对Strategy对象的引用 可定义一个接口来让Strategy访问它的数据    协作  Strategy和Context相互作用以实现选定的算法  Context将算法所需要的数据传递给Strategy Context也可以将自身作为一个参数传递给Strategy，Strategy就可以在需要的时候回调Context   Context将客户的请求转发给它的Strategy。通常创建并传递一个ConcreteStrategy对象给Context。客户只需要和Context交互。  效果 优点  相关算法系列 Strategy类层次为Context定义了一系列可供重用的算法或者行为。有助于析取出这些算法的公共功能 一个替代继承的方法 可以使用继承生成Context的子类，给予它们不同的行为，但是这就会将行为硬编码到Context当中，将算法的实现和Context的实现混淆，使得Context难以理解、难以维护、难以扩展，还不能动态改变算法。将算法封装在独立的Strategy类中，使得我们可以独立于Context改变它，易于切换、易于理解、易于扩展 消除了一些条件语句 将不同行为堆砌在一个类当中的时候，很难避免使用条件语句来选择合适的行为。将行为封装成一个个独立的Strategy类中可以消除这些条件语句（含有许多条件语句的代码通常意味着需要使用策略模式） 实现的选择 可以为相同行为提供不同的实现，可以根据不同的时间、空间权衡取舍要求从不同的策略中进行选择  缺点  客户必须要了解不同的Strategy 本模式一个潜在的缺点，客户选择一个Strategy必须要知道这些Strategy有何不同，此时可能不得不向客户暴露实现。因此只有不同行为变体与客户相关的行为时，才需要使用Strategy Strategy和Context的通信开销 无论具体的ConcreteStrategy是简单还是负责，都共享Strategy定义的接口。因此很可能某一些简单的ConcreteStrategy可能不会使用所有通过这个接口传递给他们的信息。 增加了对象的数目 Strategy增加了一个应用中对象的数目。有时候可以将Strategy实现为可供各个Context共享的无状态对象来减少这一个开销。其余任何状态都由Context来维护  实现  定义Strategy接口和Context接口 必须传递所有实现需要的数据，也可以将Context自身作为参数进行传递 将Strategy作为模板参数 （Go里没有，这就不展开了） 让Strategy对象成为可选的 访问前先判断是否存在，如果存在，就使用它；如果没有，就执行缺省的行为  代码示例  回调事件处理  相关模式 Flyweight（享元模式）： Strategy对象通常是很好的轻量级对象</description>
    </item>
    
    <item>
      <title>从Jekyll迁移至Hugo</title>
      <link>https://lllovol.com/p/2021/5/rake-file-usage/</link>
      <pubDate>Thu, 27 May 2021 19:52:17 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2021/5/rake-file-usage/</guid>
      <description>最近将博客背后的静态引擎，从Jekyll框架切换为了Hugo。也折腾了不少时间，现在总结一下其中的过程吧
准备  Go语言的环境 Go官网 Hugo的安装 Hugo官网 选择一个喜欢的hugo主题进行搭建, Hugo官网主题（本博客使用的主题是hugo-theme-stack）  主题个性化配置 hugo创建的基本流程网络上很多，这里就不过多赘述，一般选择了相应主题后，相关的主题介绍页，都会介绍如何使用，按照主题页指引即可。
这里想主要讲一下主题的适配，hugo的主题样式主要是由layouts这个文件夹下的样式作为模板，themes下所使用的模板中的layouts也会生效，因此我们可以利用这个特性，在站点项目下面的layouts重写同名的布局文件。 （本博客的gitalk就是利用了这一特性对主题进行了个性化配置）。
撰写文章 不同的hugo主题可能会有不同的文章存放策略，但是一定都是放在contents目录下，本文是放在contents/post目录下
markdown文件的头格式如下
---title: 从Jekyll迁移至Hugoauthor: ymkNKcategories: [Tech]tags: [Ruby,Tech,Hugo]date: 2021-05-27 19:52:17 +0800img: https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/post/26.jpegslug: 2021/5/rake-file-usage--- 用---和+++包围都可以，只是内容的格式要求有所区别，前者使用yaml的格式，后者使用toml的格式
Rakefile 可以使用hugo new 快速创建文章，但是如果像我这样有定制化需求的创建（比如本博客的文章图片，以及目录格式等等），就需要手动进行处理，因此我使用了rakefile来通过简单的命令快速创建生成文章以及Tag
rake new 快速创建文章，并且可以随机生成oss图片库中的随机一个图片链接作为封面，按照创建的时间，自动放在content/post/#{@year}/#{@month}的目录下，方便归档（后期有考虑同时快速创建tags与categories）
rake git 快速执行git，一键提交本次更改的内容
rake hugo 快速构建生成hugo的静态网页，public文件夹下就是站点项目，本博客托管在github，因此可以直接push到仓库，进行直接发布
源代码 task :default =&amp;gt; :new require &amp;#39;fileutils&amp;#39; desc &amp;#34;创建新 post&amp;#34; task :new do time = Time.new puts &amp;#34;请输入要创建的 文件名字：&amp;#34; @name = STDIN.</description>
    </item>
    
    <item>
      <title>Redis中的常用数据结构</title>
      <link>https://lllovol.com/p/redis/</link>
      <pubDate>Mon, 19 Aug 2019 19:15:50 +0000</pubDate>
      
      <guid>https://lllovol.com/p/redis/</guid>
      <description>前言 Redis在曾经实现用户登录token的时候使用过，但是对其的了解程度，就只是在使用的这个层次。本篇文章主要用于学习记录Redis的常见的一些数据结构。
第一部分 什么是redis？  是NoSql数据库，非关系型数据库。 是个非关系型数据库。 Key-Value数据库 使用C语言实现的单线程应用，基于内存，读取的速度都超快！ 基于内存存放,使用了rdb （就是redis内存的SNAPSHOT，存到了磁盘当中）和Aof(Append only file 也就是平时操作的命令集合)的机制来保障数据的持久化，宕机的时候可以通过这两种方式来进行数据恢复。 拥有丰富的Value对象，String\Hash\List\Set\ZSet\Stream 拥有多种底层数据结构：SDS，list，dict，zskiplist，intset，ziplist，quicklist，zipmap，stream 支持丰富功能，过期，事物  第二部分 常用Value对象 1 String对象 最常见的类型
1.1 编码 int，可以自增 embstr，就是单纯的字符串 raw
1.2 扩容长度 字符串在小于1M的时候，是加倍扩张的策略 在超过1M的时候，每次扩容会增加1M的空间，每个key最大512M
2 List 相当于java中的linkedList 插入和删除非常快，时间复杂度是O(1)
2.1 编码 redis3.2之后列表的内部实现变成了quickList而非传统的ziplist或者双向链表实现。使用的是quicklist和ziplist组成的双向链表。 ziplist的分配过长和过小都不好，过小了会太多碎片化，过大了之后空间复杂度就会更大。
 list-max-ziplist-size-2可以用来设置size. list-compress-depth 0：表示数据都不被压缩，为n的话，就是两端的n个数据不被压缩,双向链表
 2.2 常用场景 消息队列
3 Hash 3.1 编码 zipList 默认，所有的key value，长度都小于64，保存的键值对数量都小于512 ht（hashTable），超过了就用ht
4 Set和ZSet Set无序和唯一的 ZSet是可排序的，是对每一个元素添加了一个分数一样的东西
4.1 编码 Set 小512用intset，大于用hashtable ZSet 小64数量小128 用ziplist 否则用skiplist
4.2 场景 跟踪唯一性数据，比如说排行榜</description>
    </item>
    
    <item>
      <title>Idea代码飘红的问题解决方式</title>
      <link>https://lllovol.com/p/ide-code-error-solution/</link>
      <pubDate>Wed, 07 Aug 2019 10:08:30 +0000</pubDate>
      
      <guid>https://lllovol.com/p/ide-code-error-solution/</guid>
      <description>前言 在安装使用Idea Intelli的时候，导入新项目的时候，总会出现代码权限飘红的问题。本篇文章，就是介绍出现这种问题的几种情况和分别的解决方式。 导入项目代码全线飘红
情况一：maven二方库settings没有设置 一般公司内部都会有自己的二方库建设，新人在git下项目之后，总是会出现代码偏红的问题，各种库都没有导入下来，这时候首先应该排查的就是maven的配置是否正确，是否正确连接到了公司内部的二方库。
解决方式 以Idea Intelli为例: preference -&amp;gt; build,execution,deployment -&amp;gt; build tools -&amp;gt; maven -&amp;gt; User settings file: 勾选上override，改写为二方库settings.xml文件的路径
设置maven settings
情况二：Lombok插件没有安装  Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</description>
    </item>
    
    <item>
      <title>使用Jenkins回调获取状态</title>
      <link>https://lllovol.com/p/jenkins-callback/</link>
      <pubDate>Fri, 26 Jul 2019 11:01:52 +0000</pubDate>
      
      <guid>https://lllovol.com/p/jenkins-callback/</guid>
      <description>前言 最近的工作需要使用Jenkins执行一个特定脚本，但是使用FeignClient调用Jenkins的执行接口后，并不能获取到脚本执行之后的结果（成功和失败），本文就将介绍这种问题的其中一种解决方式。
 Jenkins是开源CI&amp;amp;CD软件领导者，提供超过1000个插件来支持构建、部署、自动化，满足任何项目的需要。Jenkins官网
 关键点  通过调研后，Jenkins在完成构建后，可以添加一个构建后操作。这就可以通过这个构建后操作，将本次构建脚本执行的结果，通过这个构建后操作，传给另外一个job，然后通过这个job将执行的结果通过回调的方式，传给应用服务器。
整个流程  服务器端创建一条记录，获取到记录的id，与需要执行的job所需要的参数还有回调所需要用到的apiHost一同存入到map当中，转换为JSON格式，通过FeignClient调用Jenkins对应的脚本。   服务器端应用可能会部署在不同的环境下，连接不同的数据库，因此可以在application.yml中配置当前apiHost的值，通过ConfigServer可以更改为当前环境所对应的值。
  在Jenkins端进行对应的job执行。
  通过构建后操作的trigger parameterized build on other projects功能。 
  根据本次构建的成功与否，分别执行不同的构建后操作，传递给回调job对应的参数。  
  回调job将获取到的信息，通过一个shell脚本，通过curl传递给服务器端。
  echo &amp;quot;${ID}&amp;quot;echo &amp;quot;${API_HOST}&amp;quot;echo &amp;quot;${BUILD_NO}&amp;quot;echo &amp;quot;${RESULT}&amp;quot;curl &amp;quot;$API_HOST/api/xxx/xxx/xxx/hook&amp;quot; -X POST -d &amp;quot;Id=$ID&amp;amp;buildNo=$BUILD_NO&amp;amp;result=$RESULT&amp;quot; 服务器端拿到数据进行更新和处理。  结语 有时候只是想要一条小小的消息，却不知道要辗转多少次，才能到达该去的地方</description>
    </item>
    
    <item>
      <title>自定义Snippet提高效率</title>
      <link>https://lllovol.com/p/snippet/</link>
      <pubDate>Sun, 16 Jun 2019 22:16:35 +0000</pubDate>
      
      <guid>https://lllovol.com/p/snippet/</guid>
      <description>前言 在书写markdown文章的时候，往往需要向其中添加图片的链接，从截图到文件的处理，到链接的获取都会很麻烦。在寻找各种图床工具之后，发现其效果都不是很好（比如要收费开通多个云图床的上传权限），因此本文将介绍另外一种较为简便的处理方式。
设置Snippet snippet是短文的意思，在ide中常常是指可以通过一小串的命令生成一大段代码或者文字的方式。例如，在sublime中输入lorem+tab。就会生成一大段样例文字
lorem+tab==&amp;gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmodtempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodoconsequat. Duis aute irure dolor in reprehenderit in voluptate velit essecillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat nonproident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title>RocketMQ源码分享笔记</title>
      <link>https://lllovol.com/p/rocketmq/</link>
      <pubDate>Tue, 19 Mar 2019 10:54:01 +0000</pubDate>
      
      <guid>https://lllovol.com/p/rocketmq/</guid>
      <description>前言 RocketMQ，是一种延时队列，主要的应用场景，就是消费者可以延时消费消息，比如在双11的时候,一瞬间有太多请求全部打在服务器上，服务器就会瞬间瘫痪，本文主要就是记录前辈分享的Rocket源码的时候笔记和一些感悟
主要功能  负载均衡 消费模式 消费拉取 消费进度反馈 消费过滤 延迟队列  分享主要内容笔记 打字速度有限，只能记录下简单的一些片段供参考
 有一个架构，轮询，可用性高，一致性要求没那么高 消息的一个流程：生产者发了一个消息，到了breaker之后，到了commitlog。有一个G的大小，实际发送的大小，顺序写的，io性能会很好，会被放到消费者的queue里面 ，小了之后，总要发到某一个topic里面 发一个消息的话，需要新建一个主题，需要制定一个queue的数量，每一个queue就是一个负载均衡，表示当前这个queue，消费到什么位置了。集群消息，一人拿一个。被负载的queue，同一个topic下的消息都是不同的 消费者可以对同一个topic下面的某几个队列进行消费，多个不同的consumer 设置min是核心线程数，是固定的，但是她的队列是无限的，所以这个地方没有什么用 缓存超过10000个，会改变线程池的大小，会做对应的限制 msgListener就是传的一个回调 会有一个offsetStore会存，存到本地和远程 还有消息的消费逻辑，注册到客户端的，生成clientId 封装了一些拉取消息的api，通过路由信息 worker发出请求，然后又一个线程池，来进行序列化和相应，消费的话会再七环到对应consumer的线程池 有各种组件，然后讲讲启动之后，都做了哪些事情 基本上都是通过定时消息去驱动的，很少是通过事件去驱动的， 找nameserver,然后去找server的信息 更新consumer消费的一个队列offset 都不是实时的更新的，是每一个五秒钟才刷新一次的 广播消费的，消费的queue是全部，订阅，不是分发，每一个rebalance里面，都处理了一个queue，实现了一个拍照 如果没有存，就是首次消费，如果是last，就会从，rocket是经常清消息的，发消息，然后消费 消费，就是拉取消息，就是放一条消息，就可以进行拉取，会先做一些验证，然后做一些限流，只不过限流是做一些delay，顺序消息，需要设置一下是不是第一次，然后获取订阅信息，然后调用对应的pullapi，然后去发一条消息，拉倒请求之后，就会有callback，去封装一下，找到了消息了，然后有一个真正的消息处理类 处理的流程 如果全部消费成功了之后，就会找到maxOffset，如果没有的话，就会去更新最小的那一个，这就是整个的一个消费流程  自行延展 MQ是高并发系统的核心组件之一，能够提高业务效率和系统的稳定性，主流的MQ有Rocketmq、kafka、Rabbitmq
 Rocketmq原理&amp;amp;最佳实践 主要对比如下
对比
 </description>
    </item>
    
    <item>
      <title>进程间通信的方式</title>
      <link>https://lllovol.com/p/inter-process/</link>
      <pubDate>Tue, 05 Mar 2019 16:22:56 +0000</pubDate>
      
      <guid>https://lllovol.com/p/inter-process/</guid>
      <description>前言 IPC（Inter-Process Communication，进程间通信）
有时候我们需要在不同的程序之间，也就是不同的进程之间进行通讯，那么都有些什么方式呢？通过查阅相关资料，主要有信号、管道、消息队列、共享内存等等
 进程间通信的方式
 常见的通讯方式  套接字Socket：套接字是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 信号量：信号量是一种计数器，主要是用来控制多个进程对共享资源的访问，在锁机制中应用比较多，保证在一个进程对一个资源进行访问的时候，其他进程不能对其进行资源访问 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 共享内存：内存共享是最快的IPC方式（SharedMemory）。就是映射一段其他进程也能够进行访问的内存。这一段内存虽然是由一个进程进行创建，但是多个进程都能进行访问。通常和信号量配合使用，来实现进程之间的同步和通信。 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
以上的任何一点都可以单独拿出来做一篇文章，路漫漫其修远兮  文章中已经写得很好了：）站在了巨人的肩膀上</description>
    </item>
    
    <item>
      <title>Yaml和Java对象之间的相互转换</title>
      <link>https://lllovol.com/p/yamlbeans/</link>
      <pubDate>Fri, 22 Feb 2019 21:46:09 +0000</pubDate>
      
      <guid>https://lllovol.com/p/yamlbeans/</guid>
      <description>前言 最近需要做一个将java对象转换成yaml文件格式的工作，由于手动进行操作的话效率会很低下，因此再找有没有合适的包可以使用。最后找到的工具就是yamlBeans,本文主要是翻译整理yamlBeans中的一部分信息
 yamlBeans官网
yaml文档的学习
 添加依赖 将下列代码添加到pom文件当中
&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;com.esotericsoftware.yamlbeans&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;yamlbeans&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;1.12&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt; Yaml反序列化为常见数据结构 所谓的反序列化，就是将yaml格式的文件，转换为java的常见数据结构 主要使用的类是YamlReader，然后可以将yaml文档转换为HashMap，ArrayList,还有Strings类型。
yaml：
name: Nathan Sweetage: 28address: 4011 16th Ave Sphone numbers:- name: Homenumber: 206-555-5138- name: Worknumber: 425-555-2306 code:
YamlReader reader = new YamlReader(new FileReader(&amp;quot;contact.yml&amp;quot;));Object object = reader.read();System.out.println(object);Map map = (Map)object;System.out.println(map.get(&amp;quot;address&amp;quot;)); Yaml反序列化为POJO 将yaml文档反序列化为pojo(plain ordinary java object)
Yaml and java class:
name: Nathan Sweetage: 28public class Contact {public String name;public int age;} Code:</description>
    </item>
    
    <item>
      <title>关于吞吐量的一些小知识</title>
      <link>https://lllovol.com/p/qps/</link>
      <pubDate>Mon, 07 Jan 2019 15:23:02 +0000</pubDate>
      
      <guid>https://lllovol.com/p/qps/</guid>
      <description>RT 响应时间 response time相应时间
响应时间是提交请求和返回该请求的响应之间使用的时间。
主要包括：
 数据库查询的时间 将字符传到终端上面所花的时间 访问web页面所花的时间  对于没有并发的系统而言，响应时间是一个合理并且准确的性能指标。但是响应时间的绝对值并不能反应性能的高低，软件的性能高低实际取决于用户对于该响应时间的接受度。 这就像是恋爱中的感情一样，你回复消息的快慢并不能反应你有多么爱她，而是取决于她对于你的这些行为的接受程度。TPS 每秒事物处理量 Transaction Per Second 吞吐量的（Throughput），吞吐量是指系统在单位时间内处理请求的数量。
对于单应用系统而言，吞吐量和响应时间严格成反比。单应用使用响应时间来作为衡量的指标，但是对于并发系统而言，通常需要吞吐量作为性能指标。因为在一个并发系统下，当一个用户一个请求的时间为t,但是n个用户一同请求往往不是n*t（可能大，可能小，需要看具体的情况）。一个并发系统如果配置合理，相应时间应该不会随着用户的增多而线性增加。因此才将吞吐量作为并发系统的性能衡量指标。一般而言，对于不同用户规模和不同的用户模式的系统，如果系统的最大吞吐量大致相同的话，可以判断两个系统的数据处理能力基本相同。
并发用户数 并发用户数指的是系统最大可以承受的正常使用系统功能的用户数。这个指标比TPS更加笼统，但是也更加的直观。但是这是一个非常不准确的指标，比如一个直播的弹幕网站，用户可以登录，正常发送弹幕，但是如果都挤在了一个直播间，同一时间发送一大堆弹幕，这时候的服务器可能就会崩了。而且用户在线的时候，大部分时间都在阅读信息，只有小部分的再发送请求，这样的情况是很多的。这项指标很大情况下取决于用户的行为模式。
QPS 每秒查询数量 Query Per Second
 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）摘自cnblog
 </description>
    </item>
    
    <item>
      <title>安装atom的atom-beautify</title>
      <link>https://lllovol.com/p/%E5%AE%89%E8%A3%85atom%E7%9A%84atom-beautify/</link>
      <pubDate>Fri, 07 Dec 2018 17:03:25 +0000</pubDate>
      
      <guid>https://lllovol.com/p/%E5%AE%89%E8%A3%85atom%E7%9A%84atom-beautify/</guid>
      <description>前言 想给atom安装beautify的插件 使用apm install atom-beautify 和是用preference中的插件安装都失败了
Start 使用github 克隆到本地，然后安装
 cd ~/.atom/packagesgit clone https://github.com/Glavin001/atom-beautify.gitcd atom-beautifynpm install 59469635.png
Success 使用control + alt + b 组合键 即可</description>
    </item>
    
    <item>
      <title>使用Rakefile实现文章生成器</title>
      <link>https://lllovol.com/p/rake/</link>
      <pubDate>Wed, 05 Dec 2018 01:23:16 +0000</pubDate>
      
      <guid>https://lllovol.com/p/rake/</guid>
      <description>使用github.io来写blog 本就是件很棒的事情，但是每次在想写新的文章的时候，都需要重新复制title和开头的标签，如果能够自动化地完成这件事就好了（重复性的东西工作）
About Rakefile  Rake is a Make-like program implemented in Ruby. Tasks and dependencies are specified in standard Ruby syntax.
 摘自http://docs.seattlerb.org/rake/
安装Rake sudo gem install rake 即可
创建Rakefile 在项目的根目录下
touch Rakefilevim Rakefile 然后添加如下代码
task :default =&amp;gt; :newrequire &#39;fileutils&#39;desc &amp;quot;创建新 post&amp;quot;task :new doputs &amp;quot;请输入要创建的文章文件文件名字：&amp;quot;@url = STDIN.gets.chompputs &amp;quot;请输入文章的标题：&amp;quot;@name = STDIN.gets.chompputs &amp;quot;请输入文章的子标题：&amp;quot;@slug = STDIN.gets.chompputs &amp;quot;请输入文章的分类，以空格分隔：&amp;quot;@categories = STDIN.</description>
    </item>
    
  </channel>
</rss>
