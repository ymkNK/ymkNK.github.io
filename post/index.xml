<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on lllovol</title>
    <link>https://lllovol.com/post/</link>
    <description>Recent content in Posts on lllovol</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Jan 2021 14:46:13 +0000</lastBuildDate><atom:link href="https://lllovol.com/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基础架构：一条SQL更新语句是如何执行的？</title>
      <link>https://lllovol.com/how-a-sql-executes/</link>
      <pubDate>Wed, 27 Jan 2021 14:46:13 +0000</pubDate>
      
      <guid>https://lllovol.com/how-a-sql-executes/</guid>
      <description> 本文是学习笔记，来自极客时间
 mysql&amp;gt; select * from T where ID=10； 这么一条查询语句是如何执行的呢？
MySQL基础架构 Server层：
 连接器：管理连接，权限认证 分析器：词法语法分析 查询缓存：命中则直接返回结果 优化器：执行计划生成，索引选择 执行器：操作引擎，返回结果 Server层涵盖了MySQL的大多数的核心服务功能，以及所有的内置函数  </description>
    </item>
    
    <item>
      <title>从零开始的查询优化</title>
      <link>https://lllovol.com/query-test/</link>
      <pubDate>Fri, 30 Oct 2020 16:28:10 +0000</pubDate>
      
      <guid>https://lllovol.com/query-test/</guid>
      <description>背景 需要查询到一批部门以及子部门，最终拿到这些部门下的人员信息，我们能够进行的操作如下
 通过部门的目录前缀（前缀树）的方式，能够查询到所有子部门 能够通过部门查询到这个部门（不包含子部门）的所有人员 已经添加索引  方法一 思路 找到每一个需要排除的部门，以及每一个排除的部门的子部门，然后分别查出来需要排除的人,最后通过stream的flatMap进行聚合
return allDepartment.stream().flatMap(department -&amp;gt; { List&amp;lt;EmployeeDetail&amp;gt; allByDepartmentId = employeeRepo.findAllByDepartmentId(department.getDepartmentId()); return allByDepartmentId.stream(); }).collect(Collectors.toList());  耗费时间 30616ms
方法二 思路 找到每一个需要排除的部门，将部门聚合，分别查询
 List&amp;lt;Department&amp;gt; allDepartment = findAllChildDepartments(byId.get()); return employeeRepo.findAllByDepartmentIdIsIn(allDepartment.stream().map(Department::getDepartmentId).collect(Collectors.toList())); List&amp;lt;EmployeeDetail&amp;gt; excludeEmployees = excludeDepartments.stream().flatMap(department -&amp;gt; serviceV2.findAllEmployeesByDepartmentId(department.getDepartmentId(), 1).stream()).collect(Collectors.toList()); 耗费时间 20057ms
方法三 思路 将所有需要排除的部门聚合，统一查询
 @Override public List&amp;lt;EmployeeDetail&amp;gt; findAllEmployeesByDepartmentsId(Iterable&amp;lt;String&amp;gt; departmentIds) { return employeeRepo.findAllByDepartmentIdIsIn(departmentIds); }  List&amp;lt;Department&amp;gt; allExcludedDepartments = excludeDepartments.stream().flatMap(department -&amp;gt; serviceV2.findAllChildDepartments(department).stream()).collect(Collectors.toList()); List&amp;lt;EmployeeDetail&amp;gt; excludeEmployees = serviceV2.findAllEmployeesByDepartmentsId(allExcludedDepartments.stream().map(Department::getDepartmentId).collect(Collectors.toList())); 耗费时间 26058ms 时间耗费反而多了，因为对数据库的查询次数变多了</description>
    </item>
    
    <item>
      <title>JavaJPA使用Mongo中的坑</title>
      <link>https://lllovol.com/mongo-bad/</link>
      <pubDate>Wed, 28 Oct 2020 15:03:26 +0000</pubDate>
      
      <guid>https://lllovol.com/mongo-bad/</guid>
      <description>背景 由于业务需求将一些数据作为缓存存到Mongo库中，然后在优化这个缓存过程的时候，发现的一个坑。
主要逻辑 原来的逻辑  获取所有数据 删除库中所有数据 将新数据全部存入库中  初步优化后的逻辑  获取所有数据 获取缓存库中所有数据 将两组数据做一个差值比较，筛选出来需要新建的 需要更新的 需要删除 三组数据 新增的数据进行新增 需要更新的数据进行更新 需要删除的数据进行删除  优化效果 从15000ms优化到230ms，由于数据量很大，但是其实并没有每次所有数据都有更新
坑 看起来上面逻辑没有什么问题，但是在执行的时候，发现每一次更新数据的时候，实际在mongo数据库中并不是更新数据，而是从新新建了一条数据！这就导致同一条数据在更新之后出现了两次？？ 但是我明明已经将唯一的Id值作为主键了，为什么还是会被认为是新的呢？
Model public class Example { @Id String exampleId; String name; } 看起来没有什么问题，但是这个主键获取的实际值长度特别长。导致在存入mongo库的时候，每一条新数据，都会使用系统生成的ObjectId的BSON。
但是这个生成的id值并没有返回回来
这就导致，使用JPA的save操作的时候，每一次都会判断成新数据。
解决方式 查了很久，也看了JPA的部分源码，并没有设置主键长度的地方。最终解决方式，每一次更新的时候，将旧的数据清除，然后将更新的数据和新数据聚合，更新到数据库中去。</description>
    </item>
    
    <item>
      <title>Java的部分基础机制</title>
      <link>https://lllovol.com/java-basic/</link>
      <pubDate>Sun, 20 Sep 2020 18:44:18 +0000</pubDate>
      
      <guid>https://lllovol.com/java-basic/</guid>
      <description>Java内存管理  Java的内存管理机制
 1. JMM java的内存模型
1.1 主内存和工作内存 Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程有自己的工作内存（Working Memory），线程的工作内存中保存了该线程所使用到的变量的内存副本。 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量的传递都要通过主内存来完成（如下图 2-1所有）。
1.2 执行引擎 执行引擎，就是一个运算器，能够识别输入的指令，并根据输入的指令执行一套特定的逻辑。
1.3 主内存和工作内存的交互模型 Java 内存模型中定义了 8 种操作完成主内存与工作内存之间具体的交互协议，虚拟机实现时必须保证 每一种操作都是原子级、不可再分的。 这 8 种操作又可分为作用于主内存和作用于工作内存的操作。
1.3.1 作用于主内存的操作  lock 作用于主内存的变量，它把一个变量标识为一条线程独占的状态。 unlock 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程锁定。 read 作用于主内存的变量，它把一个变量的值从主内存传输到工作内存中，以便 laod 时使用。 write 作用于主内存的变量，它把 store 操作从工作内存中得到的变量值存入到主内存变量中。  1.3.2 作用于工作内存的操作  load 作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。 use 作用于工作内存的变量，它把一个工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用的变量的值的字节码执行时会执行这个操作。 assign 作用于工作内存的变量，它把一个执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个变量赋值的字节码执行时执行这个操作。 store 作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的 write 操作。  2. JVM是如何划分内存的 垃圾回收机制 对象类型 对象擦除 基本运行原理 </description>
    </item>
    
    <item>
      <title>为什么加了索引后查询会变快</title>
      <link>https://lllovol.com/why-index-faster/</link>
      <pubDate>Sun, 20 Sep 2020 18:28:53 +0000</pubDate>
      
      <guid>https://lllovol.com/why-index-faster/</guid>
      <description>参考  说说为什么用了索引之后，查询就会变快？
 个人理解  数据页和数据页之间，组成一个双向链表 每个数据页中的记录，是一个单向链表 每个数据页都根据内部的记录生成一个页目录（Page directory），如果是主键的话，可以在页目录中使用二分法快速定位 如果我们根据一个非主键、非索引列进行查询，那么需要遍历双向链表，找到所在的页；再遍历页内的单向链表；如果表内数据很大的话，这样的查询就会很慢  如果我们根据一个非主键、非索引列进行查询，那么需要遍历双向链表，找到所在的页；再遍历页内的单向链表；如果表内数据很大的话，这样的查询就会很慢。所以没有用索引的时候，需要遍历双向链表来定位对应的页，而有了索引，则可以通过一层层“目录”定位到对应的页上。
为什么 B+ Tree 索引会降低新增、修改、删除的速度 B+ Tree 是一颗平衡树，如果对这颗树新增、修改、删除的话，会破坏它的原有结构； 我们在做数据新增、修改、删除的时候，需要花额外的时间去维护索引； 正因为这些额外的开销，导致索引会降低新增、修改、删除的速度。</description>
    </item>
    
    <item>
      <title>什么是事务？</title>
      <link>https://lllovol.com/what-is-transaction/</link>
      <pubDate>Fri, 18 Sep 2020 17:27:51 +0000</pubDate>
      
      <guid>https://lllovol.com/what-is-transaction/</guid>
      <description>背景 从实习开始也算是工作了两年了，但是从来没有使用过事务，原因可能是由于一直用的是MongoDB，而不是mysql，但是事物这种
事务的定义 可以将事物简单理解为，将一系列的操作整合为一个操作，这些操作只能全部都成功或者全部都执行失败。
事物的四个特性ACID  原子性(Atomicity):操作这些整合的操作的时候，要当成一条操作来执行，要么全部执行，要么全部不执行，一旦其中一个操作执行失败，那么就需要将数据进行回滚，回到执行事务之前的状态。 一致性(Consistency):事务的执行是让数据从一个状态转换为另外一个状态，但是对于整个数据的完整性保持稳定（比如AB两个账户相互转账，原来的总数是20000元，无论操作多少次，总数都应该还是20000元） 隔离性(Isolation):事务的隔离性是指在并发环境中，并发的事务时相互隔离的，一个事务的执行不能不被其他事务干扰。不同的事务并发操作相同的数据时，每个事务都有各自完成的数据空间，即一个事务内部的操作及使用的数据对其他并发事务时隔离的，并发执行的各个事务之间不能相互干扰。 持久性(Durability):一旦事务提交，那么它对数据库中的对应数据的状态的变更就会永久保存到数据库中。&amp;ndash;即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束的状态  事务的好处与事务的实例  事务分析
 事务提供了一种机制，可用来将一系列数据库更改归入一个逻辑操作。更改数据库后，所做的更改可以作为一个单元进行提交或取消。事务可确保遵循原子性、一致性、隔离性和持续性（ACID）这几种属性，以使数据能够正确地提交到数据库中。 使用事务机制的好处非常明显，例如银行转账之类的交易操作中，事务有着重要的作用。事务的成功取决于事务单元帐户相互依赖的操作行为是否能全部执行成功，只要有一个操作行为失败，整个事务将失败。例如：客户A和客户B的银行账户金额都是10000元人民币，客户A需要把自己帐户中的5000元人民币转到客户B的账户上。这个过程看似简单，实际上涉及了一系列的数据库操作，可以简单地视为两步基本操作，即从客户A帐户的金额中扣除5000元人民币，以及将客户B帐户中金额添加5000元人民币。假设第1步数据库操作成功，而第二步失败的话，将导致整个操作失败，并且客户A帐户金额将被扣除5000元人民币。事务机制可以避免此类情况，以保证整个操作的完成，如果某步操作出错，之前所作的数据库操作将全部失效。</description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(十四）事件监听的使用</title>
      <link>https://lllovol.com/spring14/</link>
      <pubDate>Mon, 27 Jul 2020 15:51:33 +0000</pubDate>
      
      <guid>https://lllovol.com/spring14/</guid>
      <description>背景 最近在做同步先关的工作，为了提升同步任务的处理效率，减少频繁的mongo数据库查询，因此需要将一些数据统一查询出来，在内存中进行处理。
解决方式 在任务执行的之前，就需要将相关的数据查询出来，如何实现呢？使用一个@EventListener进行ApplicationReadyEvent时间的监听，就能在应用启动之后，进行相应的操作
@EventListener(classes = {ApplicationReadyEvent.class}) public void initialMap() { if (CollectionUtils.isEmpty(ridMobileMap)) { List&amp;lt;UserRecord&amp;gt; all = entranceUserRecordRepo.findAll(); ridMobileMap = all.stream().filter(userRecord -&amp;gt; StringUtils.isNotEmpty(userRecord.getMobileNo())).collect(Collectors.toMap(UserRecord::getRid, UserRecord::getMobileNo)); } } More Application spring application，一般就是spring boot项目中的 Application这个类
@SpringBootApplication @EnableConfigurationProperties @EnableAutoConfiguration(exclude = {DruidDataSourceAutoConfigure.class, DataSourceAutoConfiguration.class, RedisAutoConfiguration.class}) @EnableScheduling @EnableFeignClients(basePackages = {&amp;quot;&amp;quot;}) @EnableAspectJAutoProxy(proxyTargetClass = true) @EnableCircuitBreaker @EnableLdapRepositories public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Bean LdapTemplate getLdapTemplate(ContextSource contextSource) { LdapTemplate ldapTemplate = new LdapTemplate(contextSource); ldapTemplate.</description>
    </item>
    
    <item>
      <title>Java学习笔记（一）</title>
      <link>https://lllovol.com/java-note/</link>
      <pubDate>Sat, 04 Jul 2020 14:07:38 +0000</pubDate>
      
      <guid>https://lllovol.com/java-note/</guid>
      <description>1. volatile volatile是轻量级的同步机制
 保证可见性 不保证原子性 禁止指令重排  1.1 JMM内存模型之可见性 JMM（Java Memory Model） Java内存模型
 Java内存模型
 </description>
    </item>
    
    <item>
      <title>单例模式的实现方式</title>
      <link>https://lllovol.com/singleton-realization/</link>
      <pubDate>Sat, 04 Jul 2020 00:34:38 +0000</pubDate>
      
      <guid>https://lllovol.com/singleton-realization/</guid>
      <description>什么是单例模式？ 在整个程序运行过程中只会实现一次的对象，例如Runtime类。
需要满足的条件有以下几点：
 构造器私有化 自行创建，并且用静态变量保存 向外提供这种实例 为了强调这是单例模式，我们可以使用final修饰  常见形式 饿汉式 懒汉式就是直接就实例化了，在程序运行的时候，直接创建，不管是否需要这个对象.不存在线程安全问题
饿汉式-直接实例化饿汉式 public class Singleton(){ public static final INSTANCE=new Singleton(); private Singleton(){ // 构造器私有化 } } 饿汉式-枚举式 和上面的效果一模一样
public enum Singleton(){ INSTANCE, ; } 静态代码块饿汉式 这种情况和第一种效果也是一样的，但是如果需要配置的话，就需要使用这种方式了
public class Singleton(){ public static final INSTANCE; private String info; static { Properties pro=new Properties(); pro.load( Singleton.class.getClassLoader().getResourceAsStream(&amp;quot;src/下面的资源文件&amp;quot;)) INSTANCE=new Singleton(pro.getProperty(&amp;quot;info&amp;quot;)); } private Singleton(String info){ this.info=info; // 构造器私有化 } } 懒汉式 延迟创建，在需要的时候才创建对象
线程不安全的懒汉式 这种情况就是会有线程安全的问题
public class Singleton(){ private static final INSTANCE; private Singleton(){ // 构造器私有化 } public Singleton getInstance(){ if(null==INSTANCE){ INSTANCE=new Singleton(); } return INSTANCE; } } 线程安全的懒汉式 加上锁，保证多线程的时候，不会有问题</description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节（十三）使用AOP实现权限系统</title>
      <link>https://lllovol.com/spring13/</link>
      <pubDate>Tue, 12 May 2020 15:04:26 +0000</pubDate>
      
      <guid>https://lllovol.com/spring13/</guid>
      <description>背景 最近在做一个小工具的权限控制系统，由于是第一次做这方面的工作，而且对权限的控制会非常的详细，比如，需要细致到对每一个对象的控制。在前期有一些调研。
想法 我大概实现的思路和设计
 构建实体类，实现相应的数据存储化，用户可以设置相应的权限策略。权限设置，换一个说法就是主谓宾&amp;ndash;&amp;ldquo;谁&amp;rdquo; &amp;ldquo;能看/不能看&amp;rdquo; &amp;ldquo;什么东西&amp;rdquo;。将这个权限设置抽象为对象，并进行存储。 根据实体类解析用户保存的策略，使之生效。  说起来简单，做起来难。第一点设置权限，其实就是非常简单的单表查询维护。难点在于第二点，如何能让这个策略生效。按照我目前接触和掌握到的技术手段，主要的解决方式有下面几种：
 写一个intercepor，拦截器。但是这个方式，只能处理请求的控制器和方法，控制不了具体的参数。这一点比较适合用来做整体的系统权限拦截，拦截接口。拦截控制的粒度比较粗糙。 在每一个业务逻辑中，分别添加拦截的逻辑，即每一个返回对象的接口，都需要查询和判断权限表。优点：思路简单。缺点：可维护性差，写完第一次之后，再维护就是噩梦。 使用Aspect，可以自定义切入的点，甚至能细化到拦截什么包什么类的什么方法等等。Perfectly，就是他了。  除了上面的Interceptor和Aspect，还有filter。这三者实际上都是对Aop的具体实现，都可以实现权限检查，日志记录等等的功能。都是对业务逻辑的提取，不同的是，使用的范围 规范、和深度不同。
 Filter、Interceptor、Aop实现与区别
 实现 由于包含工作的涉密内容，真实实现的代码就不在此展示。而网上的Demo已经相当丰富。
 SpringBooot AOP的使用
 其中实现权限控制的最简单的demo就是如下的代码
@Aspect @Component @RequiredArgsConstructor @Slf4j public class AuthAspect { @Pointcut(&amp;quot;execution(public * com.company.group.auth.service.AuthService.list(..))&amp;quot;) public void pointCutForListObjective() { } /** * 对list的方法返回值进行拦截处理 */ @AfterReturning(pointcut = &amp;quot;pointCutForListObjective()&amp;quot;, returning = &amp;quot;okrResponses&amp;quot;) public void afterReturningListObjective(JoinPoint joinPoint, Object okrResponses) { // 这个地方就能够对返回值直接进行处理 } }  定义切点pointCut(),这个地方，就是定义一个我们需要切入的点，我们要进行拦截处理的地方。 对这个切点有很多处理的方式，实现真正的权限拦截控制逻辑  其他的点  对于用户的组织权限的控制，我们可以使用路径的方式来进行判断，类似于一个树，我们每一次，存储的时候，需要将用户所在的组织架构的路径进行存储。这样我们在进行权限判断的时候，就不想要每一次都从库中获取用户的组织架构信息了。 对于model的校验可以写注解来进行实现。这一点，以后会专门写一篇文章来进行分享 Npe问题可谓是开发过程中的一生之敌。在循环迭代过程中，不可以一遍迭代，一边删除list中的值。 使用JPA的时候可以使用 pageable 来直接进行分页，不用再写mongoTemplate这种CustomRepo   @Override public List&amp;lt;Department&amp;gt; listAuthDepartment(String departmentName) { if (Strings.</description>
    </item>
    
    <item>
      <title>Structure and Interpretation of Computer Programs 读书笔记 Chapter 1 构造过程抽象 1.1 程序设计的基本元素</title>
      <link>https://lllovol.com/sicp-chapter1.1/</link>
      <pubDate>Fri, 17 Jan 2020 11:13:47 +0000</pubDate>
      
      <guid>https://lllovol.com/sicp-chapter1.1/</guid>
      <description>第1章 构造抽象过程  这一张主要学习的是有关计算过程的知识。   定义：计算过程是存在于计算机的里的一类抽象事物，主要操作一些被称之为&amp;quot;数据&amp;quot;的抽象事物。（就像Java中的各种类中的方法）
   我们指挥这种过程的程序就像是巫师的巫术一样，使用一些诡秘而深奥的程序设计语言，通过符号表达式的形式精心编排而成，他们描述了我们希望相应的计算过程去完成的工作。
  但是幸运的是，我们学习程序的危险性远远小于巫术。但是我们也必须像麻瓜一样，必须去学习、理解、预期我们所使用的咒语（程序）所带来的效果。程序里即使有一个小错误（bug or glitch）,也可能带来无法预料的后果。 真实的程序设计则需要极度细心，需要经验和智慧。
  设计良好的计算系统就像设计良好的汽车或者核反应堆一样，具有某种模块化的设计，其中的各个部分都可以独立地构造、替换和排除错误。
  书中所使用的Lisp方言Scheme，并不是一门主流语言，但是有一个非常重要的特征：计算过程的Lisp描述（过程）本身可以作为Lisp的数据来表示和操作。而不是现在很多威力强大的程序设计技术，都依赖于填平在 &amp;ldquo;被动的&amp;quot;数据和&amp;quot;主动的&amp;quot;过程之间的传统划分。
  1.1 程序设计的基本元素 一个强有力的语言，不仅是一种指挥计算机执行任务的方式，它应该成为一种框架，是我们能够在其中组织自己有关计算过程的思想。 每一种强有力的语言都提供了三种机制：
 基本表达式形式：用于表示语言所关心的最简单的个体。 组合的方法：通过它们可以从比较简单的东西出发构造出复合的元素。 抽象的方法：通过它们可以为复合对象命名，并将它们当做单元去操作。  用白话来解释，数据就是我们希望去操作的东西，而过程就是有关操作这些数据的规则描述。这样，任何强有力的程序设计语言都必须能够表达表述基本的数据和基本过程，还需要提供对过程和数据进行组合和抽象的方法。
1.1.1 表达式  开始程序设计，最简单的方式就是打开计算机的终端，用键盘输入一个表达式，解释器的响应就是将它对这一个表达式的求值结果显示出来。 运算对象+运算符 ==&amp;gt;组合式 （组合式本身也可以作为运算对象参与其他组合式的运算（套娃递归）） 即使对于非常复杂的表达式 解释器也是按照同样的基本循环运作： 读入-&amp;gt;求值-&amp;gt;打印  1.1.2 命名和环境  程序设计中一个必不可少的方面，就是它需要提供一种通过名字去使用计算对象的方式。我们将名字标识符成为变量，它的值也就是它所对应的那个对象。 实际上，构造一个复杂的程序，也就是为了去一步步地创建出越来越复杂的计算性对象。（一个Lisp程序通常是由一大批相对简单的过程组成的） 我们可以将值和符号相关联，而后又能提取出这些纸，这意味着解释器必须维护这某种存储能力，以便保持有关 名字-值 对偶的轨迹。这种存储被称之为环境 （更加准确的说是全局环境，以后会看到，在一个计算过程中完全可能涉及到若干不同的环境（全局域和局部域，全局变量和局部变量））  1.1.3 组合式的求值 一个组合式的求值狐妖就是做两件事
 求值该组合式的各个子表达式 将作为最左子表达式的（运算符）的值那个过程应用于相应的实际参数，所谓的实际参数就是其他子表达式（运算对象）的值。   一般而言，我们将递归看做一种处理层次性结构的（像树这样的对象）极强有力的技术。 &amp;ldquo;值向上穿行&amp;quot;形式的求值形式是一类更一般的计算过程的例子，这种计算过程被称为树形积累。 (define x 3)这种定义的情况，这算是一种特殊形式，作用是将符号x关联一个3的值，这并不是一个组合式。每一种特殊形式都有自己的求值规则。  1.</description>
    </item>
    
    <item>
      <title>Structure and Interpretation of Computer Programs 读书笔记 前言</title>
      <link>https://lllovol.com/sicp/</link>
      <pubDate>Mon, 13 Jan 2020 15:22:58 +0000</pubDate>
      
      <guid>https://lllovol.com/sicp/</guid>
      <description>写在最前面 本文主要用来记录自己再工作之余阅读的这本书籍的读书笔记，在记录的同时，也会加入一些自己的一些思考与总结(括号中的内容)
书籍目录架构  构造过程抽象 构造数据抽象 模块化、对象和状态 元语言抽象 寄存机器里的计算  序言部分笔记  程序员必须同时追求具体部分的完美和继承的适宜性。 每一个计算机程序都是现实中或者精神中的某一个过程的模型，通过人的头脑孵化出来。 如果艺术解释了我们的梦想，那么计算机就是以程序的名义执行着他们。 计算机是一位一丝不苟的&amp;quot;工匠&amp;quot;：它的程序必须正确，我们希望的所有东西，都必须表述得准确到每一点细节。 掌握强有力的组织技术，将会提升我们构造大型重要程序的能力。 计算机必须遵守物理定律。如果它们要快速执行，几个纳秒做一次状态转换，那么就必须在很短的距离内传导电子。 计算机永远都不够大也不够快。硬件技术的每一次突破都带来了更大规模的程序设计事业（同时也会带来更大规模的机会，机会总是无处不在的，但是能发现并抓住机会的人却没有那么多） Lisp语言有着非常简单的语法和语义，程序的语法分析可以看做一种很简单的工作。这样，语法分析技术对于Lisp程序几乎就没有价值，语言处理器的构造不会成为大型Lisp系统发展的变化和阻碍。最后，正是这种语法和语义的极端简单性，给所有的Lisp程序员都带来了负担和自由。任何规模的Lisp程序，除了那种寥寥几行的程序外，都包含考虑周到的各种功能。 发明并调整，调整恰当后再去发明！  前言部分笔记  计算机语言并不仅仅是一种让计算机去执行操作的方式，更重要的是，它是一种表述有关方法学的思想的新颖的形式化媒介。因此，程序必须写的能够供人阅读，偶尔地去供计算机执行。 能够对程序设计的风格要素有一种很好的审美观。……知道在什么时候哪些地方不需要去读，哪些东西不需要去理解。应该很有把握地去修改一个程序，同时又能保持原来作者的精神和风格。 计算机革命是关于我们如何去思考，以及如何去表达自己所思考的  </description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节（十二）单元测试</title>
      <link>https://lllovol.com/spring12/</link>
      <pubDate>Fri, 10 Jan 2020 19:07:19 +0000</pubDate>
      
      <guid>https://lllovol.com/spring12/</guid>
      <description>前言 2020将近，已经很久没有更新blog，但是每天的工作笔记都还是有在记录，趁着马上就要过年，没有那么忙碌了，把自己19年Q4的工作中遇到的问题以及一些有用的方法整理一下~
测试的必要性 在程序员的日常工作中，实际上真正在编写代码的时间，在整个工作时间中所占的比例其实很小的一部分。在写代码之前我们需要撰写需求文档，以及充足的思考，画出uml图（虽然很多经验丰富的大佬都没有画，但是那是建立在经验相当丰富的基础之上的）；在写完代码之后，这个项目需要发布与部署到测试环境，这就是CI/CD所负责的部分了；再之后，我们就需要测试我们的项目，是否能够完成需求文档中的需求，实现了相应的功能。 如果没有进行充分完整的测试，直接上线，这个项目差不多就是穿着皇帝的新衣在大街上到处晃荡了。同样，在互联网高速发展的今天，测试也不再仅仅是人工进行测试，自动化测试的演进又再一次的提升了团队的生产效率。这和敏捷开发、持续集成、持续部署、DevOps是一脉相承的。
测试金字塔Test Pyramid  图来源于ThoughtWorks
 在上方的金字塔当中，越往金字塔尖尖方向的，集成的程度越高，测试所耗费的时间就越长，但是需要的测试数目并没有那么多；与之相反，越往金字塔底层方向的，集成的程度就越低，测试所消耗的时间也更快，但是所需要测试的数量就会更加的庞大。
 UI Tests 项目的ui界面测试，这一层面的测试比较适合在上线之后进行冒烟测试，能够知道项目的整个流程到底是不是有问题。但是通常由于集成的程度太高，不能很快的定位问题。 Service Tests 这一层，用来测试服务是否可用，比如API测试。 Unit Tests 在代码层面进行测试，通常可以针对某一个类，某一个方法进行测试，能够快速定位问题。这个层级的层级能够保证一个系统的每一个基石都能够按照预期的那样进行工作。单元测试的数量应该在测试组合中远远多于其他类型的测试。  Junit 三段式结构 我们通常采用三段式的结构来撰写单元测试
 构造部分。进行对象的构建、赋值等。 逻辑部分。运行方法逻辑对第一部分的数据对象进行运算。 断言部分。判断本次单元测试能否通过。  实例代码 要使用is（）方法首先需要导入hamcrest-library-1.3.jar和hamcrest-core-1.3.jar两个jar包
依赖配置：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.hamcrest&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;hamcrest-library&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 简单的UT代码实现
import static org.hamcrest.core.Is.is; import static org.junit.Assert.assertThat; @RunWith(SpringRunner.class) @SpringBootTest @Slf4j public class ApplicationTests { @Test @Ignore public void contextLoads() { } public Boolean compare(String A, String B) { return A.</description>
    </item>
    
    <item>
      <title>从零开始将项目部署到Kubernetes</title>
      <link>https://lllovol.com/minikube/</link>
      <pubDate>Mon, 02 Dec 2019 14:23:17 +0000</pubDate>
      
      <guid>https://lllovol.com/minikube/</guid>
      <description>一、前言 kubernetes作为一个容器的编排引擎，如今已经相当的火热，日常的工作中也有使用常用的kubernetes的相关的功能，例如滚动发布、扩容等等，但是这都是在公司现成的已经搭建好的kubernetes集群上实践的，因此，本篇文章就是自主探索在本地运行一个kubernetes集群，同时写一个自己的demo，运行到本地的kubernetes集群当中。
本文主要包含如下几个方面：
 国内条件下如何安装kubernetes（no vpn） 写一个Spring boot 的demo 使用Docker将demo打包成镜像 将demo部署到本地kubernetes集群当中  二、本地安装kubernetes 选择使用minikube 我们想要学习使用kubernetes，首先就是选择一个平台进行操作，比如阿里云、Azure、Google Kubernetes等等
这里我们选择的就是学习用的minikube
 kubernetes官方文档 minikube操作文档 minikube安装文档
 安装minikube 1.检查能否虚拟化 sysctl -a | grep -E --color &#39;machdep.cpu.features|VMX&#39; vmx被标注出来有颜色，说明就是ok的，这台电脑是支持virtualization的（一般都是支持的,但是我花了88白菜价在腾讯云上买的1年1核1g服务器是不支持的）
2.安装kubectl brew install kubernetes-cli 使用kubectl version能够查看到对应的kubectl版本
3.安装Hypervisor（virtual machine monitor） 这个主要就是安装虚拟机了，kvm或者virtualBox二选一
4.安装minikube 有两种方式,第一种方式就是如下的方式
curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \ &amp;amp;&amp;amp; chmod +x minikube 将minikube安装包下载下来，手动进行安装
sudo mkdir -p /usr/local/bin/ sudo install minikube /usr/local/bin/ 如果是mac用户，直接使用如下的命令就可以了
brew install minikube brew link minikube 5.启动minikube minikube start 就会开始根据本地的virtualBox来下载对应的驱动,中间应该会要求输入一次本机电脑的一次密码,然后会出现这样的错误： Error creating machine: Error in driver during machine creation: hyperkit crashed!</description>
    </item>
    
    <item>
      <title>Java11新特性的六个实验</title>
      <link>https://lllovol.com/java11/</link>
      <pubDate>Wed, 16 Oct 2019 18:41:31 +0000</pubDate>
      
      <guid>https://lllovol.com/java11/</guid>
      <description>前言 最近将java升级到了11，因此学习了一些java11的一些新特性
一.局部变量类型判断 代码：
 @Test public void testVar() { // 测试局部变量类型判断特性 var java11 = &amp;quot;test java11&amp;quot;; var test = 1; System.out.println(java11); System.out.println(test); } 输出：
二.String类的新方法 代码：
 @Test public void testString() { String blank = &amp;quot;&amp;quot;; String strip = &amp;quot; strip &amp;quot;; String lines = &amp;quot;\n\n&amp;quot; + &amp;quot;\n&amp;quot; + &amp;quot;\n&amp;quot;; // 判断字符串是否为空白 System.out.println(blank.isBlank()); // 去除首尾空格 System.out.println(strip.strip()); // 去除开头空格 System.out.println(strip.stripLeading()); // 去除结尾空格 System.out.println(strip.stripTrailing()); // 重复 System.out.println(strip.repeat(0)); System.out.println(strip.repeat(1)); System.out.println(strip.repeat(2)); System.out.println(strip.repeat(3)); // 统计行数 System.</description>
    </item>
    
    <item>
      <title>从零开始搭建AD信息同步的项目</title>
      <link>https://lllovol.com/synchronize-job/</link>
      <pubDate>Mon, 23 Sep 2019 17:12:49 +0000</pubDate>
      
      <guid>https://lllovol.com/synchronize-job/</guid>
      <description>一 前言 最近独自完成了一个同步信息的项目，主要工作内容是从第三方的服务端将信息同步到公司的二方AD域当中。本文主要记录本项目的主要实现过程。
二 项目设计 这是一个并不复杂的项目，因此项目主要涉及到两大部分：
 从第三方服务器端获取到信息数据 将信息数据进行处理，能够存入到公司的二方AD域当中  三 第三方数据获取 1.主要技术 本项目主要获取信息的方式，是通过FeignClient来获取的
2.主要实现 a.最单纯的feign方式实现 添加pom依赖 	&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;feign-okhttp&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;10.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;feign-jackson&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;10.1.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 定义接收返回值所用到的model对象 这个地方的model定义，需要仔细阅读第三方服务端的api文档，然后根据上面的具体信息来进行定义
eg:
@Data public class XxxApiResponse { private String code; private String message; private String timestamp; private String errcode; private String errmsg; private String detailMsg; } 这里的变量名没有按照驼峰的方式进行定义，是因为官方文档返回值当中的字段key值就是这样非驼峰的方式，我们需要保证名字的一致性。
定义Feign public interface XxxClient { @RequestLine(&amp;quot;GET /v3/xxx/details?param1={param1}&amp;quot;) XxxDetailsResponse getXxxDetails(@Param(&amp;quot;param1&amp;quot;) String param1); } 注意这种RequestLine的方式和GetMapping和PostMapping的方式有所区别
定义Feign的Factory public class XxxClientFactory { private final static String URL = &amp;quot;https://api.</description>
    </item>
    
    <item>
      <title>Redis中的常用数据结构</title>
      <link>https://lllovol.com/redis/</link>
      <pubDate>Mon, 19 Aug 2019 19:15:50 +0000</pubDate>
      
      <guid>https://lllovol.com/redis/</guid>
      <description>前言 Redis在曾经实现用户登录token的时候使用过，但是对其的了解程度，就只是在使用的这个层次。本篇文章主要用于学习记录Redis的常见的一些数据结构。
第一部分 什么是redis？  是NoSql数据库，非关系型数据库。 是个非关系型数据库。 Key-Value数据库 使用C语言实现的单线程应用，基于内存，读取的速度都超快！ 基于内存存放,使用了rdb （就是redis内存的SNAPSHOT，存到了磁盘当中）和Aof(Append only file 也就是平时操作的命令集合)的机制来保障数据的持久化，宕机的时候可以通过这两种方式来进行数据恢复。 拥有丰富的Value对象，String\Hash\List\Set\ZSet\Stream 拥有多种底层数据结构：SDS，list，dict，zskiplist，intset，ziplist，quicklist，zipmap，stream 支持丰富功能，过期，事物  第二部分 常用Value对象 1 String对象 最常见的类型
1.1 编码 int，可以自增 embstr，就是单纯的字符串 raw
1.2 扩容长度 字符串在小于1M的时候，是加倍扩张的策略 在超过1M的时候，每次扩容会增加1M的空间，每个key最大512M
2 List 相当于java中的linkedList 插入和删除非常快，时间复杂度是O(1)
2.1 编码 redis3.2之后列表的内部实现变成了quickList而非传统的ziplist或者双向链表实现。使用的是quicklist和ziplist组成的双向链表。 ziplist的分配过长和过小都不好，过小了会太多碎片化，过大了之后空间复杂度就会更大。
 list-max-ziplist-size-2可以用来设置size. list-compress-depth 0：表示数据都不被压缩，为n的话，就是两端的n个数据不被压缩,双向链表
 2.2 常用场景 消息队列
3 Hash 3.1 编码 zipList 默认，所有的key value，长度都小于64，保存的键值对数量都小于512 ht（hashTable），超过了就用ht
4 Set和ZSet Set无序和唯一的 ZSet是可排序的，是对每一个元素添加了一个分数一样的东西
4.1 编码 Set 小512用intset，大于用hashtable ZSet 小64数量小128 用ziplist 否则用skiplist
4.2 场景 跟踪唯一性数据，比如说排行榜</description>
    </item>
    
    <item>
      <title>大咖分享-如何提高自己的技术视野</title>
      <link>https://lllovol.com/improve-our-vision/</link>
      <pubDate>Thu, 08 Aug 2019 01:14:30 +0000</pubDate>
      
      <guid>https://lllovol.com/improve-our-vision/</guid>
      <description>前言 最近听了一场蔡黎博士关于如何提高我们技术视野的分享，收益良多，其实不仅仅是在技术方面，其实很多道理，在生活中都是有共通点的。分享的主要内容既然是关于如何提高我们的技术视野的，那么他是如何进行分享的呢？他主要将这次分享按照内容分为了三个方面：
 视野 技术 效益  第一部分 视野 用英文来讲，就是Vision，这决定了格局和潜力，也是指的一种远见。
那么怎样才能看的更远呢？  看得到多远的过去，就能看得到多远的未来。&amp;ndash;丘吉尔  例子一：如今阿里云计算排名第一 中国云计算市场现状：top1阿里云 超过了第2到第8名的总和。 但是如果看看10年前，国内的各个公司都在同一起跑线上，那时候的大佬们对于云计算，看法又都是怎样的呢？
 李彦宏，说云计算是新瓶装旧酒，没有什么新东西。 马化腾，云计算的理念，还为时过早，就算能够实现也是过一百年和一千年之后才能实现的事情了。 马云，可以生产更好的商品，卖给消费者。  可以看到，BAT作为那时候中国的互联网三大巨头，只有阿里的马云是看好云计算的，而从如今的结果来看，阿里巴巴当初选择将精力投入到云计算是绝对正确的选择。那么，为什么阿里巴巴当初为什么要投云计算？ 因为云计算其实是数据时代的公共基础设施，那么那时候的阿里，是通过什么样的方式发现这样的一个原因呢？10年前，能看到如今的未来嘛？答案是肯定的。
我们回顾一下第二次工业革命，电的出现之后，是如何发展的呢？
 最开始-分散发电模式到现在-集中发电模式我们可以看到，在电出现了之后，最开始，都是分散发电的模式，工厂都用着自己的发电机来进行发电，实现电量的自给自足。再看看现在，都是国家电网，集中发电的集中发电形式。
 通过类比的方式可以发现，其实和发电的形式是相当相似的
工业时代看用电量
信息时代看用云量
科技永远向前，历史总在重演
例子二：小米卖手机 雷军在做小米手机的初期，那时候他的演讲，就讲到过Android还有操作系统芯片等等部分模块，都将实现标准化。
 产品经理是怎样炼成的？新媒体电商
在那个时候的手机利润，是3倍来卖的，真的是个暴利行业，但是雷军觉得，手机不应该是3倍的毛利来卖，因此，小米手机一直都是每台手机只赚5%，一直卖到了现在世界五百强。 （看看pc，毛利才14%，那时候手机毛利3倍是多么的夸张，但是其实最开始的pc也没有几个人能买得起）第一个标准化，第二个是薄利多销，雷军他所看见的手机未来的发展趋势，其实就是pc行业发展的规律。
  第一波浪潮-pc第二波浪潮-手机 这就是个历史规律，科技的趋势是普惠的。
 一体化的用户体验，是远超组合的用户体验 标准化，差距会逐渐缩小 产业最终肯定分工化、规模化， 产业的演进是技术和商业模式的结合  例子三：为什么芯片要单独为手机再开发一次？ 为什么要在手机上芯片重新开发一遍？因为功耗更小
差了几倍呢？10倍
价格呢？便宜了10倍
10倍因素的新技术，某个指标产生这种变化的时候，那么可能就是革命要出现了  你必须保持敏感，否则当新技术作为10倍数因素席卷而来的时候，猝不及防只能轰然倒塌。同时，对新技术的追逐可能不在盈利，而在于可以使得企业在必要的时候迅速转向。毕竟，只有早早行动，才有希望争取未来的胜利，改变不利的命运&amp;ndash;英特尔公司前CEO安迪·葛洛夫  水滴公司CEO沈鹏，是美团的第十号员工，他在带领团队做美团外卖的时候，也是在13年的时候，看见了一个10倍因素的场景，外卖出现了一个爆发的机会。 是什么呢？最开始的外卖机制，都需要店家在店里装一台二手电脑，用于接收订单的信息，相当的不方便。但是那时候，安卓手机的人人普及，提升了沟通的效率，也提高了配送的稳定性。外卖就是这么做出来的，稳定性就此提升，从而改变了这个产业。（饿了嘛 那时候已经做了5年左右，那时候都是用二手电脑来做的外卖生意， 美团当时第一年的目标，就是从饿了么的5w一天，美团的目标是要做到20w一天，而那时候真正的结果，美团达成了120w一天，这个因素已经远远超过了10倍）
 很有可能在5年之后，这个10倍因素将会出现在电动车行业当中。看看如今电动车的体验，特斯拉差不多是一般电动车3倍的价格，但是它的体验，远远高于普通电动车所带来的3倍 分散发点模式，分久必合，合久必分。美国的solarcity公司，让每家每户，使用太阳能电池，各自发电，多余的电还可以输送到集中电网当中。 华为发布的鸿蒙系统其实，平头哥+鸿蒙，IoT（Internet of Things）是为了物联网而做出来的系统。  第二部分 技术 推荐一部书《技术的本质》W.</description>
    </item>
    
    <item>
      <title>Idea代码飘红的问题解决方式</title>
      <link>https://lllovol.com/ide-code-error-solution/</link>
      <pubDate>Wed, 07 Aug 2019 10:08:30 +0000</pubDate>
      
      <guid>https://lllovol.com/ide-code-error-solution/</guid>
      <description>前言 在安装使用Idea Intelli的时候，导入新项目的时候，总会出现代码权限飘红的问题。本篇文章，就是介绍出现这种问题的几种情况和分别的解决方式。 情况一：maven二方库settings没有设置 一般公司内部都会有自己的二方库建设，新人在git下项目之后，总是会出现代码偏红的问题，各种库都没有导入下来，这时候首先应该排查的就是maven的配置是否正确，是否正确连接到了公司内部的二方库。
解决方式 以Idea Intelli为例: preference -&amp;gt; build,execution,deployment -&amp;gt; build tools -&amp;gt; maven -&amp;gt; User settings file: 勾选上override，改写为二方库settings.xml文件的路径
情况二：Lombok插件没有安装  Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.lombok官网
 Lombok可以让我们的Java代码更加简洁，不用再去写那些Getter和Setter。然而这个强大的功能，在初次安装idea的时候，并不会内置的给我们安装Lombok插件，因此这个时候，同样也会出现大片代码报错的问题。
解决方式 安装Lombok的插件： ** preference -&amp;gt; Plugins -&amp;gt; Install lombok -&amp;gt; restart ** 问题三：注解未开启 在安装好了 Lombok之后，发现运行还是报错 解决方式  关闭项目。 Preference &amp;gt; Build, Execution, Deployment &amp;gt; Compiler &amp;gt; Annotation Processors.</description>
    </item>
    
    <item>
      <title>Scala环境搭建</title>
      <link>https://lllovol.com/scala1/</link>
      <pubDate>Fri, 02 Aug 2019 14:50:13 +0000</pubDate>
      
      <guid>https://lllovol.com/scala1/</guid>
      <description>前言 最近工作中需要参与一下scala的项目，借此机会学习一下这个心的语言。
环境搭建  Java环境 JDK1.5以上  ymk@localhost ~ $ java -version java version &amp;quot;1.8.0_181&amp;quot; Java(TM) SE Runtime Environment (build 1.8.0_181-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) 下载安装Scala
Scala官方下载地址
安装好了之后,可以通过scala查看是否安装成功  ymk@localhost ~ $ scala Welcome to Scala 2.12.7 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_181). Type in expressions for evaluation. Or try :help. 下载安装sbt
Mac: brew install sbt@1  使用命令行搭建第一个Scala项目 本节内容主要来自于官方文档
创建项目  cd 进入一个新的空的文件夹。 执行命令 sbt new scala/hello-world.</description>
    </item>
    
    <item>
      <title>使用Jenkins回调获取状态</title>
      <link>https://lllovol.com/jenkins-callback/</link>
      <pubDate>Fri, 26 Jul 2019 11:01:52 +0000</pubDate>
      
      <guid>https://lllovol.com/jenkins-callback/</guid>
      <description>前言 最近的工作需要使用Jenkins执行一个特定脚本，但是使用FeignClient调用Jenkins的执行接口后，并不能获取到脚本执行之后的结果（成功和失败），本文就将介绍这种问题的其中一种解决方式。
 Jenkins是开源CI&amp;amp;CD软件领导者，提供超过1000个插件来支持构建、部署、自动化，满足任何项目的需要。Jenkins官网
 关键点 通过调研后，Jenkins在完成构建后，可以添加一个构建后操作。这就可以通过这个构建后操作，将本次构建脚本执行的结果，通过这个构建后操作，传给另外一个job，然后通过这个job将执行的结果通过回调的方式，传给应用服务器。
整个流程  服务器端创建一条记录，获取到记录的id，与需要执行的job所需要的参数还有回调所需要用到的apiHost一同存入到map当中，转换为JSON格式，通过FeignClient调用Jenkins对应的脚本。   服务器端应用可能会部署在不同的环境下，连接不同的数据库，因此可以在application.yml中配置当前apiHost的值，通过ConfigServer可以更改为当前环境所对应的值。
  在Jenkins端进行对应的job执行。
  通过构建后操作的trigger parameterized build on other projects功能。   根据本次构建的成功与否，分别执行不同的构建后操作，传递给回调job对应的参数。   回调job将获取到的信息，通过一个shell脚本，通过curl传递给服务器端。
  echo &amp;quot;${ID}&amp;quot; echo &amp;quot;${API_HOST}&amp;quot; echo &amp;quot;${BUILD_NO}&amp;quot; echo &amp;quot;${RESULT}&amp;quot; curl &amp;quot;$API_HOST/api/xxx/xxx/xxx/hook&amp;quot; -X POST -d &amp;quot;Id=$ID&amp;amp;buildNo=$BUILD_NO&amp;amp;result=$RESULT&amp;quot; 服务器端拿到数据进行更新和处理。  结语 有时候只是想要一条小小的消息，却不知道要辗转多少次，才能到达该去的地方</description>
    </item>
    
    <item>
      <title>容器就是一个特殊的进程</title>
      <link>https://lllovol.com/container-is-a-special-process/</link>
      <pubDate>Fri, 19 Jul 2019 11:56:44 +0000</pubDate>
      
      <guid>https://lllovol.com/container-is-a-special-process/</guid>
      <description>前言 程序的静态表现就是程序，平常的安安静静的躺在硬盘上；但是一旦运行起来，他就变成了计算机里的数据和状态的总和，这就是它的动态表现。 而容器的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出了一个边界。
 Cgroups是用来约束的主要手段。 Namespace是用来修改视图的主要方法。  docker run实验 安装好docker，输入以下命令
docker run -it busybox /bin/sh 这个命令就是告诉docker：帮我启动一个容器
接下来我们可以使用ps指令，来看一看容器和宿主机中的进程信息。 宿主机里的内容： 容器里的内容 Namespace机制 上面的小实验，这就是Linux里的namespace机制实现的， 我们可以看到，我们容器里pid为1的/bin/sh进程，在宿主机中的pid为13193，这就是容器使用了namespace使用了障眼法，让容器里的视角，以为自己就是这个机器的1号员工（pid=1），可是实际上，他还是原来的100号进程。
namespace其实只是Linux在创建新的进程的时候的一个参数，在Linux系统中创建线程的系统调用是clone()
int pid=clone(main_function,stack_size,SIGCHLD,NULL); 这个系统调用，创建了一个新进程，并且返回一个pid。而我们在创建一个新进程的时候，可以指定CLONE_NEWPID 参数。
int pid=clone(main_function,stack_size,CLONE_NEWPID | SIGCHLD,NULL); 这个新创建的进程就将“看见”一个全新的进程空间，看见它自己在这个进程空间中，他自己的pid为1。这其实只是一个障眼法，在宿主机上，它的pid该是多少，还是多少。
Namespace种类 Namespace的种类很多，上文中提到的只是PID Namespace，除此之外，还有如下的Namespaces,这些namespaces用来实现对进程上下文的“障眼法操作”
 MOUNT Namespace， 用来隔离文件系统的挂载点，使得子进程拥有自己独立的挂载点信息。 UTS（UNIX Time-sharing System ）Namespace提供了主机名和域名的隔离,能够使得子进程有独立的主机名和域名(hostname),而不仅仅只是宿主机上的一个进程. IPC Namespace,使划分到不同ipc namespace的进程组通信上隔离，无法通过消息队列、共享内存、信号量方式通信，但没有对所述所有IPC通信方式隔离。 Network Namespace，是实现网络虚拟化的重要功能，它能创建多个隔离的网络空间，它们有独自的网络栈信息。不管是虚拟机还是容器，运行的时候仿佛自己就在独立的网络中。 User Namespace,是Linux3.8新增的一种namespace，用于隔离安全相关的资源，包括user IDs and group IDs，keys,和capabilities。同样一个用户的userID和groupID在不同的user namespace中可以不一样(与PID namespace类似)。换句话说，一个用户可以在一个user namespace中是普通用户，但在另一个user namespace中是超级用户。  通过Namespace这样的方式，容器就只能看见当前Namespace所限定的资源、文件、设备、状态、配置。而对于宿主机和其他不想关的程序，对这个容器（一个进程）来说，就“雨我无瓜了”
结语 这个原理，就是为什么容器要比虚拟机效能更高的原因，本文是读了张磊前辈的文章后的学习笔记。</description>
    </item>
    
    <item>
      <title>小鲸鱼的成长史</title>
      <link>https://lllovol.com/docker-history/</link>
      <pubDate>Tue, 16 Jul 2019 20:58:05 +0000</pubDate>
      
      <guid>https://lllovol.com/docker-history/</guid>
      <description>前言 了解一个未知的事物，最好的方式就是去了解这个事物的历史。现在容器化，微服务很火热，有必要去了解一下docker这个小鲸鱼背后的东西。
最热的服务器端技术 在如今，肯定可以不假思索的说，是容器，因为现在是2019年，如果是2013年，我们可不敢这么说.那时候最火热的是PaaS化。“应用托管”，那时候租了虚拟机之后，用脚本或者手动的在上面部署应用。这样部署应用就会有本地环境和云端环境不一致的问题，因此，那时候的公司，拼的就是，谁能更好的模拟云端的环境。而PaaS项目的出现，就是实现当时这个问题的最佳方案。
Cloud Foundry 当时最大的开源的PaaS项目。只需要一个命令
cf push &amp;quot;我的应用&amp;quot;
就可以将本地应用部署到云上。这就是实现了应用托管的功能。
“应用托管”如何是实现？  每一种主流的语言特定方式各自打包，上传（cf push的作用就等同于用户将应用的可执行文件和启动脚本打进了脚本当中，上传到了Cloud Foundry的云存储当中。） 在虚拟机创造各种沙盒隔离环境 Cloud Foundry调度合适的虚拟机下载压缩包 机器上的Agent下载压缩包启动运行  而这个沙盒隔离环境，其实就是现如今所说的“容器”。
Dot Cloud公司 在随着PaaS的历史长河的流动过程中，dot Cloud这个公司，弱小，可怜又无助，无人问津，差一点就在PaaS的潮流中被抛弃。这个时候，这个公司决定开源一个项目，就是Docker项目。 这个Docker呢，其实同样也是使用了Cgroups和Namespace的方式来创造了容器，和Cloud Foundry等其他的PaaS项目基本没有什么区别，没有什么黑科技，因此那些PaaS平台的大佬也就没有将Docker放在眼里。
风云变幻 然而，世事无常，短短几个月，Cloud Foundry等其他的PaaS社区，还没有来得及成为Docker的对手，就被Docker直接宣告“出局”。
原因 先看看Cloud Foundry的一件上传
 需要为每种语言、每种框架、甚至应用的每种版本单独维护一个打好的包。 打包过程没有章法 本地跑的好好的应用，需要修改和更改不少配置才能好好的在云端运行 表面一件发布，实际上一波三折、费劲心力  Docker成功，就是靠着Docker镜像，这个看起来无足轻重的一部分，但是却提供了一种非常方便的打包机制
 完整操作系统的文件和目录 完全不需要任何配置和修改  这样做了之后，就是docker能够成功的精髓，那就是实现了本地环境和云端环境的高度一致！
结语 生产力解放之后。PaaS自然就被淘汰，CaaS（Container as a Service）变成了一种新兴的趋势。DotCloud公司也改名为Docker公司。成为了基础设施领域近十年难得一见的技术明星。</description>
    </item>
    
    <item>
      <title>FeignClient的FallBack处理</title>
      <link>https://lllovol.com/fallback/</link>
      <pubDate>Thu, 11 Jul 2019 16:31:53 +0000</pubDate>
      
      <guid>https://lllovol.com/fallback/</guid>
      <description>前言 在使用FeignClient的时候，我们很难保证第三方的调用不会出问题，这个时候，可以写一个FallBack类，来对出错的时候进行处理，可以异常上报，也可以进行打点处理，可以不再单独地去做这些事情。
FeignClient的编写  添加maven依赖。  	&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.2.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;feign-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;9.7.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;feign-slf4j&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;9.7.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 新建一个接口，在上方添加FeignClient注解，在value中使用占位符的方式，对参数进行调用。  	@FeignClient(name = &amp;quot;gitApi&amp;quot;, url = &amp;quot;${api.server.gitlab.url}&amp;quot;,fallback = GitApiFeignFallBack.class) public interface GitApiFeign { @GetMapping(value = &amp;quot;/{namespace}/-/jobs/{jobId}/trace&amp;quot;) JSONObject getTrace( @PathVariable(&amp;quot;namespace&amp;quot;) String namespace, @PathVariable(&amp;quot;jobId&amp;quot;) Integer jobId, @RequestParam(&amp;quot;private_token&amp;quot;) String accessToken); } @Autowired 注解就能对FeignClient进行使用。  @Autowired GitApiFeign gitApiFeign; FeignClient的Fallback实现 在上方的代码中，可以看见注解中有fallback的选项，这个就是新建这个Client对应的fallback类来实现FeignClient。
在fallback类的实现代码大致如下，最简单的实现就是在fallBack类中重写一遍Client中的所有方法。
@Component @Slf4j public class GitApiFeignFallBack implements GitApiFeign { @Override public JSONObject getTrace(String namespace, Integer jobId, String accessToken) { log.</description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(十一)CR笔记、阿里巴巴代码规约</title>
      <link>https://lllovol.com/spring11/</link>
      <pubDate>Wed, 10 Jul 2019 23:36:52 +0000</pubDate>
      
      <guid>https://lllovol.com/spring11/</guid>
      <description>前言 最近正式入职，第一周的事情主要就是进行代码的Code Review,将自己曾经的实习时候写的代码看一看，清掉一部分过时的代码。同时也从前辈们的分享中学习到了不少的小细节。 以及看了阿里巴巴的开发规范规约，将一些比较重要的地方、原来没有注意到的地方记录一下。
测试用例   在写Junit的时候，可以写一个BaseTest,以后test直接继承这个类即可，就不用每次都新建一个类然后在上面重新写上好多注解了。
 @SpringBootTest(classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) @RunWith(SpringJUnit4ClassRunner.class) @Slf4j public class BaseTests { }    在写CRUD的测试用例的时候，一定要写成一个闭环，新加了测试用例，最后测试结束的时候一定要删除，防止在数据库中产生脏数据。
  阿里巴巴的规约阅读笔记  外部正在调用或者二方库依赖的接口（二方库就是公司内部各个服务之间相互依赖的库）不允许修改方法的签名，避免对接口调用方造成影响。 接口过时的时候必须加上**@Deprecated**注解。 Object的equals方法容易报NPE，应该使用常量或者确定有值的对象来使用equals方法。   正例:&amp;ldquo;test&amp;rdquo;.equals(object);
反例:object.equals(&amp;ldquo;test&amp;rdquo;);
 所有整型包装类对象之间值的比较，全部使用equals方法比较。   说明:对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产 生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数 据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。
 浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。 定义数据对象DO类时，属性类型要与数据库字段类型相匹配。   正例:数据库字段的 bigint 必须与类属性的 Long 类型相对应。
反例:某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来 越大，超过 Integer 的表示范围而溢出成为负数。</description>
    </item>
    
    <item>
      <title>自定义Snippet提高效率</title>
      <link>https://lllovol.com/snippet/</link>
      <pubDate>Sun, 16 Jun 2019 22:16:35 +0000</pubDate>
      
      <guid>https://lllovol.com/snippet/</guid>
      <description>前言 在书写markdown文章的时候，往往需要向其中添加图片的链接，从截图到文件的处理，到链接的获取都会很麻烦。在寻找各种图床工具之后，发现其效果都不是很好（比如要收费开通多个云图床的上传权限），因此本文将介绍另外一种较为简便的处理方式。
设置Snippet snippet是短文的意思，在ide中常常是指可以通过一小串的命令生成一大段代码或者文字的方式。例如，在sublime中输入lorem+tab。就会生成一大段样例文字
lorem+tab ==&amp;gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description>
    </item>
    
    <item>
      <title>Android开发笔记（一)</title>
      <link>https://lllovol.com/android-idea/</link>
      <pubDate>Sat, 08 Jun 2019 16:49:49 +0000</pubDate>
      
      <guid>https://lllovol.com/android-idea/</guid>
      <description>前言 最近在帮朋友优化一个安卓的应用，使用Android来实现的一个华容道的小游戏。 项目链接
Android Studio的开发项目文件结构图 主要显示的是src文件夹下的结构
 . ├── AndroidManifest.xml ├── java │ └── com │ └── example │ └── huarongdao │ ├── AboutActivity.java │ ├── Block.java │ ├── Dimension.java │ ├── Klotski.java │ ├── KlotskiMapParser.java │ ├── L.java │ ├── Level1Activity.java │ ├── Level2Activity.java │ ├── Level3Activity.java │ ├── Level4Activity.java │ ├── LevelActivity.java │ ├── MainActivity.java │ └── Screen.java └── res ├── drawable ├── drawable-v24 ├── layout ├── mipmap-anydpi-v26 ├── mipmap-hdpi ├── mipmap-mdpi ├── mipmap-xhdpi ├── mipmap-xxhdpi ├── mipmap-xxxhdpi ├── temp-mipmap └── values  AndroidManifest.</description>
    </item>
    
    <item>
      <title>随笔杂想</title>
      <link>https://lllovol.com/aboutsomething/</link>
      <pubDate>Mon, 13 May 2019 13:02:36 +0000</pubDate>
      
      <guid>https://lllovol.com/aboutsomething/</guid>
      <description>前言 从公司回到学校，不多不少刚好一个月了。这一个月，自己都做了些什么？完成了什么目标？结果怎么样？
学车 真的有点操之过急，四月之前报名的话，就不用刷学时。但是也为时不晚，仔细想一想，等到真正工作上班之后，哪里还会有这么多的时间来练车，工作上的事情也是一堆一堆的。
 科二，要慢，记准确每一个点。 科三，还没有学，但是一定要好好跟着教练练习。  心境 感觉自己最近总是很容易着急，今天在驾校和隔壁教练起了冲突。
仔细一想，完全没有必要。
我是去学车的，并不是去斗嘴的，他莫名其妙的侮辱我，不讲道理，我给他讲道理难道他就会听了吗？非然也。
以后遇到这种事情，一定要冷静。不置可否，将自己的本职工作做好，已属不易。
需要锻炼自己的身体， 冲动是魔鬼，心平气和，就像后来宋教练给我说的，要学会吃话。
多听，好好听完了别人说什么，抓住重点，再进行反问，不要让自己脑子一热，就做出一些让自己后悔的事情。 感觉今天的处世方式，真的很像蔡徐坤。仿佛不容别人质疑自己，容不得一点负面的评价，还要去发律师函，愚蠢。
别人教练再怎么说，都是长辈，然后和别人教练顶撞了过去，没有必要。 前辈始终是前辈。得罪了这个教练，就算他不负责我，他也始终是教练，得罪了他，对我来讲，能有什么好处？ 没有好处。
上善若水，大丈夫，能屈能伸。
对于别人的评价与看法 越来越不喜欢别人对自己的评价，是可爱，而希望是成熟。
但是这真的很傻，才发现，这种太在意别人评价的事情，才是真的不成熟。 别人能对我有所评价，至少别人是有在关心我（无论正负评价，都是关心，就像明星一样，黑粉也一样是粉丝）。 那些真正对你不理不睬的，才是真的可怕。 让所有人都满意，让所有人都对我有很高的评价，真的能做到吗？不能。
光是做好自己的事情，就已经很不容易了。
别人将我捧的高，我的实力也不会因为他的夸赞而突飞猛进；
别人将我贬的低，我的能力也不会因为他的觊觎而忽然消失。 做好自己
所有的事情 都取决于自己的 想法与做法 要做事、先做人 </description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(十）泛型、分布式锁</title>
      <link>https://lllovol.com/spring10/</link>
      <pubDate>Fri, 29 Mar 2019 17:19:15 +0000</pubDate>
      
      <guid>https://lllovol.com/spring10/</guid>
      <description>前言 本文主要记录最近工作中关于开发中的一些小技巧以及感悟
小细节 权重转换百分比的问题 在工作中需要将各个对象所对应的权重转换成百分比，并且要求最后转换出来的百分比，同一类型的相加必须为百分之百，解决思路主要如下
 将各个类型的对象都分别分类 算出各个类型的总权重 算出每个对象在自己类型下的所占百分比 判断每个类型下的对象百分比相加是否等于100 在List处理的时候，可以将List分割成当前类型，和非当前类型 其中需要注意的是，在算百分比的时候，*100应该写在分子  eg: //这样会一直为0，是错误的 //原因是运算符是从左往右计算 //前面除法算出来之后会直接去尾，不足1就是0，所以最后乘以100结果还是0 percent / totalWeight * 100 //这样是正确的 percent * 100 / totalWeight
code:
 private List&amp;lt;GreyDestination&amp;gt; getDestinationsPercent(List&amp;lt;GreyDestination&amp;gt; tempDestinations) { HashMap&amp;lt;String, Integer&amp;gt; serviceAndTotalWeight = new HashMap&amp;lt;&amp;gt;(); HashMap&amp;lt;String, Integer&amp;gt; serviceAndCount = new HashMap&amp;lt;&amp;gt;(); getServiceWeightAndCount(tempDestinations, serviceAndTotalWeight, serviceAndCount); List&amp;lt;GreyDestination&amp;gt; finalDestinations = tempDestinations.stream().map( destination -&amp;gt; { String service = destination.getService(); Integer count = serviceAndCount.get(service); if (count == 1) { destination.</description>
    </item>
    
    <item>
      <title>Shuffle</title>
      <link>https://lllovol.com/shuffle/</link>
      <pubDate>Thu, 28 Mar 2019 11:00:40 +0000</pubDate>
      
      <guid>https://lllovol.com/shuffle/</guid>
      <description>前言 排序问题实现过很多次了，但是如何保证随机的乱序呢？这就是洗牌问题了（Shuffle）
 洗牌算法FisherYates原理
 洗牌问题 Fisher-Yates shuffle算法 首先来看看Collection里面的方法 code：
 /** * Created by ymk on 2019/3/28. * 这个算法主要是用来实现洗牌算法的 */ public class FisherYates { public static void main(String[] args) { Integer[] raw = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}; List&amp;lt;Integer&amp;gt; pokers = Arrays.asList(raw); Joiner joiner= Joiner.on(&amp;quot;,&amp;quot;); System.out.println(joiner.join(pokers)); Collections.shuffle(pokers); System.out.println(joiner.join(pokers)); } }  输出：
 1,2,3,4,5,6,7,8,9,10,11,12,13 5,9,1,12,7,8,2,10,11,6,3,4,13  源码实现  public static void shuffle(List&amp;lt;?</description>
    </item>
    
    <item>
      <title>Dynamic Programming-钢条切割问题</title>
      <link>https://lllovol.com/dynamic-programming/</link>
      <pubDate>Wed, 27 Mar 2019 20:38:15 +0000</pubDate>
      
      <guid>https://lllovol.com/dynamic-programming/</guid>
      <description>前言 动态规划是算法中的一大类，是一个求解最优解的值的问题
 本文内容主要来自于 《算法导论第三版第四部分第15章 动态规划》
 四个基本步骤 我们通常需要四个步骤来设计一个动态规划算法：
 1.刻画一个最优解的结构特征 2.递归地定义最优解的值。 3.计算最优解的值，通常采用自定向上的算法 4.利用计算出的信息构造一个最优解  钢条切割问题 问题描述 给定一段长度为n的英寸的钢条，和一个价格表pi（i=1,2,&amp;hellip;,n）,求切割钢条的切割方案，是的销售收益rn最大。（如果长度为n英寸的钢条价格pn足够大，最优解可能就是完全不需要切割）
问题处理 长度为n英寸的钢条共有2^(n-1)种不同的切割方案，因为在距离钢条左端i（i=1,2,&amp;hellip;,n-1）英寸的地方，我们总是可以选择切割或者不切割。 这时候rn=max(pn,r1+r[n-1],r2+r[n-2],r[n-1]+r1)，相当于，我们将问题分割了，首先将钢条切割了，切割成了长度为i和n-i的两端，然后求解这两端的ri和r[n-i]
这样，我们就能通过组合两个相关子问题的最优解，并在所有可能的两端切割方案中选取组合收益的最大者，构成原问题的最优解。 这样，我们称钢条切割问题满足最优子结构（optimal substructure）的性质：问题的最优解由相关问题的最优解组合而成，而这些子问题可以独立求解。
除此之外，我们可以将钢条从左边切割下长度为i的一段，然后只对右边剩下的长度为n-i的一段继续进行切割（递归求解），对左边的一段则不再进行切割，
而不做任何切割的方案，可以描述为：第一段的长度为n，收益为pn，剩余部分的长度为0，对应的收益为r0=0。
伪代码实现（自顶向下的方法）  CUT-ROD（p,n) 1	if n == 0 2	return 0; 3 q = min_num 4 for i = 1 to n 5 q=max(q,p[i]+CUT-ROD(p,n-i)) 6 return q  CUT-ROD优化 上方的方法，在n变大的时候，程序运行时间会变得特别特别慢，原因是，它会反复的使用相同的参数值，对自身进行递归调用，等价于他在反复求解相同的子问题。如果将上面函数的递归调用树画出来，将会有2^(n-1)个叶节点。全部展开，必将成为一个指数级增长的趋势。上面的朴素递归算法，效率低，就是这个问题，反复求解了相同的子问题。
因此，动态规划要求仔细安排求解的顺序，对每个子问题，之求解一次，并将结果保存下来。因此，对于每个子问题的解，咱们只求一次，并且将结果保存下来，之后再遇到相同的子问题，就可以直接求出解，因此，动态规划方法，就是付出了额外的内存空间，来节省计算时间，这就是典型的时空权衡的例子。下面是两个优化算法的伪代码
带备忘的自顶向下法（top-down with memoization） 过程会保存每个子问题的解，通常保存在一个数组或者散列表当中。当需要一个子问题的解的时候，首先检查一下是否已经保存过此解。
 MEMOIZED-CUT-ROD(p,n) 1 let r[0..n]be a new array 2 for i = 0 to n 3 r[i] = min_num 4 return MEMOIZED-CUT-ROD-AUX(p,n,r); MEMOIZED-CUT-ROD-AUX(p,n,r) 1 if r[n]&amp;gt;=0 2 return r[n] 3 if n == 0 4 q = 0 5 else q = min_num 6	for i = 1 to n 7 q=max(q,p[i]+MEMOIZED-CUT-ROD-AUX(p,n-i,r)) 8 r[n]=q 9 return q  自底向上的方法  BOTTOM-UP-CUT-ROD(p,n) 1 let r[0.</description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(九）Guava库</title>
      <link>https://lllovol.com/spring9/</link>
      <pubDate>Sun, 24 Mar 2019 17:23:42 +0000</pubDate>
      
      <guid>https://lllovol.com/spring9/</guid>
      <description>前言 本文主要记录最近工作中关于开发中的一些小技巧以及感悟
小细节 String转Long 使用Long.parseLong,而不是Long.getLong
Guava库 Joiner 超好用的Guava库，主要用于字符串的拼接，可以自动在中间加上分隔符
 String yamlStart = &amp;quot;---\n&amp;quot;; String yamlEnd = &amp;quot;...\n&amp;quot;; Joiner joinerContent = Joiner.on(&amp;quot;...\n---\n&amp;quot;).skipNulls(); return Joiner.on(&amp;quot;&amp;quot;).join(yamlStart, joinerContent.join(yamlList), yamlEnd);  Splitter 可以很方便的将字符串分割成对应的数据结构
 //将source进行处理 List&amp;lt;String&amp;gt; tempSource = Splitter.on(&amp;quot;,&amp;quot;).splitToList(param.getSource());  String占位符的用法 原来：
 String title = &amp;quot;[&amp;quot; + characterName + &amp;quot;][&amp;quot; + task.getEnv() + &amp;quot;][&amp;quot; + pipelineStage.getService() + &amp;quot;]&amp;quot;;  改进：
 String title = String.format(&amp;quot;[%s][%s][%s]&amp;quot;,  线程中的问题 不能直接使用Autowired，需要定义了成员变量之后，使用外界已经加载好的service作为入参传入初始化这个线程，如果每一个线程都启一个service的话，资源消耗会很大。 （仅仅是我暂时这么理解，TODO 搞清楚原因）
数据入库的操作 建议先入队列，然后再入库
Configuration的问题 定义了两个configuration，一个masterClient，一个jobClient 然后有个地方使用了@Autowired来进行配置（一个在外层service，一个是另外一个service），这时候就出现了冲突，开始报错。配置一定要清晰</description>
    </item>
    
    <item>
      <title>Java8流式编程</title>
      <link>https://lllovol.com/stream/</link>
      <pubDate>Thu, 21 Mar 2019 11:08:24 +0000</pubDate>
      
      <guid>https://lllovol.com/stream/</guid>
      <description>前言 在前天的时候，java12都出了，但是我还在用java6的陈旧的编码方式，需要改进到java8的流式编程，此文主要是用来记录流式编程的积累
 java8 新特性
 个人的主要理解 java真正的支持了函数式的编程，同时加入了streamApi来进行支持
 Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。 Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 Stream编程
 总而言之，流式操作主要分为了中间操作和最终操作
Intermediate 操作 非最终操作，也就是中间操作
 map (mapToInt, flatMap 等) filter distinct sorted peek limit skip parallel sequential unordered  Terminal 操作 最终操作
 forEach forEachOrdered toArray reduce collect min max count anyMatch allMatch noneMatch findFirst findAny iterator  Short-circuiting 操作 短程巡回操作</description>
    </item>
    
    <item>
      <title>RocketMQ源码分享笔记</title>
      <link>https://lllovol.com/rocketmq/</link>
      <pubDate>Tue, 19 Mar 2019 10:54:01 +0000</pubDate>
      
      <guid>https://lllovol.com/rocketmq/</guid>
      <description>前言 RocketMQ，是一种延时队列，主要的应用场景，就是消费者可以延时消费消息，比如在双11的时候,一瞬间有太多请求全部打在服务器上，服务器就会瞬间瘫痪，本文主要就是记录前辈分享的Rocket源码的时候笔记和一些感悟
主要功能  负载均衡 消费模式 消费拉取 消费进度反馈 消费过滤 延迟队列  分享主要内容笔记 打字速度有限，只能记录下简单的一些片段供参考
 有一个架构，轮询，可用性高，一致性要求没那么高 消息的一个流程：生产者发了一个消息，到了breaker之后，到了commitlog。有一个G的大小，实际发送的大小，顺序写的，io性能会很好，会被放到消费者的queue里面 ，小了之后，总要发到某一个topic里面 发一个消息的话，需要新建一个主题，需要制定一个queue的数量，每一个queue就是一个负载均衡，表示当前这个queue，消费到什么位置了。集群消息，一人拿一个。被负载的queue，同一个topic下的消息都是不同的 消费者可以对同一个topic下面的某几个队列进行消费，多个不同的consumer 设置min是核心线程数，是固定的，但是她的队列是无限的，所以这个地方没有什么用 缓存超过10000个，会改变线程池的大小，会做对应的限制 msgListener就是传的一个回调 会有一个offsetStore会存，存到本地和远程 还有消息的消费逻辑，注册到客户端的，生成clientId 封装了一些拉取消息的api，通过路由信息 worker发出请求，然后又一个线程池，来进行序列化和相应，消费的话会再七环到对应consumer的线程池 有各种组件，然后讲讲启动之后，都做了哪些事情 基本上都是通过定时消息去驱动的，很少是通过事件去驱动的， 找nameserver,然后去找server的信息 更新consumer消费的一个队列offset 都不是实时的更新的，是每一个五秒钟才刷新一次的 广播消费的，消费的queue是全部，订阅，不是分发，每一个rebalance里面，都处理了一个queue，实现了一个拍照 如果没有存，就是首次消费，如果是last，就会从，rocket是经常清消息的，发消息，然后消费 消费，就是拉取消息，就是放一条消息，就可以进行拉取，会先做一些验证，然后做一些限流，只不过限流是做一些delay，顺序消息，需要设置一下是不是第一次，然后获取订阅信息，然后调用对应的pullapi，然后去发一条消息，拉倒请求之后，就会有callback，去封装一下，找到了消息了，然后有一个真正的消息处理类 处理的流程 如果全部消费成功了之后，就会找到maxOffset，如果没有的话，就会去更新最小的那一个，这就是整个的一个消费流程  自行延展 MQ是高并发系统的核心组件之一，能够提高业务效率和系统的稳定性，主流的MQ有Rocketmq、kafka、Rabbitmq
 Rocketmq原理&amp;amp;最佳实践 主要对比如下
 </description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(八)装箱与拆箱，基本数据类型与包装类</title>
      <link>https://lllovol.com/spring8/</link>
      <pubDate>Thu, 14 Mar 2019 17:03:05 +0000</pubDate>
      
      <guid>https://lllovol.com/spring8/</guid>
      <description>前言 主要用来记录整理最近一周工作学习中遇到，学到的一些小知识，积少成多，聚沙成塔
小细节 Swagger-ui显示枚举类型的时候 定义的枚举类型的头上不需要加一些莫名其妙的注解，就可以在Swagger-ui界面自动生成
 public enum GreyTaskType { SCALE, PERSON, DEMAND, HOST ; }  Swagger-ui的参数显示的问题 这个是在帮忙解决朋友的问题的时候发现的，其实就是Getter的问题，他定义了俩Getter，这样就会有俩参数跑出来了。
双向的验证 在两个模块相互依赖的时候，一方在进行某些操作的时候，需要判断另一方的状态，同样，另一方在进行某些操作的时候，也需要对这边的状态进行判断。 （主要是在删除和发布操作的时候）
Burp Suite和Kali系统 能够用于web应用攻击的，主要使用这个工具来进行网络安全方面的测试。而Kali系统主要就是黑客使用的系统了，用于网络渗透
Spring cloud配置中心 能够使用这个工具，实现项目发布在不同环境的情况下， 自行加载对应环境下的配置，而不再用手动修改
配置的优先级顺序：  配置中心的/-(env).yml （一般不存在） 配置中心的application-env.yml （一般不存在） 配置中心的 /-test.yml 配置中心的application-test.yml 配置中心的 /.yml 配置中心的application.yml 项目内的application.yml  从上到下，优先级依次降低
debug的时候的细节 在debug的时候，停到某一行的时候，可以按optional+f8，可以单独对函数进行调试，包括修改参数等等操作
栈和队列有什么区别 吃多了拉就是队列，吃多了吐就是栈（段子区看到的23333对栈和队列最形象生动的解释了）
Java中的装箱和拆箱 这个是一个前辈教授于我的，同时还推荐了一些书籍给我
spring 相关书籍推荐 spring boot 编程思想 原生类型，装箱和拆箱（int 和Integer） https://www.cnblogs.com/dolphin0520/p/3780005.html
为什么会有装箱和拆箱 我的理解，是将一个基本类型装箱，变成一个类，比如int 比那成Integer，这样做了之后，就能赋予这个类其他的各种方法和函数操作。
当然这只是我很浅显的理解，下面是我在网上查阅相关的资料所了解到原因
 为什么会有装箱和拆箱 深入浅出java装箱和拆箱
  将一个基本类型包装成一个类， 可以使得这个类有很多可以调用的方法 java还不算纯面向对象的语言，真正的面向对象，是没有基本数据类型的 在java的泛型中，基本类型是不能够作为泛型参数的，因此需要使用包装类的类型解决泛型参数的问题 这也是早期java的设计缺陷，基本的数据类型是数据，不是对象，也不是Object的子类，因此需要装箱，才能和其他的Object子类公用一个接口  基本数据类型和对应的包装类    基本数据类型 包装类     int（4字节） Integer   byte（1字节） Byte   short（2字节） Short   long（8字节） Long   float（4字节） Float   double（8字节） Double   char（2字节） Character   boolean（未定） Boolean    装箱和拆箱的过程  装箱过程：通过调用包装器的valueOf方法实现的 拆箱过程：通过调用包装器的xxxValue方法实现的。（xxx代表对应的基本数据类型）。  其他注意点  通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.</description>
    </item>
    
    <item>
      <title>源码阅读SpringDataJPA</title>
      <link>https://lllovol.com/springdatajpa/</link>
      <pubDate>Mon, 11 Mar 2019 19:28:16 +0000</pubDate>
      
      <guid>https://lllovol.com/springdatajpa/</guid>
      <description>前言 CRUD是平常业务开发过程中最常接触到的，因此想通过阅读这个最常接触模块的代码，使得自己能够更加深入的了解Spring，提升自己的技术能力，而不是只会CRUD，却都不知道它是怎么实现的。
Hibernate  Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm（Object Relational Mapping）框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，完成数据持久化的重任。Hibernate百科
 JPA  JPA诞生的缘由是为了整合第三方ORM框架，建立一种标准的方式，百度百科说是JDK为了实现ORM的天下归一，目前也是在按照这个方向发展，但是还没能完全实现。在ORM框架中，Hibernate是一支很大的部队，使用很广泛，也很方便，能力也很强，同时Hibernate也是和JPA整合的比较良好，我们可以认为JPA是标准，事实上也是，JPA几乎都是接口，实现都是Hibernate在做，宏观上面看，在JPA的统一之下Hibernate很良好的运行。
我们都知道，在使用持久化工具的时候，一般都有一个对象来操作数据库，在原生的Hibernate中叫做Session，在JPA中叫做EntityManager，在MyBatis中叫做SqlSession，通过这个对象来操作数据库。我们一般按照三层结构来看的话，Service层做业务逻辑处理，Dao层和数据库打交道，在Dao中，就存在着上面的对象。那么ORM框架本身提供的功能有什么呢？答案是基本的CRUD，所有的基础CRUD框架都提供，我们使用起来感觉很方便，很给力，业务逻辑层面的处理ORM是没有提供的，如果使用原生的框架，业务逻辑代码我们一般会自定义，会自己去写SQL语句，然后执行。在这个时候，Spring-data-jpa的威力就体现出来了，ORM提供的能力他都提供，ORM框架没有提供的业务逻辑功能Spring-data-jpa也提供，全方位的解决用户的需求。使用Spring-data-jpa进行开发的过程中，常用的功能，我们几乎不需要写一条sql语句。
  博文地址 JPA官方文档  应用实例 在大家的日常开发中都用到了很多，再次就不细致列举了，详情可以查看另外一篇博文
 Spring开发的小细节（六）
 源码解析 Repository  @Indexed public interface Repository&amp;lt;T, ID&amp;gt; { }  CrudRepository 主要接口 CurdRepository
 public interface CrudRepository&amp;lt;T, ID&amp;gt; extends Repository&amp;lt;T, ID&amp;gt; { &amp;lt;S extends T&amp;gt; S save(S var1); &amp;lt;S extends T&amp;gt; Iterable&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; var1); Optional&amp;lt;T&amp;gt; findById(ID var1); boolean existsById(ID var1); Iterable&amp;lt;T&amp;gt; findAll(); Iterable&amp;lt;T&amp;gt; findAllById(Iterable&amp;lt;ID&amp;gt; var1); long count(); void deleteById(ID var1); void delete(T var1); void deleteAll(Iterable&amp;lt;?</description>
    </item>
    
    <item>
      <title>进程间通信的方式</title>
      <link>https://lllovol.com/inter-process/</link>
      <pubDate>Tue, 05 Mar 2019 16:22:56 +0000</pubDate>
      
      <guid>https://lllovol.com/inter-process/</guid>
      <description>前言 IPC（Inter-Process Communication，进程间通信）
有时候我们需要在不同的程序之间，也就是不同的进程之间进行通讯，那么都有些什么方式呢？通过查阅相关资料，主要有信号、管道、消息队列、共享内存等等
 进程间通信的方式
 常见的通讯方式  套接字Socket：套接字是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 信号量：信号量是一种计数器，主要是用来控制多个进程对共享资源的访问，在锁机制中应用比较多，保证在一个进程对一个资源进行访问的时候，其他进程不能对其进行资源访问 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 共享内存：内存共享是最快的IPC方式（SharedMemory）。就是映射一段其他进程也能够进行访问的内存。这一段内存虽然是由一个进程进行创建，但是多个进程都能进行访问。通常和信号量配合使用，来实现进程之间的同步和通信。 管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
以上的任何一点都可以单独拿出来做一篇文章，路漫漫其修远兮  文章中已经写得很好了：）站在了巨人的肩膀上</description>
    </item>
    
    <item>
      <title>Yaml和Java对象之间的相互转换</title>
      <link>https://lllovol.com/yamlbeans/</link>
      <pubDate>Fri, 22 Feb 2019 21:46:09 +0000</pubDate>
      
      <guid>https://lllovol.com/yamlbeans/</guid>
      <description>前言 最近需要做一个将java对象转换成yaml文件格式的工作，由于手动进行操作的话效率会很低下，因此再找有没有合适的包可以使用。最后找到的工具就是yamlBeans,本文主要是翻译整理yamlBeans中的一部分信息
 yamlBeans官网
yaml文档的学习
 添加依赖 将下列代码添加到pom文件当中
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.esotericsoftware.yamlbeans&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;yamlbeans&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.12&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  Yaml反序列化为常见数据结构 所谓的反序列化，就是将yaml格式的文件，转换为java的常见数据结构 主要使用的类是YamlReader，然后可以将yaml文档转换为HashMap，ArrayList,还有Strings类型。
yaml：
name: Nathan Sweet age: 28 address: 4011 16th Ave S phone numbers: - name: Home number: 206-555-5138 - name: Work number: 425-555-2306  code:
YamlReader reader = new YamlReader(new FileReader(&amp;quot;contact.yml&amp;quot;)); Object object = reader.read(); System.out.println(object); Map map = (Map)object; System.out.println(map.get(&amp;quot;address&amp;quot;));  Yaml反序列化为POJO 将yaml文档反序列化为pojo(plain ordinary java object)
Yaml and java class:
name: Nathan Sweet age: 28 public class Contact { public String name; public int age; }  Code:</description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(七)Controller路由以及分页查询</title>
      <link>https://lllovol.com/spring7/</link>
      <pubDate>Wed, 20 Feb 2019 11:35:51 +0000</pubDate>
      
      <guid>https://lllovol.com/spring7/</guid>
      <description>前言 过年后第一次开始更新啦，这一篇主要就用来总结年后以来有意思，有用的一些信息
在Controller中的一些注解 Controller的类型 主要有两种，一种是普通的,通常是被使用服务于web页面的。默认，你的controller方法返回的是一个string串，是表示要展示哪个模板页面或者是要跳转到哪里去。
@Controller  另外一种是专门用在编写API的时候，返回一个JSON，或者是XML等等。然后方法返回的是可以是一个对象，或者是一个可以被序列化的对象。
@RestController  路由的类型 这里的路由就是指http method。（GET,POST,PUT,PATCH,DELETE）。
@GetMapping @PostMapping @PutMapping @PatchMapping @DeleteMapping  同时，在Controller上面可以加上一个@RequestMapping，可以将所有类型路由的前缀都放在上面
@RestController @Slf4j @Api(tags = &amp;quot;11. xxxxx&amp;quot;) @RequestMapping(&amp;quot;/api/v1&amp;quot;) @RequiredArgsConstructor public class DataController { private final DataService dataService; @ApiOperation(&amp;quot;11.1 xxxx&amp;quot;) @GetMapping(&amp;quot;/statistics&amp;quot;) public Response&amp;lt;DataDeployDto&amp;gt; deployTask(@Validated DataParam query){ log.info(&amp;quot;data Query {}&amp;quot;, JSONObject.toJSON(query)); return ResponseUtil.makeSuccess(dataService.deployData(query)); } }  在Controller内的传参的注解 @ApiOperation(&amp;quot;1.1 创建业务线&amp;quot;) @PostMapping(&amp;quot;/save&amp;quot;) public Response save(@RequestBody @Validated CustomProductAddParam customProductAddDto) { log.info(&amp;quot;save() {}&amp;quot;, JSONObject.toJSON(customProductAddDto)); customProductService.save(customProductAddDto, true); return ResponseUtil.</description>
    </item>
    
    <item>
      <title>《Spring源码深度解析》读后感(二)Bean的标签解析</title>
      <link>https://lllovol.com/spring-source-code-2/</link>
      <pubDate>Thu, 17 Jan 2019 11:56:50 +0000</pubDate>
      
      <guid>https://lllovol.com/spring-source-code-2/</guid>
      <description>两种标签 Spring中的标签的包括默认的标签和自定义的标签两种，而这两种标签的用法和解析方式存在着很大的不同。
默认标签的解析 默认标签的解析是在parseDefaultElement函数中进行的，函数中的功能逻辑一目了然，分别对4种不同的标签做了不同的处理：
 import alias bean beans  bean标签的解析以及注册 在4种标签的解析中，对bean的解析最为复杂也最为重要。因此由此深入，如果将此标签的解析过程理解了，其他标签的解析自然也会迎刃而解。
processBeanDefinition（ele,delegate） /** * Process the given bean element, parsing the bean definition * and registering it with the registry. */ protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) { BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) { bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try { // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); } catch (BeanDefinitionStoreException ex) { getReaderContext().error(&amp;quot;Failed to register bean definition with name &#39;&amp;quot; + bdHolder.</description>
    </item>
    
    <item>
      <title>《Spring源码深度解析》读后感(一)Spring的容器Bean</title>
      <link>https://lllovol.com/spring-source-code/</link>
      <pubDate>Tue, 15 Jan 2019 17:06:53 +0000</pubDate>
      
      <guid>https://lllovol.com/spring-source-code/</guid>
      <description>前言 这个系列主要是用来记录自己读这本书的一些笔记和想法的记录，不过买书好像买错了，应该买spring boot的相关解读的书籍，这是spring的深入解读的书。吃了一亏，不过这也是spring boot的前身，其中的源码也是有价值的。
首先开始的，是整个spring当中最核心的用法，但是却十分重要的一个部分&amp;ndash;容器。大道至简，大音希声。
容器的基本用法 bean是spring中最核心的东西，因为spring就像一个大水桶，而bean就像是水桶中的水，水桶脱离了水便没有了什么用处。而spring 的目的，就是让我们的bean，能够成为纯粹的POJO（plain ordinary java object）。 需要：
  一个成员属性
  这个属性的getter
  这个属性的setter 然后在配置文件xml当中添加相关的bean
 &amp;lt;bean id=&amp;quot;myTestBean&amp;quot; class=&amp;quot;bean.MyTestBean&amp;quot;/&amp;gt;    然后就可以在测试代码中使用我们所测试的bean了
容器的基础XmlBeanFactory 代码如下
 BeanFactory bf= new XmlBeanFactory(new ClassPathResource(&amp;quot;beanFactoryTest.xml&amp;quot;));  实现流程 首先调用了ClassPathResource的构造函数 来构造了Resource资源文件的实例对象，然后后续的资源处理就可以使用Resource提供的各种服务来操作了。然后当我们有了Resource之后，就可以进行XmlBeanFactory的初始化了。
与之同理，对于不同来源的资源文件都有相应的Resource实现。有了Resource接口之后便可以对所有资源文件进行统一的处理。例如
 Resource resource=new ClassPathResource(&amp;quot;beanFactoryTest.xml&amp;quot;); InputStream inputStream=resource.getInputStream();  XmlBeanDefinition 然后，当Resource的相关类完成了对配置文件进行封住后配置文件的读取工作就全权交给XmlBeanDefinition来处理了。
（ignoreDependencyInterface（）函数的主要功能是忽略给定接口的自动装配功能） (时序图书 p20)
 封装资源文件。 获取输入流 通过构造的InputSource实例和Resource实例继续调用函数doLoadbeanDefinitions  支撑着整个Spring容器部分的实现基础 然后就是3个步骤，支撑着整个Spring容器部分的实现基础
 获取对XML文件的验证模式 加载XML文件，并得到对应的Document 根据返回的Document注册Bean信息  doRegisterBeanDefinitions(root) 然后，又通过一系列的处理之后，终于可以到了核心逻辑的底部doRegisterBeanDefinitions(root)
终于开始真正的解析了。</description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(六)JPA</title>
      <link>https://lllovol.com/spring6/</link>
      <pubDate>Tue, 08 Jan 2019 10:51:00 +0000</pubDate>
      
      <guid>https://lllovol.com/spring6/</guid>
      <description>前言 本文主要总结于如下的官方文档的部分内容，如有翻译不当理解不当的地方，欢迎留言指正
Spring官方文档
Spring JDBC官方文档
Spring MongoDB官方文档
JPA JAVA Persistence API，java持久化的api
 JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易地掌握。JPA基于非侵入式原则设计，因此可以很容易地和其它框架或者容器集成。
 MongoDB与JDBC mongoDB和JDBC（JAVA DATABASE CONNECTIVITY）最顶级的抽象类CrudRepository有很多相似的地方，下面就来看看CrudRepository和MongoRepository的对比，根据源码来看看两者之间的关系
MongoRepository @NoRepositoryBean public interface MongoRepository&amp;lt;T, ID&amp;gt; extends PagingAndSortingRepository&amp;lt;T, ID&amp;gt;, QueryByExampleExecutor&amp;lt;T&amp;gt; { @Override &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; entites); @Override List&amp;lt;T&amp;gt; findAll(); @Override List&amp;lt;T&amp;gt; findAll(Sort sort); &amp;lt;S extends T&amp;gt; S insert(S entity); &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; insert(Iterable&amp;lt;S&amp;gt; entities); @Override &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; example); @Override &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; example, Sort sort); }  CrudRepository public interface CrudRepository&amp;lt;T, ID extends Serializable&amp;gt; extends Repository&amp;lt;T, ID&amp;gt; { &amp;lt;S extends T&amp;gt; S save(S entity); Optional&amp;lt;T&amp;gt; findById(ID primaryKey); Iterable&amp;lt;T&amp;gt; findAll(); long count(); void delete(T entity); boolean existsById(ID primaryKey); // … more functionality omitted.</description>
    </item>
    
    <item>
      <title>关于吞吐量的一些小知识</title>
      <link>https://lllovol.com/qps/</link>
      <pubDate>Mon, 07 Jan 2019 15:23:02 +0000</pubDate>
      
      <guid>https://lllovol.com/qps/</guid>
      <description>RT 响应时间 response time相应时间
响应时间是提交请求和返回该请求的响应之间使用的时间。
主要包括：
 数据库查询的时间 将字符传到终端上面所花的时间 访问web页面所花的时间  对于没有并发的系统而言，响应时间是一个合理并且准确的性能指标。但是响应时间的绝对值并不能反应性能的高低，软件的性能高低实际取决于用户对于该响应时间的接受度。 这就像是恋爱中的感情一样，你回复消息的快慢并不能反应你有多么爱她，而是取决于她对于你的这些行为的接受程度。TPS 每秒事物处理量 Transaction Per Second 吞吐量的（Throughput），吞吐量是指系统在单位时间内处理请求的数量。
对于单应用系统而言，吞吐量和响应时间严格成反比。单应用使用响应时间来作为衡量的指标，但是对于并发系统而言，通常需要吞吐量作为性能指标。因为在一个并发系统下，当一个用户一个请求的时间为t,但是n个用户一同请求往往不是n*t（可能大，可能小，需要看具体的情况）。一个并发系统如果配置合理，相应时间应该不会随着用户的增多而线性增加。因此才将吞吐量作为并发系统的性能衡量指标。一般而言，对于不同用户规模和不同的用户模式的系统，如果系统的最大吞吐量大致相同的话，可以判断两个系统的数据处理能力基本相同。
并发用户数 并发用户数指的是系统最大可以承受的正常使用系统功能的用户数。这个指标比TPS更加笼统，但是也更加的直观。但是这是一个非常不准确的指标，比如一个直播的弹幕网站，用户可以登录，正常发送弹幕，但是如果都挤在了一个直播间，同一时间发送一大堆弹幕，这时候的服务器可能就会崩了。而且用户在线的时候，大部分时间都在阅读信息，只有小部分的再发送请求，这样的情况是很多的。这项指标很大情况下取决于用户的行为模式。
QPS 每秒查询数量 Query Per Second
 每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）摘自cnblog
 </description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(五)String、StringBuffer和StringBuilder、</title>
      <link>https://lllovol.com/spring5/</link>
      <pubDate>Sat, 05 Jan 2019 17:05:33 +0000</pubDate>
      
      <guid>https://lllovol.com/spring5/</guid>
      <description>Code Review 这一周主要是一个前辈的code Review，在此期间能学到很多新的东西，也能看到自己的不足
变量名的命名 禁止使用拼音，真的显得很没有水平，而且可读性会非常差，除非这个对象真的只有拼音名字
关于异常的抛出  异常不要怕抛出的多，有异常一定要打出来，不然出了错都不知道是什么地方出的错 禁止一个Exception就把一大段代码的所有异常给吞了 异常一定要用log.error()将栈给打出来  StringBuffer、StringBuilder和String 运行速度：执行速度，在这方面运行速度快慢为：StringBuilder &amp;gt; StringBuffer &amp;gt; String String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。
String str=&amp;quot;abc&amp;quot;+&amp;quot;de&amp;quot;; StringBuilder stringBuilder=new StringBuilder().append(&amp;quot;abc&amp;quot;).append(&amp;quot;de&amp;quot;); System.out.println(str); System.out.println(stringBuilder.toString());  这种情况下除外，String的速度会比StringBuilder要快，因为第一行等价于String str=&amp;ldquo;abcde&amp;rdquo;。
在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的 如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。
使用的情况 String：适用于少量的字符串操作的情况
StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况
StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况
代码复用性 都是http的请求的话，封装成一个功能函数就好了，不用每次都写一个http的函数，复用性太低。而且最好的方式是使用feign的方式，更加的漂亮
正则和alike有什么区别吗？ 好像用alike好一点，但是mongo里面好像只有正则，其实都可以
Stream流的方式 主要用在将一个list转成另外一个list或者map转map的时候用的，入参一个，出参一个 list.stream().map（）使用java的，都能实现，主要是map可以不用写那么多代码。map(CustomVersion::new).collect(Collectors.toList()); 这个new 就是要创造一个传入的参数的构造函数
数据库的CRUD 查询的时候注意 不建议使用findAll，最好做一个分页，看一下表有多大，除非是表小，而且不会有爆炸性的数据增长的时候可以用。其他时候最好都有分页
删除的时候 最好是确认了可以保存了，然后再去删，这个，不应该一来就删了
profile 想了解应用运行的状态，在什么环境下的，应该去看activity的profile
spring: profiles: active: debug  上面是在bootstrap.yml中的，下面是如何使用
@Value(&amp;quot;${spring.profiles.active}&amp;quot;) String active; log.info(&amp;quot;start kubernetes watch,active:{}&amp;quot;,active);  将mongoTemplate改为repo的形式  官方文档
 相当的方便，好处就是出问题的时候，可以找到对应的表的对应的repo类，快速排查问题。
如果想要自定义函数的话，需要自定义一个接口，再实现之后，用repo来继承自定义的接口。</description>
    </item>
    
    <item>
      <title>《定位》</title>
      <link>https://lllovol.com/positioning/</link>
      <pubDate>Tue, 01 Jan 2019 01:29:23 +0000</pubDate>
      
      <guid>https://lllovol.com/positioning/</guid>
      <description>“取法于上，仅得为中，取法为中，故为其下”。  在读AI Ries和Jack Trout的这一本《定位》之前，我对“定位”这个词，第一个感觉，就是唐太宗的这句话，当然这只是仅仅是站在个人的层面，对自己的一种定位。在追求探索一件事情的时候，需要将目标放的高与长远一点。在读完《定位》之后，我对定位这个词有了新的理解。
回想近代社会的发展史，其实也就是人们的定位的一次次的更新和迭代：十八世纪六十年代，瓦特改良了蒸汽机，手工劳动的转变为了大机器生产，是第一次的工业革命，人类的生产力得到了极大的提高，这时候生产力的定位，是靠着有这熟练经验的技工总结而来的；十九世纪下半叶，蒸汽时代逐渐接受，人们逐渐开始进入电气时代，这时候生产力的定位，和第一次有着巨大的不同，是科学技术真正的开始带来生产力的巨大变革；而在第二次世界大战结束之后，人类进入了第三次的生产力革命，信息技术的革命，技术更迭日新月异，瞬息万变的时代，而现在的定位，正是书中所着重介绍的，可以植入人们心智的一种定位。
因此书中举了很多关于企业的例子，美国的香烟品牌如何使用定位抢占市场份额，航空公司的成长，福特公司生产汽车优劣等等。虽然这本书的作者，Jack Trout最早是在上个世纪70年代的时候提出来的定位这个概念，书中有不少例子都不是那么的新，甚至还会存在打脸的情况，但是最后的结果都在印证书中的观点的正确性。例如《TIME》的名字，作者最开始并不那么看好，认为这名字不是很好，销量不如《每周周刊》，虽然随着时间的不断积累，展示出来的结果恰恰相反，但是也在一定程度上印证了书中的观点，有一个好名字的重要性。预测失误只是当时的作者并不认为这是一个好的名字。
现在的中国，已经成长为世界上第二大的经济体，改革开放以来，中国的实体经济，主要都是靠着廉价的劳动力成本来进行的驱动，但是随着时代的发展，人们物质生活水平都在不断的提高，对精神需求方面以及环境保护方面，都有了非常大的变化。而在现如今的社会市场状况下，已经不是当初那个靠着产品来驱动的时代了。而应该就是书中所说的“定位的时代”。
通读全书，定位主要有以下几个方面。
确定领导者地位  成为第一就是进入顾客心智的主要途径，成为第一个进入人们心智某个领域的产品，给自己确定一个定位。在给自己定位之前，还必须明确当前自己的定位，不要去尝试去挑战那些已经是第一领导者的人，那需要更多宣传和更高的质量，然后对于后来者来说，都是很难同时兼顾的事情。如果是成功成为了领导者，那么就要遵循领导者的准则，以潜在用户的标准来建立领导地位，然后对竞争对手进行全面的拦截，同时保证自己产品的实力，对竞争对手提出来新的概念的时候做出迅速的回应，以保持自己的领导者地位。书中说，成为第一很难，保持第一很简单。但我觉得，这两者都并非易事，但是成为领导者之后，确实可以通过占有更大的资源份额，做出更大发展。就这一点来看，我们公司现在已经做到了，但是需要努力工作，才能保持优势。在公益筹款平台方面，我询问我的朋友们，他们第一反应就是我们公司。
跟随者的方式  如果不能成为领导者，那么就需要使用跟随者的方式，找到一个未被其他人占据的“空位”。例如同一个产品的高价定位，或者低价定位，或者性别定位，但是有一个陷阱，就是永远不要想着满足所有人的需求。这一点无论是做产品，还是做人做事，都是一样的道理，人的精力是有限的，将目标之事专注的完成了已经就不是一件易事。除此之外，还可以给竞争对手重新定位。个人理解，就是进行一种比较性的定位，找出自己具有优势而对手却薄弱的方面，进行定位，虽然这么做不是那么厚道，但是却真实有效。但是现实就是如此，对竞争对手少许的“贬低”，比自己大量的“自吹自擂”更加有意义。诚实和公正的重新定位，才能让竞争对手不敢怠慢。
产品的定位品牌  然后就是书中很重要的一个方面，就是自己的产品的定位品牌。一是拥有一个优秀的好名字，一个优秀的名字本身，在这个传播过渡的社会中就具有巨大的威力，例如水滴，完美符合众筹的这个概念，无论是点滴汇成江河海洋，还是滴水石穿，从古诗意境上面分析，这就是一个非常好的意象。一个响亮，接近通用而又带有描述性的名字，本身就可以阻击对手进入我们的领域。取名字真的是一门学问，就像一个好的名字会伴随一个人的终生，一个名字也将是一个产品最重要的牌面。二就是书中所提到的无名陷阱，有些名字冗长的公司企图使用缩写来简化自己的名字，然而往往适得其反，最后使得用户完全不知道这个缩写词所代指的到底是什么，除非足够幸运，缩写词刚好也是公司主要业务的体现这样的尤为特殊的情况，例如漫威电影中的神盾局Strategic Homeland Intervention, Enforcement and Logistics Division缩写刚好是S.H.I.E.L.D，这么幸运的事情，还是很难强求的。三就是不要企图将第一个成功的品牌名字无限的重复使用，使用一个名字不断延伸自己的产品种类，这样的坏处是，用户在看见这个名字的时候，会疑惑这到底指的是什么产品。当把一个成功产品的名字使用到多个新产品中的时候，其实是在消耗成功产品的寿命。看完此书之后，我才明白，为什么竹子好课不叫水滴好课，国际化项目不叫水滴国际而叫Deeda。总结来讲，品牌名就像是橡皮筋，它可以拉伸，但是又临界点，它拉的越长，就越脆弱。
个人定位  上面都是关于企业产品的定位，而对个人而言，也可以拥有自己的定位。首先是定义自己，给自己一个唯一确定的定位，个人觉得这是一个很难的命题，需要随着时间阶段的推移和自身的成长做出长远和短期的定位目标（OKR），例如现在我对自己的定位，就是做一个认真踏实的后端实习生，将来的定位，就是成为一个后端研发专业的工程师。然后就是拥有一个好名字，这一点需要感谢我的母亲，给我取了一个好名字，而我自身也需要用自己的行动来将这个名字赋予新的意义，更加具有辨识度。然后就是找一匹优秀的马，换言之，就是寻找一个能够提升自己的事业的公司与愿意培养自己的领导。我很幸运，在实习的时候能够来到这个充满活力和无限未来可能性的公司，同时也有很多优秀的前辈给予我悉心的培养、耐心的指导，在过去半年里让我成长很大。
你好2019  18再见，19你好！新的一年里，从零开始，新生再战！</description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(四)CR笔记ApplicationListener等等</title>
      <link>https://lllovol.com/spring4/</link>
      <pubDate>Fri, 28 Dec 2018 17:12:32 +0000</pubDate>
      
      <guid>https://lllovol.com/spring4/</guid>
      <description>Code Review 这周被点名来做code view了来着，然后昨天晚上做了一个小时的code review，还是相当紧张，然后今天改了一天代码 特此总结
ApplicationListener 这个地方原来主要实现的功能是spring3中的功能，在启动了整个项目之后，让watch pods和watch service启动并且只启动一次。
（启动一个单线程，回调函数，生命周期） 原来的做法是使用spring task在应用启动之后，就启动一次然后一直运行
// @Scheduled(cron = &amp;quot;${schedule.kubeService}&amp;quot;) @Scheduled(fixedDelay = 999999999) protected void gitlabProjectTask() { kubernetesService.collectServices(); customServiceService.bindServiceAndProject(); kubernetesService.watchServices(); } // @Scheduled(cron = &amp;quot;${schedule.kubePod}&amp;quot;) // @Scheduled(cron = &amp;quot;0 0,14 6,18 * * ? &amp;quot;) //taskexecutor // ScheduledExecutorTask // new 一个单线程一直跑就可以了 @Scheduled(fixedDelay = 999999999) public void collectPod() { kubernetesService.collectPods(); kubernetesService.watchPods(); }  现在使用的是ApplicationListener
public class KubernetesServiceImpl implements KubernetesService, ApplicationListener&amp;lt;ApplicationReadyEvent&amp;gt; { //生命周期 @Override public void onApplicationEvent(ApplicationReadyEvent event) { collectServices(); customServiceService.</description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(三)KubernetesClient的使用与配置</title>
      <link>https://lllovol.com/spring3/</link>
      <pubDate>Tue, 25 Dec 2018 15:08:35 +0000</pubDate>
      
      <guid>https://lllovol.com/spring3/</guid>
      <description>前言 最近主要在获取到的k8s中的相关service和pod的信息的变化，将原来全量获取数据的方式改进为增量的方式，此篇主要记录使用过程中遇到的坑和相信的解决方式
KubernetesClient的包的依赖的引用 使用的是fabric8的kubernetes-client，添加如下依赖即可
&amp;lt;!--在pom.xml文件--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.fabric8&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;kubernetes-client&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.0.5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  配置文件配置相关的属性 application.yml文件 添加k8s集群的主机url,token
api: server: k8s: key: &amp;quot;kubernetes.auth.token&amp;quot; token: &amp;quot;***********************************&amp;quot; url: &amp;quot;https://10.0.0.0:6443&amp;quot;  这里就有一个坑，就是这个token,由于kubernetes的安全机制，原来获取到的token都只有一天的时效，第二天都需要重新更新一个新的token
这样是肯定不行的，解决的方式有大概下面几种：
 使用证书的方式，需要三个文件，CaCertFile,ClientCertFile,ClientKeyFile 获取一种长效的永久的token，这个需要的权限比较高，需要找到kubernetes的负责人，拥有的权限比较高的人
（查看本地的token,cd ~/.kube,然后cat config,就能看到自己本地的token） 使用账号密码进行登录  configuration的实现 在configuration文件夹下面新建一个class，取名为KubernetesConfig
主要文件内容如下
@Setter @Configuration @ConfigurationProperties(prefix = &amp;quot;api.server&amp;quot;) public class KubernetesConfig { private K8s k8s; private static final int REQUEST_TIMEOUT = 3 * 1000; private static final int CONNECTION_TIMEOUT = 3 * 1000; @Bean(&amp;quot;kubernetesClient&amp;quot;) public KubernetesClient kubernetesClient() { Config config = new ConfigBuilder() .</description>
    </item>
    
    <item>
      <title>大咖分享-对游戏的看法</title>
      <link>https://lllovol.com/share/</link>
      <pubDate>Fri, 21 Dec 2018 19:24:46 +0000</pubDate>
      
      <guid>https://lllovol.com/share/</guid>
      <description>背景 晚上 青果灵动的CEO刘睿（julao）来到了我们公司进行了一场演讲
（以下都是按照julao的“我”）
正题 其实是周三
做了十五年了
青果这家公司已经做了10年了
每个人对游戏都有自己的价值观，所以这只是一次分享
p1 有人没有玩过游戏嘛？请举手 （有零星几个人举手）
玩过俄罗斯方块嘛？
玩过剪刀石头布吗？
拼多多使用游戏化的方法，成功？ 其实并不是，拼多多并不是游戏化的方式成功了。
这一次的分享只是一次学习的回报
关于游戏化的建议： 不要做，我做了十五年，都没有搞清楚游戏化是什么，每一个游戏都有自己的逻辑
p2 游戏仅仅是娱乐？ 毁三观：  英国【报销门】，做一些假报销，==》卫报的游戏（调查你处议员的开支） 大概是个什么样的游戏呢？  登录这个游戏，就可以看到可能和议会有关的图片都上传扫描上去，然后可以看见其他的玩家打上的留言和标签， 所有人可以根据这些图片找出线索， 这仅仅只是一个游戏，并没有什么物质上的奖励，调查的结果又28名议员和这个案子有关。
给我们一个非常重要的启示：20000名个玩家，为什么要去参加? 社会正义感？ 为什么游戏的这种方式会有效？    p3 光晕3中的人类保卫战（HALO3） 这是微软做的一个游戏，也是一个系列，是个在线联网的游戏 1500w名玩家发动的活动，人类保卫战。
565天，消灭了一百e的外星人，平均每天1175个，每小时73万个。
然后他们的成就被记录在 MUSEUM OF HUMANITY，做了个纪录片
里面所有的故事和画面都是虚拟的，但是唤起的感情是真实的
p4 重新认识一下游戏 俄罗斯方块：你知道你终究都会失败，这个游戏是没有胜利者的，这个游戏是为了输才玩的
内容并不新鲜，得分并没有奖励，so 为什么我们要玩俄罗斯方块？
人类的大脑进化到今天，大概过了四十万年
从经验
到规律
到指导行为
eg:为什么可以一边听演讲一边打字记下笔记？
为什么我们知道桌上的水是水？
游戏比现实更可预测！
这就是为什么游戏那么吸引人的一个重要的前提
游戏更加的不耐（进度反馈和不耐）
人脑只有体重的5%，但是消耗了25%的能量，所以这是为什么甜食这么受人们喜欢的原因
p5 追女孩是一件很难的事情 但是如果谈恋爱有进度条
我们的生物性，决定了我们的社会性
（游戏红） 游戏好玩就和脂肪很香一样，都是植入了DNA的东西
p6 游戏是积极的！ 玩游戏超过12小时的举手！但是玩游戏是很累的！加微信
因为游戏是个很累的一种事情</description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(二)CR笔记</title>
      <link>https://lllovol.com/spring2/</link>
      <pubDate>Thu, 20 Dec 2018 20:01:33 +0000</pubDate>
      
      <guid>https://lllovol.com/spring2/</guid>
      <description>Code Review 让大家对代码质量的标准是在一个线上， 是一个相互学习的过程。 blog主要是用来记录当时的笔记与自己的一些感想
用户中心的接口，需要查用户之前捐过的一些订单 ContextUtil.getUserId(()不建议使用 限制了使用线程的场景，可能每一段代码执行的线程可能不在一起了 讲究的是 变量来源应该是外部的,参数是传入的 swing local ？本地的东西 context 在子线程中是无法工作的，Util这个工具类，不应该涉及到线程这种复杂的东西
interceptor， implements HandlerMethodargumentResolver，//可以直接解析参数（将token解析的过程，就放到这个里面了） (@LoginUidAttribute String uid)  拿到userId的，isDelete()可以不用判断 解决泛型，warning 加 PageHelper是用的swing local mapper上面的select 一定要体现一个sql,查询条件一定要解耦，不要太复杂了 不要写太多的if OrderBizMapper.xml 这样可以更好的去维护索引
不建议使用copyProperties，只要一个属性对不上可能就会 使用long不建议使用int，java中一直诟病的，就是java中的对象看不出来到底是不是long null 新的语言都解决了 null会不会有问题的东西。 创建一个 optional约定就是，可能为null int 是不能为null的 interger是可以为null的 这样可以增加代码的意义的传递，这个就是一种约定 ，使用原生的类型比较好
链式的一个使用的方式，每一个点放一个行,因为一个点就表示一个操作了 order.stream() .map(OrderBizVo::new) .collect(Collection.toList())这样会更加java 8一点 .map() .distinct() .collect(Collections.toList()) //就可以  返回给前端最好返回是一个空的集合而不是一个null，这样前端会更好处理一点 每一个表建表的时候都需要加一个 isDelete update 不涉及索引的，不能一味使用 查sql，一般不应该根据sql来加，先是业务来看怎么查的？（冲突与建议）查询的时候只能将sql交给dba，沟通的简洁 连点增加锁的操作，token不用放在数据库中，这种没必要持久化的东西，就放到redis中 为什么是double check? 是处理单例的时候才会使用double check，早起的java处理指令重排的时候，会导致一个check会被跳过去的，所以才处理了double check （在说什么？我怎么开始听不懂了），两次的话，就总有一次会成功
e.printStackTrace()是禁止的 使用
log.error(&amp;quot;&amp;quot;,{},e);  token的延长时间 一个是长效token,一个是短效的token,这样子的话会更加安全一点</description>
    </item>
    
    <item>
      <title>Java中的容器类</title>
      <link>https://lllovol.com/java/</link>
      <pubDate>Sun, 16 Dec 2018 22:23:46 +0000</pubDate>
      
      <guid>https://lllovol.com/java/</guid>
      <description>概览 平时学习工作中，总会使用到各种各样的数据结构，map、set、LinkedHashMap等等，虽然在使用的过程中对此有了一定的了解，但是感觉还是不是很通透。故此写一篇blog用于总结java中的数据结构。
Java的容器类 Java中的容器类按照大的来分，主要可以分为：
 collection：存储着对象的集合 map：存储着key，value的键值对 接下来的主要就分别以上面两个类别展开进行整理  Collection List    List类别 特点     ArrayList 基于动态数组实现，支持随机访问，允许所有元素包括null   Vector 与ArrayList相似，但是Vector是线程安全的（同步的）   LinkedList 基于双向链表，只能顺序访问，可以快速的再链表中插入和删除元素（栈[Stack]、队列[Queue]、双向队列[Deque]）。没有同步方法   Stack 继承自Vector，实现一个后进先出的堆栈。额外提供了5个方法使得Vector可以被当做堆栈使用：push,pop,peek,empty,search。刚刚创建的时候是空栈     和LinkedList一样，ArrayList也是非同步的（unsynchronized）。一般情况下使用这两个就可以了，因为非同步，所以效率比较高。 如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。 几种java容器
 有几个问题
 ArrayList的扩容操作？  每一次扩容都会扩容到原来的1.5倍，使用grow()方法，第一次添加元素的时候分配10个对象空间，当添加到第11个元素的时候，就会扩容到原来的1.5倍，当添加到16个元素的时候，就会扩容到原来的15*1.5的大小，等等。每一次扩容都是通过Array.copyof(elementData,newCapacity)来实现的，会消耗大量的资源，代价比较大，因此在知道大致对象大小的时候，提前设置好ArrayList的大小是非常明智的选择。（old+old&amp;raquo;1)
 为什么Vector是线程安全的？  Set    Set类别 特点     SortSet(TreeSet) 基于红黑树有序，TreeSet是set的一种变体，是可以实现排序等功能的集合 O(logN)   HashSet 基于hash表实现，可以看成一个只有key的HashMap O(1) ，不允许重复，无序，允许存在null(最多一个)   LinkedHashSet 具有HashSet的查找效率，且内部使用了双向链表维护了元素的插入顺序,保证了集合的有序性     写了 HashMap 和 HashSet，然后我们可以看到 HashSet 的方法基本上都是基于 HashMap 来实现的，说白了，HashSet内部的数据结构就是一个 HashMap，其方法的内部几乎就是在调用 HashMap 的方法。 LinkedHashSet 首先我们需要知道的是它是一个 Set 的实现，所以它其中存的肯定不是键值对，而是值。此实现与 HashSet 的不同之处在于，LinkedHashSet 维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可为插入顺序或是访问顺序。 看到上面的介绍，是不是感觉其与 HashMap 和 LinkedHashMap 的关系很像？LinkedHashSet就是使用LinkedHashMap来实现的。 注意，此实现不是同步的。如果多个线程同时访问链接的哈希Set，而其中至少一个线程修改了该 Set，则它必须保持外部同步。</description>
    </item>
    
    <item>
      <title>SpringBoot开发中的一些小细节(一)Slf4J、Post和Get的小技巧</title>
      <link>https://lllovol.com/spring1/</link>
      <pubDate>Fri, 14 Dec 2018 19:13:00 +0000</pubDate>
      
      <guid>https://lllovol.com/spring1/</guid>
      <description>原来写的代码被CTO抓出来吐槽，发现确实都是一些当初自己没有注意到的地方，打算将这样的小细节一点一点的收集起来，养成更好的编码习惯。
Slf4j  The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time. 摘自https://www.slf4j.org/
 在编写Spring的代码的时候，只需要在Class上方添加一个@Slf4j的注解即可。slf4j是facade pattern的典型例子（隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口，又被成为门面模式或者外观模式） 使用的时候，可以使用占位符的方式进行日志的记录，省去了原来自己拼接日志的麻烦。
 log.debug(&amp;quot;wxpushGet() returned: {}&amp;quot; ,result);  但是有一些需要注意的地方。
 在日常开发调试的时候应该少用log.info()，而应该使用log.debug，不然在上线之后，就会产生很多冗余的信息。 只有在线上部署的时候，关键代码的信息，才使用log.info(),来显示日志的信息。千万不能滥用！ 在catch的抛出错误的时候，使用log.error()。会打印错误以及异常的信息 log.warn(),用于打印潜在的用户的错误可能的信息。  Dto等model的@Data注解 @Data注解，可以实现类的Getter和Setter的同时还有toString方法，没有必要自己再转一次Json(如果只是打印个日志的话)，lombok生成的toString的可读性是很高的
 Lombok 是一种 Java™ 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO Plain Ordinary Java Object）。它通过注解实现这一目的。</description>
    </item>
    
    <item>
      <title>实习总结与报告</title>
      <link>https://lllovol.com/summary/</link>
      <pubDate>Sun, 09 Dec 2018 17:19:50 +0000</pubDate>
      
      <guid>https://lllovol.com/summary/</guid>
      <description>概览  实习工作回顾 实习主要产出 没做好的地方 做的好的地方 成长以及收获 个人成长计划  实习工作回顾 从9月17号入职，实习至今，已将近有三个月的时间，全勤，认真负责的完成份内的工作，并且主动承担自己力所能及的其他任务。在海洋前辈的指导下，开发了nintendo，并且独立完成了运维的部分的自动化运维工具。
实习主要产出 Devops Nintendo平台 从零开始搭建的公司内部自研devops平台
 负责了gitlab方面的数据收集以及处理部分  获取gitlab的group，project，tag，commit，job分别持久化存储到MongoDb当中，实现相应的CRUD,以及返回数据的分页。 产品线的CRUD。 增加字段判断服务是不是公共服务，是不是需要部署，将服务与产品线相关联。 nintendo增量更新信息，使用gitlab的webhook回调更新tag信息，再通过SpringTask定时任务更新新增的project，并为新的project自动添加hook，实现数据的自动化更新。 通过pipeline，tag，定位到job，取得要运行的jobid，进行发版，实现部署发布服务的最初版本的接口（后期前辈改用了线程去实现，异步的去执行）。 获取gitlab执行job后的日志并进行处理，返回到前端。 改进接口，不传env的显示所有的服务，这样实现同一业务线下的服务可以部署到不同的环境下。   集成ldap，实现了用户的登录与登出，将用户登录状态记录在缓存中并返回一个token，使用redis实现，将来流量大的时候能够解决分布式问题。 nintendo的intercepter拦截器实现，同时记录下用户的操作日志，并且提供了用户的操作日志的模糊查询以及分页。 实现一个服务的tag和commit相关联，使得用户能够知道本次发布都更新了那些信息。 集成企业微信，并与上一个功能结合起来，实现用户发布服务之后，将服务发布的状态与信息发送给相关联的用户。  优化改进企业微信为卡片信息显示的样子。 卡片信息可以直接跳转到指定的服务日志地址进行查看，并且生成对应用户自带的token，实现免登陆直接查看，提高了用户体验。   平台信息显示的优化，将用户从拼音的显示转化为真正的名字来进行显示。 nintendo平台的历史功能部署实现。  每个人发布的tag，会帮他筛选出最近部署的5个服务，显示出最近发布的版本。 使用redis来进行存储对应的username,tag,service。 添加tag push类型的webhook，在tag进行更新的时候，更新对应user的对应的service信息。   nintendo平台一键部署到多环境的功能实现。  Autotool自动化运维工具  Ldap中rds组用户的自动化添加：基于LDAP自身的数据实现，每隔一段时间，遍历各个department，将符合条件的人员放进一个Set,再与rds中原来的用户进行比对，将新的用户添加到rds的members当中。 jumpserver的grey log_select test的跳板机权限的自动化添加：基于ldap和rds组和jumpserver的用户组实现，如果rds的用户组中出现了jumpserver中不存在的用户，自动为其创建一个账户，并且添加test log_select test的权限。  aaa项目升级与完善  将项目升级到Spring Boot 2.0，并且修复由于升级而造成的bug。 给aaa项目添加swagger-ui 企业微信消息发送Api的依赖封装与接口实现。  实现获取Token的接口，使得其他业务的同事能够使用这个token进行文件上传的功能 实现发送普通消息的接口 实现发送卡片信息的接口 实现发送文件信息的接口    没做好的地方  处理问题的方式不够完善和全面，在实现给每个project添加hook的时候，不小心多加了几条重复的数据，第一想法是将所有的hook全部删除，然后被海洋前辈及时制止：* “如果有的项目本身就有一些hook呢？你不能全部都删了。” * 最后改进，在删除的时候，判断是不是需要删除的url，如果匹配成功才执行删除操作。 查询日志的时候，不应该以当前的时间往前倒退一天，正常的操作应该是以一个零点作为时间点来进行查询。 jumpserver自动化运维工具所使用的账号，不应该是我个人的账号，由于原本使用的个人账号，后期因为我更改了密码，导致工具在一段时间内失效。 构建模板样式的工作没有放在值对象外面,这样的设计换不了模板，后来将api的包改为了单纯封装http请求，这样才能保证代码的可维护性和可拓展性。 升级aaa的时候，由于依赖版本的更新，更改代码之后没有进行逻辑方面的测试，就上线发版，导致了新入职的人员没有及时的同步与更新。以后对于线上的操作要万分慎重，无论多么小的改动，都需要进行仔细的测试，再进行提交。  做的好的地方  将公司的核心价值观牢记于心，并且贯彻落实到生活工作中。  用户第一 追求极致 开放心态 拥抱变化 诚信严谨 勤俭敬业   在不明白的地方及时的请教前辈，深知团队协作才能发挥1+1&amp;gt;2的能量。 对于学习工作中学习到的新的知识，会将其记录下来，深知好记性不如烂笔头的道理。 能够积极主动去承担工作中的任务。 对新事物永远保有一颗探索与发现的心，不断学习充实自己。  成长以及收获  熟悉了SpringBoot的框架，Initializer的使用和Swagger的使用，以及Spring的各种映射注解的使用（例如使用@Getter @Setter或者@Data，而不是原来每一次都generate Getter and Setter,一旦成员变量有一些变动，就需要维护很多地方），使用注解调动配置文件中的信息等等。 更加熟练地掌握了java代码的编写，更加熟悉了了解其中HashSet,HashMap以及有序的LinkedHashMap等数据结构（例如使用HashMap实现空间换取时间），使用了mock数据给前端进行同步开发，使用枚举类型来避免魔法数的产生等很多的细节。 更好的代码习惯养成，例如尽量重用对象，尽量使用局部对象，尽量减少对变量的重复计算，减少对象的IO，优化代码的体积等等。 更加熟悉了解了MongoDb这样的非关系型数据库。 更加熟悉了解了redis这样的分布式缓存。 更加熟悉了解了LDAP。 docker以及Kubernetes等关于微服务的相关知识，常用的命令行指令查看pods状态信息和日志。 CI/CD（Continuous Integration/ Continuous Deployment）方面的了解，熟悉了一个项目发布流程和整个生产的生命周期 gitlab,github等团队项目管理工具的使用。 maven构建项目，以及nexus公司私服服务器的使用。 AOP的面向切面的编程思想，将为业务逻辑所公用的逻辑封装起来，减少系统的重复代码，降低模块之间的耦合度，有利于未来的可操作性和可维护性。 提升了对各种官方文档的阅读能力和理解能力。 从刚进公司的龟速一指禅打字，到现在40wpm左右的规范指法打字。 OKR的这种聚焦的工作管理方式。  个人成长计划 不断积累方方面面的知识，主攻后端，也可以懂一点前端知识，也可以懂服务器的搭建，项目的发布等运维相关的知识，也可以懂DBA等等，希望自己能够成为一个全栈复合型的人才。虽然这难度很大，但是也正因为有挑战，才会更有价值。海洋前辈给我说，坚持每周写至少一篇技术型的文档，这将对自己的能力提升有很大帮助，我深表赞同，并将坚持下去。</description>
    </item>
    
    <item>
      <title>安装atom的atom-beautify</title>
      <link>https://lllovol.com/%E5%AE%89%E8%A3%85atom%E7%9A%84atom-beautify/</link>
      <pubDate>Fri, 07 Dec 2018 17:03:25 +0000</pubDate>
      
      <guid>https://lllovol.com/%E5%AE%89%E8%A3%85atom%E7%9A%84atom-beautify/</guid>
      <description>前言 想给atom安装beautify的插件 使用apm install atom-beautify 和是用preference中的插件安装都失败了
Start 使用github 克隆到本地，然后安装
 cd ~/.atom/packages git clone https://github.com/Glavin001/atom-beautify.git cd atom-beautify npm install  Success 使用control + alt + b 组合键 即可</description>
    </item>
    
    <item>
      <title>高效能人士的七个习惯</title>
      <link>https://lllovol.com/msg/</link>
      <pubDate>Thu, 06 Dec 2018 10:22:08 +0000</pubDate>
      
      <guid>https://lllovol.com/msg/</guid>
      <description>前言 最近看的一本书的随笔，摘抄与记录
七个习惯的简要的概要  习惯一，积极主动。由内而外的改变，积极面对一切 习惯二，以终为始。所有的事物都经过了两次创造，先在脑海中酝酿，其次才是实质的创造 习惯三，要事第一。次要的事情不必摆在第一，要事不能放在第二 习惯四，双赢思维。无论工作伙伴还是家庭成员，要从互赖式的角度思考 习惯五，知彼解己。舍弃回答心，改以了解心去聆听别人 习惯六，统合综效。创造第三种选择，是互相尊重的成果，创造式的合作，1+1&amp;gt;2的方式 习惯七，不断更新。身体、精神、智力、社会，不断更新自己  变化的世界不变的原则  恐惧感和不安全感：在现代社会有太多的人保守不安全感的折磨，担心自己失业，担心自己无力养家，也因此助长了一种现象就是：人们不论是在工作还是生活中，都倾向于选择一种零风险的生活，并且逃避和他人互相依赖和合作。（不能说这种想法就是错的，就像元素守恒的道理是一样的，风险和收益往往都是成正比例的，高回报的同时也伴随着高风险，而低风险往往伴随着平平淡淡；而合作的好处更是不言而喻，例如，在现代的敏捷软件开发过程中，出现了pair programming，可以增加纪律性，写出更加优秀的代码。就如同书中所说，我们生活在一个相互依赖的社会中，最辉煌的成就都是靠着互相依赖和合作才能成就的，远远不是个人能力了就能够企及的。） 我现在就想得到：我们必须训练头脑，大量投入，不断磨练，提升自己的竞争力，以免被社会所淘汰。绝对不能就满足于学校的教育。人生处处皆高考，这是我高中班主任最常给我们传授的一句话，而现实也正是如此。 缺乏人生平衡：懂得轻重缓急，抓住生活的重点，客观面对现实 我的定位在哪儿：真正的大事业，通常只会由思维开阔、内涵丰富的头脑，经由忘我的合作精神&amp;ndash;互敬和双赢取得的 渴望理解：想要获得其他人的理解，那么自己需要成为一个聆听着，学会去理解他人 冲突与分歧：采用创造性的合作，找到比双方最初想法都要好的解决方法。  产能平衡的原则 秉承自己内心的价值观，产生自己的自尊自重与自制力，以自己内在的价值标准，而不是以别人的好恶或者与别人的评价的结果，来衡量自己。事情的对错与别人是否发现无关。
不再让别人影响自己的情绪，反而会更加容易接受变化，因为可以有一些恒久不变的内在的本质，可以作为支柱
对自己要有耐心，因为自我成长是神圣的，同时也是脆弱的，是人生中最大规模的投资。
“得之太易者必不受珍惜。唯有付出代价，万物始有价值。上苍深知如何为其产品制定合理的价格”
待续。有缘再更</description>
    </item>
    
    <item>
      <title>基于Gitalk实现文章的评论功能</title>
      <link>https://lllovol.com/gitalk/</link>
      <pubDate>Wed, 05 Dec 2018 18:08:38 +0000</pubDate>
      
      <guid>https://lllovol.com/gitalk/</guid>
      <description>前言 想要在blog中实现文章评论发布功能，网上百度了很多文章，发现DISQUZ国内网访问速度比较慢，网易评论等平台也被关闭，最后发现了github强大功能，Gitalk。
 Gitalk：一个基于 Github Issue 和 Preact 开发的评论插件 摘自v2ex
 再一次感受到了开源的强大之处，造就了现如今信息技术的高速发展
设置OAuth github&amp;gt;右上角settings&amp;gt;Developer Settings&amp;gt;new OAuth App 然后依次输入
 Application name : 一个超厉害的名字 Homepage URL : github page的地址（http://yourname.github.io/） Application description : app的描述（随意） Authorization callback URL : Github api回调的地址，与Homepage URL相同  有一些坑需要注意，如果解析到了自己的域名，就在githubpage中的Repository，找到settings，找到github给你的url 即可获取到对应的clientId和clientSecret 修改post.html 然后在修改项目文件中的_layouts的post.html 找到合适的位置添加如下代码
&amp;lt;!--Gitalk评论start --&amp;gt; {% if site.gitalk.enable %} &amp;lt;!-- 引入Gitalk评论插件 --&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://unpkg.com/gitalk/dist/gitalk.css&amp;quot;&amp;gt; &amp;lt;script src=&amp;quot;https://unpkg.com/gitalk@latest/dist/gitalk.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;div id=&amp;quot;gitalk-container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt; var gitalk = new Gitalk({ clientID: &#39;{{site.gitalk.clientID}}&#39;, clientSecret: &#39;{{site.</description>
    </item>
    
    <item>
      <title>使用Rakefile实现文章生成器</title>
      <link>https://lllovol.com/rake/</link>
      <pubDate>Wed, 05 Dec 2018 01:23:16 +0000</pubDate>
      
      <guid>https://lllovol.com/rake/</guid>
      <description>使用github.io来写blog 本就是件很棒的事情，但是每次在想写新的文章的时候，都需要重新复制title和开头的标签，如果能够自动化地完成这件事就好了（重复性的东西工作）
About Rakefile  Rake is a Make-like program implemented in Ruby. Tasks and dependencies are specified in standard Ruby syntax.
 摘自http://docs.seattlerb.org/rake/
安装Rake sudo gem install rake  即可
创建Rakefile 在项目的根目录下
touch Rakefile vim Rakefile  然后添加如下代码
task :default =&amp;gt; :new require &#39;fileutils&#39; desc &amp;quot;创建新 post&amp;quot; task :new do puts &amp;quot;请输入要创建的文章文件文件名字：&amp;quot; @url = STDIN.gets.chomp puts &amp;quot;请输入文章的标题：&amp;quot; @name = STDIN.gets.chomp puts &amp;quot;请输入文章的子标题：&amp;quot; @slug = STDIN.gets.chomp puts &amp;quot;请输入文章的分类，以空格分隔：&amp;quot; @categories = STDIN.</description>
    </item>
    
    <item>
      <title>Welcome</title>
      <link>https://lllovol.com/welcome/</link>
      <pubDate>Mon, 14 Oct 1996 08:08:08 +0000</pubDate>
      
      <guid>https://lllovol.com/welcome/</guid>
      <description>Just Want to Share and Record Some Useful,Interesting Things !</description>
    </item>
    
  </channel>
</rss>
