<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='ä¸¤ç§æ ‡ç­¾ Springä¸­çš„æ ‡ç­¾çš„åŒ…æ‹¬é»˜è®¤çš„æ ‡ç­¾å’Œè‡ªå®šä¹‰çš„æ ‡ç­¾ä¸¤ç§ï¼Œè€Œè¿™ä¸¤ç§æ ‡ç­¾çš„ç”¨æ³•å’Œè§£ææ–¹å¼å­˜åœ¨ç€å¾ˆå¤§çš„ä¸åŒã€‚
é»˜è®¤æ ‡ç­¾çš„è§£æ é»˜è®¤æ ‡ç­¾çš„è§£ææ˜¯åœ¨parseDefaultElementå‡½æ•°ä¸­è¿›è¡Œçš„ï¼Œå‡½æ•°ä¸­çš„åŠŸèƒ½é€»è¾‘ä¸€ç›®äº†ç„¶ï¼Œåˆ†åˆ«å¯¹4ç§ä¸åŒçš„æ ‡ç­¾åšäº†ä¸åŒçš„å¤„ç†ï¼š
 import alias bean beans  beanæ ‡ç­¾çš„è§£æä»¥åŠæ³¨å†Œ åœ¨4ç§æ ‡ç­¾çš„è§£æä¸­ï¼Œå¯¹beançš„è§£ææœ€ä¸ºå¤æ‚ä¹Ÿæœ€ä¸ºé‡è¦ã€‚å› æ­¤ç”±æ­¤æ·±å…¥ï¼Œå¦‚æœå°†æ­¤æ ‡ç­¾çš„è§£æè¿‡ç¨‹ç†è§£äº†ï¼Œå…¶ä»–æ ‡ç­¾çš„è§£æè‡ªç„¶ä¹Ÿä¼šè¿åˆƒè€Œè§£ã€‚
processBeanDefinitionï¼ˆele,delegateï¼‰ /*** Process the given bean element, parsing the bean definition* and registering it with the registry.*/protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);if (bdHolder != null) {bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);try {// Register the final decorated instance.BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());}catch (BeanDefinitionStoreException ex) {getReaderContext().error(&amp;quot;Failed to register bean definition with name &#39;&amp;quot; &#43;bdHolder.'><title>ã€ŠSpringæºç æ·±åº¦è§£æã€‹è¯»åæ„Ÿ(äºŒ)Beançš„æ ‡ç­¾è§£æ</title>

<link rel='canonical' href='https://lllovol.com/posts/spring/2019-01-17-spring-source-code-2/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='ã€ŠSpringæºç æ·±åº¦è§£æã€‹è¯»åæ„Ÿ(äºŒ)Beançš„æ ‡ç­¾è§£æ'>
<meta property='og:description' content='ä¸¤ç§æ ‡ç­¾ Springä¸­çš„æ ‡ç­¾çš„åŒ…æ‹¬é»˜è®¤çš„æ ‡ç­¾å’Œè‡ªå®šä¹‰çš„æ ‡ç­¾ä¸¤ç§ï¼Œè€Œè¿™ä¸¤ç§æ ‡ç­¾çš„ç”¨æ³•å’Œè§£ææ–¹å¼å­˜åœ¨ç€å¾ˆå¤§çš„ä¸åŒã€‚
é»˜è®¤æ ‡ç­¾çš„è§£æ é»˜è®¤æ ‡ç­¾çš„è§£ææ˜¯åœ¨parseDefaultElementå‡½æ•°ä¸­è¿›è¡Œçš„ï¼Œå‡½æ•°ä¸­çš„åŠŸèƒ½é€»è¾‘ä¸€ç›®äº†ç„¶ï¼Œåˆ†åˆ«å¯¹4ç§ä¸åŒçš„æ ‡ç­¾åšäº†ä¸åŒçš„å¤„ç†ï¼š
 import alias bean beans  beanæ ‡ç­¾çš„è§£æä»¥åŠæ³¨å†Œ åœ¨4ç§æ ‡ç­¾çš„è§£æä¸­ï¼Œå¯¹beançš„è§£ææœ€ä¸ºå¤æ‚ä¹Ÿæœ€ä¸ºé‡è¦ã€‚å› æ­¤ç”±æ­¤æ·±å…¥ï¼Œå¦‚æœå°†æ­¤æ ‡ç­¾çš„è§£æè¿‡ç¨‹ç†è§£äº†ï¼Œå…¶ä»–æ ‡ç­¾çš„è§£æè‡ªç„¶ä¹Ÿä¼šè¿åˆƒè€Œè§£ã€‚
processBeanDefinitionï¼ˆele,delegateï¼‰ /*** Process the given bean element, parsing the bean definition* and registering it with the registry.*/protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);if (bdHolder != null) {bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);try {// Register the final decorated instance.BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());}catch (BeanDefinitionStoreException ex) {getReaderContext().error(&amp;quot;Failed to register bean definition with name &#39;&amp;quot; &#43;bdHolder.'>
<meta property='og:url' content='https://lllovol.com/posts/spring/2019-01-17-spring-source-code-2/'>
<meta property='og:site_name' content='lllovol'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts' /><meta property='article:tag' content='Spring' /><meta property='article:published_time' content='2019-01-17T11:56:50&#43;00:00'/><meta property='article:modified_time' content='2019-01-17T11:56:50&#43;00:00'/><meta property='og:image' content='https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/1.jpg' />
<meta name="twitter:title" content="ã€ŠSpringæºç æ·±åº¦è§£æã€‹è¯»åæ„Ÿ(äºŒ)Beançš„æ ‡ç­¾è§£æ">
<meta name="twitter:description" content="ä¸¤ç§æ ‡ç­¾ Springä¸­çš„æ ‡ç­¾çš„åŒ…æ‹¬é»˜è®¤çš„æ ‡ç­¾å’Œè‡ªå®šä¹‰çš„æ ‡ç­¾ä¸¤ç§ï¼Œè€Œè¿™ä¸¤ç§æ ‡ç­¾çš„ç”¨æ³•å’Œè§£ææ–¹å¼å­˜åœ¨ç€å¾ˆå¤§çš„ä¸åŒã€‚
é»˜è®¤æ ‡ç­¾çš„è§£æ é»˜è®¤æ ‡ç­¾çš„è§£ææ˜¯åœ¨parseDefaultElementå‡½æ•°ä¸­è¿›è¡Œçš„ï¼Œå‡½æ•°ä¸­çš„åŠŸèƒ½é€»è¾‘ä¸€ç›®äº†ç„¶ï¼Œåˆ†åˆ«å¯¹4ç§ä¸åŒçš„æ ‡ç­¾åšäº†ä¸åŒçš„å¤„ç†ï¼š
 import alias bean beans  beanæ ‡ç­¾çš„è§£æä»¥åŠæ³¨å†Œ åœ¨4ç§æ ‡ç­¾çš„è§£æä¸­ï¼Œå¯¹beançš„è§£ææœ€ä¸ºå¤æ‚ä¹Ÿæœ€ä¸ºé‡è¦ã€‚å› æ­¤ç”±æ­¤æ·±å…¥ï¼Œå¦‚æœå°†æ­¤æ ‡ç­¾çš„è§£æè¿‡ç¨‹ç†è§£äº†ï¼Œå…¶ä»–æ ‡ç­¾çš„è§£æè‡ªç„¶ä¹Ÿä¼šè¿åˆƒè€Œè§£ã€‚
processBeanDefinitionï¼ˆele,delegateï¼‰ /*** Process the given bean element, parsing the bean definition* and registering it with the registry.*/protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);if (bdHolder != null) {bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);try {// Register the final decorated instance.BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());}catch (BeanDefinitionStoreException ex) {getReaderContext().error(&amp;quot;Failed to register bean definition with name &#39;&amp;quot; &#43;bdHolder."><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/1.jpg' />
    <link rel="shortcut icon" href="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/cat.jpg" />

    </head>
    <body class="article-page keep-sidebar">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended ">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    <img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/cat.jpg" width="300" height="300" class="site-logo" loading="lazy" alt="Avatar">
                

                
                    <span class="emoji">ğŸ¥</span>
                
            </figure>
        
        <h1 class="site-name"><a href="https://lllovol.com">lllovol</a></h1>
        <h2 class="site-description">Stay Hungry, Stay Foolish</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        

        
            <li id="dark-mode-toggle">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <span>Dark Mode</span>
            </li>
        
    </ol>
</aside>

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/posts/spring/2019-01-17-spring-source-code-2/">
                
                    <img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/1.jpg" loading="lazy" alt="Featured image of post ã€ŠSpringæºç æ·±åº¦è§£æã€‹è¯»åæ„Ÿ(äºŒ)Beançš„æ ‡ç­¾è§£æ" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/spring/" >
                Spring
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/posts/spring/2019-01-17-spring-source-code-2/">ã€ŠSpringæºç æ·±åº¦è§£æã€‹è¯»åæ„Ÿ(äºŒ)Beançš„æ ‡ç­¾è§£æ</a>
    </h2>

    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Jan 17, 2019</time>
    </footer></div>
</header>

    <section class="article-content">
    <h1 id="ä¸¤ç§æ ‡ç­¾">ä¸¤ç§æ ‡ç­¾</h1>
<p>Springä¸­çš„æ ‡ç­¾çš„åŒ…æ‹¬é»˜è®¤çš„æ ‡ç­¾å’Œè‡ªå®šä¹‰çš„æ ‡ç­¾ä¸¤ç§ï¼Œè€Œè¿™ä¸¤ç§æ ‡ç­¾çš„ç”¨æ³•å’Œè§£ææ–¹å¼å­˜åœ¨ç€å¾ˆå¤§çš„ä¸åŒã€‚</p>
<h1 id="é»˜è®¤æ ‡ç­¾çš„è§£æ">é»˜è®¤æ ‡ç­¾çš„è§£æ</h1>
<p>é»˜è®¤æ ‡ç­¾çš„è§£ææ˜¯åœ¨parseDefaultElementå‡½æ•°ä¸­è¿›è¡Œçš„ï¼Œå‡½æ•°ä¸­çš„åŠŸèƒ½é€»è¾‘ä¸€ç›®äº†ç„¶ï¼Œåˆ†åˆ«å¯¹4ç§ä¸åŒçš„æ ‡ç­¾åšäº†ä¸åŒçš„å¤„ç†ï¼š</p>
<ul>
<li>import</li>
<li>alias</li>
<li>bean</li>
<li>beans</li>
</ul>
<h1 id="beanæ ‡ç­¾çš„è§£æä»¥åŠæ³¨å†Œ">beanæ ‡ç­¾çš„è§£æä»¥åŠæ³¨å†Œ</h1>
<p>åœ¨4ç§æ ‡ç­¾çš„è§£æä¸­ï¼Œå¯¹beançš„è§£ææœ€ä¸ºå¤æ‚ä¹Ÿæœ€ä¸ºé‡è¦ã€‚å› æ­¤ç”±æ­¤æ·±å…¥ï¼Œå¦‚æœå°†æ­¤æ ‡ç­¾çš„è§£æè¿‡ç¨‹ç†è§£äº†ï¼Œå…¶ä»–æ ‡ç­¾çš„è§£æè‡ªç„¶ä¹Ÿä¼šè¿åˆƒè€Œè§£ã€‚</p>
<h2 id="processbeandefinitioneledelegate">processBeanDefinitionï¼ˆele,delegateï¼‰</h2>
<pre><code>/**
 * Process the given bean element, parsing the bean definition
 * and registering it with the registry.
 */
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
  if (bdHolder != null) {
    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
    try {
      // Register the final decorated instance.
      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
    }
    catch (BeanDefinitionStoreException ex) {
      getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
          bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
    }
    // Send registration event.
    getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
  }
}
</code></pre>
<ul>
<li>é¦–å…ˆå§”æ‰˜BeanDefinitionDelegateç±»çš„parseBeanDefinitionElementæ–¹æ³•è¿›è¡Œå…ƒç´ è§£æï¼Œè¿”å›BeanDefinitionHolderç±»å‹çš„å®ä¾‹bdHolderã€‚åœ¨è¿™ä¸ªæ–¹æ³•ä¹‹åï¼ŒbdHolderå®ä¾‹å·²ç»åŒ…å«äº†æˆ‘ä»¬é…ç½®ä¸­çš„å„ç§å±æ€§äº†ï¼Œä¾‹å¦‚classã€nameã€idã€aliasä¹‹ç±»çš„å±æ€§äº†ã€‚</li>
<li>å½“è¿”å›çš„bdHolderä¸ä¸ºç©ºçš„æƒ…å†µä¸‹ï¼Œå¦‚æœå­˜åœ¨é»˜è®¤æ ‡ç­¾ä¸‹çš„å­èŠ‚ç‚¹ä¸‹å†æœ‰è‡ªå®šä¹‰å±æ€§ï¼Œè¿˜éœ€è¦åœ¨æ­¤å¯¹è‡ªå®šä¹‰æ ‡ç­¾è¿›è¡Œè§£æã€‚</li>
<li>è§£æå®Œæˆåï¼Œéœ€è¦å¯¹è§£æåçš„bdHolderè¿›è¡Œæ³¨å†Œï¼ŒåŒæ ·ï¼Œæ³¨å†Œæ“ä½œå§”æ‰˜ç»™äº†BeanDefinitionReaderUtilsçš„registerBeanDefinitionæ–¹æ³•ã€‚</li>
<li>æœ€åå‘å‡ºå“åº”æ—¶é—´ï¼Œé€šçŸ¥ç›¸å…³çš„ç›‘å¬å™¨ï¼Œåœ¨è¿™ä¸ªæ—¶å€™ï¼Œè¿™ä¸ªbeanå·²ç»åŠ è½½å®Œæˆäº†ã€‚</li>
</ul>
<h3 id="è§£æbeandefinition">è§£æBeanDefinition</h3>
<pre><code>/**
 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
 * if there were errors during parse. Errors are reported to the
 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
 */
@Nullable
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
  return parseBeanDefinitionElement(ele, null);
}

 /**
  * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
  * if there were errors during parse. Errors are reported to the
  * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
  */
 @Nullable
 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
    //è§£æidçš„å±æ€§
  String id = ele.getAttribute(ID_ATTRIBUTE);
    //è§£ænameçš„å±æ€§
  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
    //åˆ†å‰²nameçš„å±æ€§
  List&lt;String&gt; aliases = new ArrayList&lt;&gt;();
  if (StringUtils.hasLength(nameAttr)) {
   String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
   aliases.addAll(Arrays.asList(nameArr));
  }

  String beanName = id;
  if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {
   beanName = aliases.remove(0);
   if (logger.isDebugEnabled()) {
    logger.debug(&quot;No XML 'id' specified - using '&quot; + beanName +
      &quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
   }
  }

  if (containingBean == null) {
   checkNameUniqueness(beanName, aliases, ele);
  }
   //å¯¹æ ‡ç­¾ä¸­å…¶ä»–å±æ€§çš„è§£æè¿‡ç¨‹
  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
  if (beanDefinition != null) {
   if (!StringUtils.hasText(beanName)) {
    try {
    //å¦‚æœbeanæ²¡æœ‰beanNameï¼Œå°±ä½¿ç”¨é»˜è®¤æ–¹æ³•ç”ŸæˆbeanName
     if (containingBean != null) {
      beanName = BeanDefinitionReaderUtils.generateBeanName(
        beanDefinition, this.readerContext.getRegistry(), true);
     }
     else {
      beanName = this.readerContext.generateBeanName(beanDefinition);
      // Register an alias for the plain bean class name, if still possible,
      // if the generator returned the class name plus a suffix.
      // This is expected for Spring 1.2/2.0 backwards compatibility.
      String beanClassName = beanDefinition.getBeanClassName();
      if (beanClassName != null &amp;&amp;
        beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;
        !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
       aliases.add(beanClassName);
      }
     }
     if (logger.isDebugEnabled()) {
      logger.debug(&quot;Neither XML 'id' nor 'name' specified - &quot; +
        &quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
     }
    }
    catch (Exception ex) {
     error(ex.getMessage(), ele);
     return null;
    }
   }
   String[] aliasesArray = StringUtils.toStringArray(aliases);
   return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
  }

  return null;
 }
</code></pre>
<p>åœ¨å½“å‰å±‚ï¼Œå®Œæˆçš„ä¸»è¦å·¥ä½œå¦‚ä¸‹ï¼š</p>
<ul>
<li>1.æå–äº†å…ƒç´ ä¸­çš„idå’Œnameå±æ€§</li>
<li>2.è¿›ä¸€æ­¥è§£æå…¶ä»–æ‰€æœ‰å±æ€§å¹¶å°è£…è‡³AbstractBeanDefinitionç±»å‹çš„å®ä¾‹ä¸­</li>
<li>3.å¦‚æœæ£€æµ‹åˆ°beanæ²¡æœ‰æŒ‡å®šbeanNameï¼Œé‚£ä¹ˆä½¿ç”¨é»˜è®¤çš„è§„åˆ™ä¸ºæ­¤Beanç”ŸæˆBeanName</li>
<li>4.å°†è·å–åˆ°çš„ä¿¡æ¯å°è£…åˆ°BeanDefinitionHolderçš„å®ä¾‹ä¸­</li>
</ul>
<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥ç€æ¥çœ‹ä¸€ä¸‹æ­¥éª¤2ä¸­çš„å¯¹æ ‡ç­¾å…¶ä»–å±æ€§çš„è§£æè¿‡ç¨‹ï¼š</p>
<pre><code>/**
  * Parse the bean definition itself, without regard to name or aliases. May return
  * {@code null} if problems occurred during the parsing of the bean definition.
  */
 @Nullable
 public AbstractBeanDefinition parseBeanDefinitionElement(
   Element ele, String beanName, @Nullable BeanDefinition containingBean) {

  this.parseState.push(new BeanEntry(beanName));
    //è§£æclasså±æ€§
  String className = null;
  if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
   className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
  }
    //è§£æparentå±æ€§
  String parent = null;
  if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
   parent = ele.getAttribute(PARENT_ATTRIBUTE);
  }

  try {
    //ä½¿ç”¨classNameå’Œparentåˆ›å»ºä¸€ä¸ªç”¨äºæ‰¿è½½å„ç§å±æ€§çš„AbstractBeanDefinitionå®ä¾‹ bd
   AbstractBeanDefinition bd = createBeanDefinition(className, parent);
    //ç¡¬ç¼–ç è§£æé»˜è®¤beançš„å„ç§å±æ€§
   parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
    //æå–description
   bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));
    //è§£æå…ƒæ•°æ®
   parseMetaElements(ele, bd);
    //è§£ælookup-methodå±æ€§
   parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
    //è§£æreplace-methodå±æ€§
   parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

    //è§£ææ„é€ å‡½æ•°å‚æ•°
   parseConstructorArgElements(ele, bd);

    //è§£æpropertyå­å…ƒç´ 
   parsePropertyElements(ele, bd);

    //è§£æqualifiedå­å…ƒç´ 
   parseQualifierElements(ele, bd);

   bd.setResource(this.readerContext.getResource());
   bd.setSource(extractSource(ele));

   return bd;
  }
  catch (ClassNotFoundException ex) {
   error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);
  }
  catch (NoClassDefFoundError err) {
   error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);
  }
  catch (Throwable ex) {
   error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);
  }
  finally {
   this.parseState.pop();
  }

  return null;
 }
</code></pre>
<p>beanæ ‡ç­¾çš„æ‰€æœ‰å±æ€§ï¼Œä¸è®ºæ˜¯å¸¸ç”¨çš„è¿˜æ˜¯ä¸å¸¸ç”¨çš„æˆ‘ä»¬éƒ½æŒ‰åˆ°äº†ï¼Œå°½ç®¡æœ‰äº›å¤æ‚çš„å±æ€§éœ€è¦è¿›ä¸€æ­¥è§£æã€‚æ¥ä¸‹æ¥ä¸»è¦å°±æ˜¯çœ‹ä¸€äº›å¤æ‚æ ‡ç­¾å±æ€§çš„è§£æã€‚</p>
<h3 id="åˆ›å»ºç”¨äºå±æ€§æ‰¿è½½çš„beandefinitioncreatebeandefinition">åˆ›å»ºç”¨äºå±æ€§æ‰¿è½½çš„BeanDefinitionï¼ˆCreateBeanDefinitionï¼‰</h3>
<p>BeanDefinitionæ˜¯ä¸€ä¸ªæ¥å£ï¼Œåœ¨Springä¸­å­˜åœ¨ä¸‰ç§å®ç°ï¼šRootBeanDefinitionï¼ŒChildBeanDefinition,GenericBeanDefinitionã€‚ä¸‰ç§å®ç°æ–¹å¼å‡é›†æˆäº†AbstractBeanDefinitionï¼Œå…¶ä¸­BeanDefinitionæ˜¯é…ç½®æ–‡ä»¶<!-- raw HTML omitted -->å…ƒç´ æ ‡ç­¾çš„å†…éƒ¨è¡¨ç¤ºå½¢å¼ã€‚ï¼ˆ<!-- raw HTML omitted -->å…ƒç´ æ ‡ç­¾æ‹¥æœ‰classã€scopeã€lazy-initç­‰é…ç½®å±æ€§ï¼Œè€ŒBeanDefinitionå’‹æä¾›äº†ç›¸åº”çš„beanClassã€scopeã€LazyInitå±æ€§ï¼ŒBeanDefinitionå’Œ<!-- raw HTML omitted -->ä¸­çš„å±æ€§æ˜¯ä¸€ä¸€å¯¹åº”çš„ã€‚å…¶ä¸­RootBeanDefinitionæ˜¯æœ€å¸¸ç”¨çš„å®ç°ç±»ï¼‰ã€‚<br>
åœ¨é…ç½®æ–‡ä»¶ä¸­å¯ä»¥å®šä¹‰çˆ¶<!-- raw HTML omitted -->å’Œå­<!-- raw HTML omitted -->ï¼Œçˆ¶<!-- raw HTML omitted -->ä½¿ç”¨RootBeanDefinitionæ¥è¡¨ç¤ºï¼Œå­<!-- raw HTML omitted -->ä½¿ç”¨ChildBeanDefinitionæ¥è¡¨ç¤ºï¼Œè€Œæ²¡æœ‰çˆ¶<!-- raw HTML omitted -->çš„<!-- raw HTML omitted -->å°±ç”¨RootBeanDefinitionæ¥è¡¨ç¤ºã€‚AbstractBeanDefinitionå¯¹ä¸¤è€…å…±åŒçš„ç±»ä¿¡æ¯è¿›è¡ŒæŠ½è±¡ã€‚
Springé€šè¿‡BeanDefinitionå°†é…ç½®æ–‡ä»¶ä¸­çš„<!-- raw HTML omitted -->é…ç½®ä¿¡æ¯è½¬åŒ–ä¸ºå®¹å™¨çš„å†…éƒ¨è¡¨ç¤ºï¼Œç„¶åå°†è¿™äº›BeanDefinitionæ³¨å†Œåˆ°BeanDefinitionRegistryå½“ä¸­ã€‚</p>
<p><img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/%e3%80%8aSpring%e6%ba%90%e7%a0%81%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90%e3%80%8b%e8%af%bb%e5%90%8e%e6%84%9f%28%e4%ba%8c%29_files/64484741.png" alt="64484741.png"  /></p>
<p>è¦è§£æå±æ€§ï¼Œé¦–å…ˆè¦åˆ›å»ºç”¨äºæ‰¿è½½å±æ€§çš„å®ä¾‹ï¼Œä¹Ÿå°±æ˜¯åˆ›å»ºGenericBeanDefinitionç±»å‹çš„å®ä¾‹ï¼Œè€Œ  AbstractBeanDefinition bd = createBeanDefinition(className, parent);å°±æ˜¯å®ç°è¿™ä¸ªåŠŸèƒ½</p>
<pre><code>/**
  * Create a new GenericBeanDefinition for the given parent name and class name,
  * eagerly loading the bean class if a ClassLoader has been specified.
  * @param parentName the name of the parent bean, if any
  * @param className the name of the bean class, if any
  * @param classLoader the ClassLoader to use for loading bean classes
  * (can be {@code null} to just register bean classes by name)
  * @return the bean definition
  * @throws ClassNotFoundException if the bean class could not be loaded
  */
 public static AbstractBeanDefinition createBeanDefinition(
   @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {

  GenericBeanDefinition bd = new GenericBeanDefinition();
  bd.setParentName(parentName);
  if (className != null) {
   if (classLoader != null) {
    //å¦‚æœclassLoaderä¸ä¸ºç©ºï¼Œåˆ™ä½¿ç”¨ä»¥ä¼ å…¥çš„classLoaderåŒä¸€è™šæ‹ŸæœºåŠ è½½ç±»å¯¹è±¡ï¼Œå¦åˆ™åªæ˜¯è®°å½•ClassName
    bd.setBeanClass(ClassUtils.forName(className, classLoader));
   }
   else {
    bd.setBeanClassName(className);
   }
  }
  return bd;
 }
</code></pre>
<h3 id="è§£æå„ç§å±æ€§parsebeandefinitionattributesæ–¹æ³•">è§£æå„ç§å±æ€§(parseBeanDefinitionAttributesæ–¹æ³•)</h3>
<p>åœ¨ä¸Šä¸€æ­¥ï¼Œåˆ›å»ºäº†Beanä¿¡æ¯çš„æ‰¿è½½å®ä¾‹å­—åï¼Œå°±å¯ä»¥è¿›è¡Œbeanä¿¡æ¯çš„å„ç§å±æ€§çš„è§£æäº†ã€‚æˆ‘ä»¬è¿›å…¥åˆ°parseBeanDefinitionAttributesæ–¹æ³•ã€‚</p>
<pre><code>/**
  * Apply the attributes of the given bean element to the given bean * definition.
  * @param ele bean declaration element
  * @param beanName bean name
  * @param containingBean containing bean definition
  * @return a bean definition initialized according to the bean element attributes
  */
 public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
   @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {
    //åˆ¤æ–­æ˜¯å¦æ˜¯å•ä¾‹çš„å±æ€§ï¼Œå¦‚æœæœ‰çš„è¯éœ€è¦æŠ¥é”™
  if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {
   error(&quot;Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration&quot;, ele);
  }
    //è§£æscopeå±æ€§
  else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
   bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));
  }
  else if (containingBean != null) {
   // Take default from containing bean in case of an inner bean definition.
    //å¦‚æœåœ¨åµŒå…¥beanDefinitionæƒ…å†µä¸‹ä¸”æ²¡æœ‰å•ç‹¬åˆ¶å®šscopeå±æ€§çš„æ—¶å€™åˆ™ä½¿ç”¨çˆ¶ç±»é»˜è®¤çš„å±æ€§
   bd.setScope(containingBean.getScope());
  }
    //è§£æAbstractå±æ€§
  if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
   bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));
  }
    //è§£ælazy-Initå±æ€§
  String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);
  if (DEFAULT_VALUE.equals(lazyInit)) {
   lazyInit = this.defaults.getLazyInit();
  }
  bd.setLazyInit(TRUE_VALUE.equals(lazyInit));
    //è§£æautowireå±æ€§
  String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);
  bd.setAutowireMode(getAutowireMode(autowire));
    //è§£ædepend-onçš„å±æ€§
  if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
   String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);
   bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));
  }
    //è§£æautowireCandidateå±æ€§
  String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
  if (&quot;&quot;.equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {
   String candidatePattern = this.defaults.getAutowireCandidates();
   if (candidatePattern != null) {
    String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);
    bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));
   }
  }
  else {
   bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));
  }
    //è§£æprimaryå±æ€§
  if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
   bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));
  }
    //è§£æinit-methodå±æ€§
  if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
   String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);
   bd.setInitMethodName(initMethodName);
  }
  else if (this.defaults.getInitMethod() != null) {
   bd.setInitMethodName(this.defaults.getInitMethod());
   bd.setEnforceInitMethod(false);
  }
    //è§£ædestroy-methodå±æ€§
  if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
   String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);
   bd.setDestroyMethodName(destroyMethodName);
  }
  else if (this.defaults.getDestroyMethod() != null) {
   bd.setDestroyMethodName(this.defaults.getDestroyMethod());
   bd.setEnforceDestroyMethod(false);
  }
    //è§£æfactory-methodå±æ€§
  if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
   bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));
  }
    //è§£æfactory-beanå±æ€§
  if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
   bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));
  }
  return bd;
 }
</code></pre>
<p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªæ–¹æ³•å®Œæˆäº†å¯¹æ‰€æœ‰beanå±æ€§çš„è§£æã€‚</p>
<h3 id="è§£æå­å…ƒç´ meta">è§£æå­å…ƒç´ meta</h3>
<h4 id="metaå±æ€§çš„ä½¿ç”¨">metaå±æ€§çš„ä½¿ç”¨</h4>
<pre><code>&lt;bean id=&quot;myTestBean&quot; class=&quot;bean.myTestBean&quot;&gt;
ã€€ã€€&lt;meta key = &quot;testStr&quot; value = &quot;aaaaaaaaa&quot;&gt;
&lt;/bean&gt;
</code></pre>
<p>è¿™æ®µä»£ç å¹¶ä¸ä¼šä½“ç°åœ¨MyTestBeançš„å±æ€§å½“ä¸­ï¼Œè€Œæ˜¯ä¸€ä¸ªé¢å¤–çš„å£°æ˜ï¼Œå½“éœ€è¦ä½¿ç”¨é‡Œé¢çš„ä¿¡æ¯çš„æ—¶å€™å¯ä»¥é€šè¿‡BeanDefinitionçš„getAttribute(key)çš„æ–¹æ³•è·å–</p>
<h4 id="å¯¹metaå±æ€§çš„è§£æä»£ç å¦‚ä¸‹">å¯¹metaå±æ€§çš„è§£æä»£ç å¦‚ä¸‹</h4>
<pre><code>public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
    //è·å–å½“å‰èŠ‚ç‚¹
  NodeList nl = ele.getChildNodes();
  for (int i = 0; i &lt; nl.getLength(); i++) {
    //æå–meta
    Node node = nl.item(i);
    if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) {
      Element metaElement = (Element) node;
      String key = metaElement.getAttribute(KEY_ATTRIBUTE);
      String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
        //ä½¿ç”¨keyå’Œvalueæ„é€ BeanMetadataAttribute
      BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
      attribute.setSource(extractSource(metaElement));
        //è®°å½•ä¿¡æ¯
      attributeAccessor.addMetadataAttribute(attribute);
    }
  }
}
</code></pre>
<h3 id="è§£æå­å…ƒç´ lookup-method">è§£æå­å…ƒç´ lookup-method</h3>
<p>è¿™ä¸ªå±æ€§ä¸æ˜¯å¾ˆå¸¸ç”¨ï¼Œé€šå¸¸ç§°è¿™ä¸ªä¸ºè·å–å™¨æ³¨å…¥ã€‚ï¼ˆP44ï¼‰</p>
<h3 id="è§£æå­å…ƒç´ replaced-method">è§£æå­å…ƒç´ replaced-method</h3>
<p>æ–¹æ³•æ›¿æ¢ï¼šå¯ä»¥åœ¨è¿è¡Œæ—¶ç”¨æ–°çš„æ–¹æ³•æ›¿æ¢ç°æœ‰çš„æ–¹æ³•ã€‚replaced-methodä¸ä½†å¯ä»¥åŠ¨æ€è¿”å›å®ä½“beanï¼Œè€Œä¸”è¿˜èƒ½åŠ¨æ€åœ°æ›´æ”¹åŸæœ‰æ–¹æ³•çš„é€»è¾‘ã€‚ï¼ˆP46ï¼‰</p>
<h3 id="è§£æå­å…ƒç´ constructor-arg">è§£æå­å…ƒç´ constructor-arg</h3>
<p>å¯¹æ„é€ å‡½æ•°è¿›è¡Œçš„è§£æï¼ˆP48ï¼‰</p>
<h3 id="è§£æå­å…ƒç´ property">è§£æå­å…ƒç´ property</h3>
<p>p53</p>
<h3 id="è§£æå­å…ƒç´ qualifier">è§£æå­å…ƒç´ qualifier</h3>
<p>p54</p>
<h2 id="abstractbeandefinitionå±æ€§">AbstractBeanDefinitionå±æ€§</h2>
<p>è‡³æ­¤å®Œæˆäº†XMLæ–‡æ¡£åˆ°GenericBeanDefinitionçš„è½¬æ¢ã€‚ä½†æ˜¯Genericåªæ˜¯å­ç±»å®ç°ï¼Œå¤§éƒ¨åˆ†é€šç”¨çš„å±æ€§éƒ½æ˜¯ä¿å­˜åœ¨AbstractBeanDefinitionè¿™ä¸ªç±»ä¸­çš„ã€‚ä¸‹é¢æŸ¥çœ‹äº†ä¸€ä¸‹spring bootçš„AbstractBeanDefinition,å’Œä¹¦ä¸­çš„spring çš„å·®åˆ«è¿˜æ˜¯å¾ˆå¤§çš„</p>
<pre><code>/**
 * Base class for concrete, full-fledged {@link BeanDefinition} classes,
 * factoring out common properties of {@link GenericBeanDefinition},
 * {@link RootBeanDefinition}, and {@link ChildBeanDefinition}.
 *
 * &lt;p&gt;The autowire constants match the ones defined in the
 * {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory}
 * interface.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Rob Harrop
 * @author Mark Fisher
 * @see GenericBeanDefinition
 * @see RootBeanDefinition
 * @see ChildBeanDefinition
 */
@SuppressWarnings(&quot;serial&quot;)
public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor
        implements BeanDefinition, Cloneable {

    /**
     * Constant for the default scope name: {@code &quot;&quot;}, equivalent to singleton
     * status unless overridden from a parent bean definition (if applicable).
     */
    public static final String SCOPE_DEFAULT = &quot;&quot;;

    /**
     * Constant that indicates no autowiring at all.
     * @see #setAutowireMode
     */
    public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;

    /**
     * Constant that indicates autowiring bean properties by name.
     * @see #setAutowireMode
     */
    public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;

    /**
     * Constant that indicates autowiring bean properties by type.
     * @see #setAutowireMode
     */
    public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;

    /**
     * Constant that indicates autowiring a constructor.
     * @see #setAutowireMode
     */
    public static final int AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;

    /**
     * Constant that indicates determining an appropriate autowire strategy
     * through introspection of the bean class.
     * @see #setAutowireMode
     * @deprecated as of Spring 3.0: If you are using mixed autowiring strategies,
     * use annotation-based autowiring for clearer demarcation of autowiring needs.
     */
    @Deprecated
    public static final int AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;

    /**
     * Constant that indicates no dependency check at all.
     * @see #setDependencyCheck
     */
    public static final int DEPENDENCY_CHECK_NONE = 0;

    /**
     * Constant that indicates dependency checking for object references.
     * @see #setDependencyCheck
     */
    public static final int DEPENDENCY_CHECK_OBJECTS = 1;

    /**
     * Constant that indicates dependency checking for &quot;simple&quot; properties.
     * @see #setDependencyCheck
     * @see org.springframework.beans.BeanUtils#isSimpleProperty
     */
    public static final int DEPENDENCY_CHECK_SIMPLE = 2;

    /**
     * Constant that indicates dependency checking for all properties
     * (object references as well as &quot;simple&quot; properties).
     * @see #setDependencyCheck
     */
    public static final int DEPENDENCY_CHECK_ALL = 3;

    /**
     * Constant that indicates the container should attempt to infer the
     * {@link #setDestroyMethodName destroy method name} for a bean as opposed to
     * explicit specification of a method name. The value {@value} is specifically
     * designed to include characters otherwise illegal in a method name, ensuring
     * no possibility of collisions with legitimately named methods having the same
     * name.
     * &lt;p&gt;Currently, the method names detected during destroy method inference
     * are &quot;close&quot; and &quot;shutdown&quot;, if present on the specific bean class.
     */
    public static final String INFER_METHOD = &quot;(inferred)&quot;;


    @Nullable
    private volatile Object beanClass;
    //beançš„ä½œç”¨èŒƒå›´ï¼Œå¯¹åº”beanå±æ€§scope
    @Nullable
    private String scope = SCOPE_DEFAULT;

    private boolean abstractFlag = false;

    private boolean lazyInit = false;

    private int autowireMode = AUTOWIRE_NO;

    private int dependencyCheck = DEPENDENCY_CHECK_NONE;

    @Nullable
    private String[] dependsOn;

    private boolean autowireCandidate = true;

    private boolean primary = false;

    private final Map&lt;String, AutowireCandidateQualifier&gt; qualifiers = new LinkedHashMap&lt;&gt;(0);

    @Nullable
    private Supplier&lt;?&gt; instanceSupplier;

    private boolean nonPublicAccessAllowed = true;

    private boolean lenientConstructorResolution = true;

    @Nullable
    private String factoryBeanName;

    @Nullable
    private String factoryMethodName;

    @Nullable
    private ConstructorArgumentValues constructorArgumentValues;

    @Nullable
    private MutablePropertyValues propertyValues;

    @Nullable
    private MethodOverrides methodOverrides;

    @Nullable
    private String initMethodName;

    @Nullable
    private String destroyMethodName;

    private boolean enforceInitMethod = true;

    private boolean enforceDestroyMethod = true;

    private boolean synthetic = false;

    private int role = BeanDefinition.ROLE_APPLICATION;

    @Nullable
    private String description;

    @Nullable
    private Resource resource;


    /**
     * Create a new AbstractBeanDefinition with default settings.
     */
    protected AbstractBeanDefinition() {
        this(null, null);
    }

    /**
     * Create a new AbstractBeanDefinition with the given
     * constructor argument values and property values.
     */
    protected AbstractBeanDefinition(@Nullable ConstructorArgumentValues cargs, @Nullable MutablePropertyValues pvs) {
        this.constructorArgumentValues = cargs;
        this.propertyValues = pvs;
    }

    /**
     * Create a new AbstractBeanDefinition as a deep copy of the given
     * bean definition.
     * @param original the original bean definition to copy from
     */
    protected AbstractBeanDefinition(BeanDefinition original) {
        setParentName(original.getParentName());
        setBeanClassName(original.getBeanClassName());
        setScope(original.getScope());
        setAbstract(original.isAbstract());
        setLazyInit(original.isLazyInit());
        setFactoryBeanName(original.getFactoryBeanName());
        setFactoryMethodName(original.getFactoryMethodName());
        setRole(original.getRole());
        setSource(original.getSource());
        copyAttributesFrom(original);

        if (original instanceof AbstractBeanDefinition) {
            AbstractBeanDefinition originalAbd = (AbstractBeanDefinition) original;
            if (originalAbd.hasBeanClass()) {
                setBeanClass(originalAbd.getBeanClass());
            }
            if (originalAbd.hasConstructorArgumentValues()) {
                setConstructorArgumentValues(new ConstructorArgumentValues(original.getConstructorArgumentValues()));
            }
            if (originalAbd.hasPropertyValues()) {
                setPropertyValues(new MutablePropertyValues(original.getPropertyValues()));
            }
            if (originalAbd.hasMethodOverrides()) {
                setMethodOverrides(new MethodOverrides(originalAbd.getMethodOverrides()));
            }
            setAutowireMode(originalAbd.getAutowireMode());
            setDependencyCheck(originalAbd.getDependencyCheck());
            setDependsOn(originalAbd.getDependsOn());
            setAutowireCandidate(originalAbd.isAutowireCandidate());
            setPrimary(originalAbd.isPrimary());
            copyQualifiersFrom(originalAbd);
            setInstanceSupplier(originalAbd.getInstanceSupplier());
            setNonPublicAccessAllowed(originalAbd.isNonPublicAccessAllowed());
            setLenientConstructorResolution(originalAbd.isLenientConstructorResolution());
            setInitMethodName(originalAbd.getInitMethodName());
            setEnforceInitMethod(originalAbd.isEnforceInitMethod());
            setDestroyMethodName(originalAbd.getDestroyMethodName());
            setEnforceDestroyMethod(originalAbd.isEnforceDestroyMethod());
            setSynthetic(originalAbd.isSynthetic());
            setResource(originalAbd.getResource());
        }
        else {
            setConstructorArgumentValues(new ConstructorArgumentValues(original.getConstructorArgumentValues()));
            setPropertyValues(new MutablePropertyValues(original.getPropertyValues()));
            setResourceDescription(original.getResourceDescription());
        }
    }


    /**
     * Override settings in this bean definition (presumably a copied parent
     * from a parent-child inheritance relationship) from the given bean
     * definition (presumably the child).
     * &lt;ul&gt;
     * &lt;li&gt;Will override beanClass if specified in the given bean definition.
     * &lt;li&gt;Will always take {@code abstract}, {@code scope},
     * {@code lazyInit}, {@code autowireMode}, {@code dependencyCheck},
     * and {@code dependsOn} from the given bean definition.
     * &lt;li&gt;Will add {@code constructorArgumentValues}, {@code propertyValues},
     * {@code methodOverrides} from the given bean definition to existing ones.
     * &lt;li&gt;Will override {@code factoryBeanName}, {@code factoryMethodName},
     * {@code initMethodName}, and {@code destroyMethodName} if specified
     * in the given bean definition.
     * &lt;/ul&gt;
     */
    public void overrideFrom(BeanDefinition other) {
        if (StringUtils.hasLength(other.getBeanClassName())) {
            setBeanClassName(other.getBeanClassName());
        }
        if (StringUtils.hasLength(other.getScope())) {
            setScope(other.getScope());
        }
        setAbstract(other.isAbstract());
        setLazyInit(other.isLazyInit());
        if (StringUtils.hasLength(other.getFactoryBeanName())) {
            setFactoryBeanName(other.getFactoryBeanName());
        }
        if (StringUtils.hasLength(other.getFactoryMethodName())) {
            setFactoryMethodName(other.getFactoryMethodName());
        }
        setRole(other.getRole());
        setSource(other.getSource());
        copyAttributesFrom(other);

        if (other instanceof AbstractBeanDefinition) {
            AbstractBeanDefinition otherAbd = (AbstractBeanDefinition) other;
            if (otherAbd.hasBeanClass()) {
                setBeanClass(otherAbd.getBeanClass());
            }
            if (otherAbd.hasConstructorArgumentValues()) {
                getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues());
            }
            if (otherAbd.hasPropertyValues()) {
                getPropertyValues().addPropertyValues(other.getPropertyValues());
            }
            if (otherAbd.hasMethodOverrides()) {
                getMethodOverrides().addOverrides(otherAbd.getMethodOverrides());
            }
            setAutowireMode(otherAbd.getAutowireMode());
            setDependencyCheck(otherAbd.getDependencyCheck());
            setDependsOn(otherAbd.getDependsOn());
            setAutowireCandidate(otherAbd.isAutowireCandidate());
            setPrimary(otherAbd.isPrimary());
            copyQualifiersFrom(otherAbd);
            setInstanceSupplier(otherAbd.getInstanceSupplier());
            setNonPublicAccessAllowed(otherAbd.isNonPublicAccessAllowed());
            setLenientConstructorResolution(otherAbd.isLenientConstructorResolution());
            if (otherAbd.getInitMethodName() != null) {
                setInitMethodName(otherAbd.getInitMethodName());
                setEnforceInitMethod(otherAbd.isEnforceInitMethod());
            }
            if (otherAbd.getDestroyMethodName() != null) {
                setDestroyMethodName(otherAbd.getDestroyMethodName());
                setEnforceDestroyMethod(otherAbd.isEnforceDestroyMethod());
            }
            setSynthetic(otherAbd.isSynthetic());
            setResource(otherAbd.getResource());
        }
        else {
            getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues());
            getPropertyValues().addPropertyValues(other.getPropertyValues());
            setResourceDescription(other.getResourceDescription());
        }
    }

    /**
     * Apply the provided default values to this bean.
     * @param defaults the defaults to apply
     */
    public void applyDefaults(BeanDefinitionDefaults defaults) {
        setLazyInit(defaults.isLazyInit());
        setAutowireMode(defaults.getAutowireMode());
        setDependencyCheck(defaults.getDependencyCheck());
        setInitMethodName(defaults.getInitMethodName());
        setEnforceInitMethod(false);
        setDestroyMethodName(defaults.getDestroyMethodName());
        setEnforceDestroyMethod(false);
    }


    /**
     * Specify the bean class name of this bean definition.
     */
    @Override
    public void setBeanClassName(@Nullable String beanClassName) {
        this.beanClass = beanClassName;
    }

    /**
     * Return the current bean class name of this bean definition.
     */
    @Override
    @Nullable
    public String getBeanClassName() {
        Object beanClassObject = this.beanClass;
        if (beanClassObject instanceof Class) {
            return ((Class&lt;?&gt;) beanClassObject).getName();
        }
        else {
            return (String) beanClassObject;
        }
    }

    /**
     * Specify the class for this bean.
     */
    public void setBeanClass(@Nullable Class&lt;?&gt; beanClass) {
        this.beanClass = beanClass;
    }

    /**
     * Return the class of the wrapped bean, if already resolved.
     * @return the bean class, or {@code null} if none defined
     * @throws IllegalStateException if the bean definition does not define a bean class,
     * or a specified bean class name has not been resolved into an actual Class
     */
    public Class&lt;?&gt; getBeanClass() throws IllegalStateException {
        Object beanClassObject = this.beanClass;
        if (beanClassObject == null) {
            throw new IllegalStateException(&quot;No bean class specified on bean definition&quot;);
        }
        if (!(beanClassObject instanceof Class)) {
            throw new IllegalStateException(
                    &quot;Bean class name [&quot; + beanClassObject + &quot;] has not been resolved into an actual Class&quot;);
        }
        return (Class&lt;?&gt;) beanClassObject;
    }

    /**
     * Return whether this definition specifies a bean class.
     */
    public boolean hasBeanClass() {
        return (this.beanClass instanceof Class);
    }

    /**
     * Determine the class of the wrapped bean, resolving it from a
     * specified class name if necessary. Will also reload a specified
     * Class from its name when called with the bean class already resolved.
     * @param classLoader the ClassLoader to use for resolving a (potential) class name
     * @return the resolved bean class
     * @throws ClassNotFoundException if the class name could be resolved
     */
    @Nullable
    public Class&lt;?&gt; resolveBeanClass(@Nullable ClassLoader classLoader) throws ClassNotFoundException {
        String className = getBeanClassName();
        if (className == null) {
            return null;
        }
        Class&lt;?&gt; resolvedClass = ClassUtils.forName(className, classLoader);
        this.beanClass = resolvedClass;
        return resolvedClass;
    }

    /**
     * Set the name of the target scope for the bean.
     * &lt;p&gt;The default is singleton status, although this is only applied once
     * a bean definition becomes active in the containing factory. A bean
     * definition may eventually inherit its scope from a parent bean definition.
     * For this reason, the default scope name is an empty string (i.e., {@code &quot;&quot;}),
     * with singleton status being assumed until a resolved scope is set.
     * @see #SCOPE_SINGLETON
     * @see #SCOPE_PROTOTYPE
     */
    @Override
    public void setScope(@Nullable String scope) {
        this.scope = scope;
    }

    /**
     * Return the name of the target scope for the bean.
     */
    @Override
    @Nullable
    public String getScope() {
        return this.scope;
    }

    /**
     * Return whether this a &lt;b&gt;Singleton&lt;/b&gt;, with a single shared instance
     * returned from all calls.
     * @see #SCOPE_SINGLETON
     */
    @Override
    public boolean isSingleton() {
        return SCOPE_SINGLETON.equals(scope) || SCOPE_DEFAULT.equals(scope);
    }

    /**
     * Return whether this a &lt;b&gt;Prototype&lt;/b&gt;, with an independent instance
     * returned for each call.
     * @see #SCOPE_PROTOTYPE
     */
    @Override
    public boolean isPrototype() {
        return SCOPE_PROTOTYPE.equals(scope);
    }

    /**
     * Set if this bean is &quot;abstract&quot;, i.e. not meant to be instantiated itself but
     * rather just serving as parent for concrete child bean definitions.
     * &lt;p&gt;Default is &quot;false&quot;. Specify true to tell the bean factory to not try to
     * instantiate that particular bean in any case.
     */
    public void setAbstract(boolean abstractFlag) {
        this.abstractFlag = abstractFlag;
    }

    /**
     * Return whether this bean is &quot;abstract&quot;, i.e. not meant to be instantiated
     * itself but rather just serving as parent for concrete child bean definitions.
     */
    @Override
    public boolean isAbstract() {
        return this.abstractFlag;
    }

    /**
     * Set whether this bean should be lazily initialized.
     * &lt;p&gt;If {@code false}, the bean will get instantiated on startup by bean
     * factories that perform eager initialization of singletons.
     */
    @Override
    public void setLazyInit(boolean lazyInit) {
        this.lazyInit = lazyInit;
    }

    /**
     * Return whether this bean should be lazily initialized, i.e. not
     * eagerly instantiated on startup. Only applicable to a singleton bean.
     */
    @Override
    public boolean isLazyInit() {
        return this.lazyInit;
    }

    /**
     * Set the autowire mode. This determines whether any automagical detection
     * and setting of bean references will happen. Default is AUTOWIRE_NO,
     * which means there's no autowire.
     * @param autowireMode the autowire mode to set.
     * Must be one of the constants defined in this class.
     * @see #AUTOWIRE_NO
     * @see #AUTOWIRE_BY_NAME
     * @see #AUTOWIRE_BY_TYPE
     * @see #AUTOWIRE_CONSTRUCTOR
     * @see #AUTOWIRE_AUTODETECT
     */
    public void setAutowireMode(int autowireMode) {
        this.autowireMode = autowireMode;
    }

    /**
     * Return the autowire mode as specified in the bean definition.
     */
    public int getAutowireMode() {
        return this.autowireMode;
    }

    /**
     * Return the resolved autowire code,
     * (resolving AUTOWIRE_AUTODETECT to AUTOWIRE_CONSTRUCTOR or AUTOWIRE_BY_TYPE).
     * @see #AUTOWIRE_AUTODETECT
     * @see #AUTOWIRE_CONSTRUCTOR
     * @see #AUTOWIRE_BY_TYPE
     */
    public int getResolvedAutowireMode() {
        if (this.autowireMode == AUTOWIRE_AUTODETECT) {
            // Work out whether to apply setter autowiring or constructor autowiring.
            // If it has a no-arg constructor it's deemed to be setter autowiring,
            // otherwise we'll try constructor autowiring.
            Constructor&lt;?&gt;[] constructors = getBeanClass().getConstructors();
            for (Constructor&lt;?&gt; constructor : constructors) {
                if (constructor.getParameterCount() == 0) {
                    return AUTOWIRE_BY_TYPE;
                }
            }
            return AUTOWIRE_CONSTRUCTOR;
        }
        else {
            return this.autowireMode;
        }
    }

    /**
     * Set the dependency check code.
     * @param dependencyCheck the code to set.
     * Must be one of the four constants defined in this class.
     * @see #DEPENDENCY_CHECK_NONE
     * @see #DEPENDENCY_CHECK_OBJECTS
     * @see #DEPENDENCY_CHECK_SIMPLE
     * @see #DEPENDENCY_CHECK_ALL
     */
    public void setDependencyCheck(int dependencyCheck) {
        this.dependencyCheck = dependencyCheck;
    }

    /**
     * Return the dependency check code.
     */
    public int getDependencyCheck() {
        return this.dependencyCheck;
    }

    /**
     * Set the names of the beans that this bean depends on being initialized.
     * The bean factory will guarantee that these beans get initialized first.
     * &lt;p&gt;Note that dependencies are normally expressed through bean properties or
     * constructor arguments. This property should just be necessary for other kinds
     * of dependencies like statics (*ugh*) or database preparation on startup.
     */
    @Override
    public void setDependsOn(@Nullable String... dependsOn) {
        this.dependsOn = dependsOn;
    }

    /**
     * Return the bean names that this bean depends on.
     */
    @Override
    @Nullable
    public String[] getDependsOn() {
        return this.dependsOn;
    }

    /**
     * Set whether this bean is a candidate for getting autowired into some other bean.
     * &lt;p&gt;Note that this flag is designed to only affect type-based autowiring.
     * It does not affect explicit references by name, which will get resolved even
     * if the specified bean is not marked as an autowire candidate. As a consequence,
     * autowiring by name will nevertheless inject a bean if the name matches.
     * @see #AUTOWIRE_BY_TYPE
     * @see #AUTOWIRE_BY_NAME
     */
    @Override
    public void setAutowireCandidate(boolean autowireCandidate) {
        this.autowireCandidate = autowireCandidate;
    }

    /**
     * Return whether this bean is a candidate for getting autowired into some other bean.
     */
    @Override
    public boolean isAutowireCandidate() {
        return this.autowireCandidate;
    }

    /**
     * Set whether this bean is a primary autowire candidate.
     * &lt;p&gt;If this value is {@code true} for exactly one bean among multiple
     * matching candidates, it will serve as a tie-breaker.
     */
    @Override
    public void setPrimary(boolean primary) {
        this.primary = primary;
    }

    /**
     * Return whether this bean is a primary autowire candidate.
     */
    @Override
    public boolean isPrimary() {
        return this.primary;
    }

    /**
     * Register a qualifier to be used for autowire candidate resolution,
     * keyed by the qualifier's type name.
     * @see AutowireCandidateQualifier#getTypeName()
     */
    public void addQualifier(AutowireCandidateQualifier qualifier) {
        this.qualifiers.put(qualifier.getTypeName(), qualifier);
    }

    /**
     * Return whether this bean has the specified qualifier.
     */
    public boolean hasQualifier(String typeName) {
        return this.qualifiers.keySet().contains(typeName);
    }

    /**
     * Return the qualifier mapped to the provided type name.
     */
    @Nullable
    public AutowireCandidateQualifier getQualifier(String typeName) {
        return this.qualifiers.get(typeName);
    }

    /**
     * Return all registered qualifiers.
     * @return the Set of {@link AutowireCandidateQualifier} objects.
     */
    public Set&lt;AutowireCandidateQualifier&gt; getQualifiers() {
        return new LinkedHashSet&lt;&gt;(this.qualifiers.values());
    }

    /**
     * Copy the qualifiers from the supplied AbstractBeanDefinition to this bean definition.
     * @param source the AbstractBeanDefinition to copy from
     */
    public void copyQualifiersFrom(AbstractBeanDefinition source) {
        Assert.notNull(source, &quot;Source must not be null&quot;);
        this.qualifiers.putAll(source.qualifiers);
    }

    /**
     * Specify a callback for creating an instance of the bean,
     * as an alternative to a declaratively specified factory method.
     * &lt;p&gt;If such a callback is set, it will override any other constructor
     * or factory method metadata. However, bean property population and
     * potential annotation-driven injection will still apply as usual.
     * @since 5.0
     * @see #setConstructorArgumentValues(ConstructorArgumentValues)
     * @see #setPropertyValues(MutablePropertyValues)
     */
    public void setInstanceSupplier(@Nullable Supplier&lt;?&gt; instanceSupplier) {
        this.instanceSupplier = instanceSupplier;
    }

    /**
     * Return a callback for creating an instance of the bean, if any.
     * @since 5.0
     */
    @Nullable
    public Supplier&lt;?&gt; getInstanceSupplier() {
        return this.instanceSupplier;
    }

    /**
     * Specify whether to allow access to non-public constructors and methods,
     * for the case of externalized metadata pointing to those. The default is
     * {@code true}; switch this to {@code false} for public access only.
     * &lt;p&gt;This applies to constructor resolution, factory method resolution,
     * and also init/destroy methods. Bean property accessors have to be public
     * in any case and are not affected by this setting.
     * &lt;p&gt;Note that annotation-driven configuration will still access non-public
     * members as far as they have been annotated. This setting applies to
     * externalized metadata in this bean definition only.
     */
    public void setNonPublicAccessAllowed(boolean nonPublicAccessAllowed) {
        this.nonPublicAccessAllowed = nonPublicAccessAllowed;
    }

    /**
     * Return whether to allow access to non-public constructors and methods.
     */
    public boolean isNonPublicAccessAllowed() {
        return this.nonPublicAccessAllowed;
    }

    /**
     * Specify whether to resolve constructors in lenient mode ({@code true},
     * which is the default) or to switch to strict resolution (throwing an exception
     * in case of ambiguous constructors that all match when converting the arguments,
     * whereas lenient mode would use the one with the 'closest' type matches).
     */
    public void setLenientConstructorResolution(boolean lenientConstructorResolution) {
        this.lenientConstructorResolution = lenientConstructorResolution;
    }

    /**
     * Return whether to resolve constructors in lenient mode or in strict mode.
     */
    public boolean isLenientConstructorResolution() {
        return this.lenientConstructorResolution;
    }

    /**
     * Specify the factory bean to use, if any.
     * This the name of the bean to call the specified factory method on.
     * @see #setFactoryMethodName
     */
    @Override
    public void setFactoryBeanName(@Nullable String factoryBeanName) {
        this.factoryBeanName = factoryBeanName;
    }

    /**
     * Return the factory bean name, if any.
     */
    @Override
    @Nullable
    public String getFactoryBeanName() {
        return this.factoryBeanName;
    }

    /**
     * Specify a factory method, if any. This method will be invoked with
     * constructor arguments, or with no arguments if none are specified.
     * The method will be invoked on the specified factory bean, if any,
     * or otherwise as a static method on the local bean class.
     * @see #setFactoryBeanName
     * @see #setBeanClassName
     */
    @Override
    public void setFactoryMethodName(@Nullable String factoryMethodName) {
        this.factoryMethodName = factoryMethodName;
    }

    /**
     * Return a factory method, if any.
     */
    @Override
    @Nullable
    public String getFactoryMethodName() {
        return this.factoryMethodName;
    }

    /**
     * Specify constructor argument values for this bean.
     */
    public void setConstructorArgumentValues(ConstructorArgumentValues constructorArgumentValues) {
        this.constructorArgumentValues = constructorArgumentValues;
    }

    /**
     * Return constructor argument values for this bean (never {@code null}).
     */
    @Override
    public ConstructorArgumentValues getConstructorArgumentValues() {
        if (this.constructorArgumentValues == null) {
            this.constructorArgumentValues = new ConstructorArgumentValues();
        }
        return this.constructorArgumentValues;
    }

    /**
     * Return if there are constructor argument values defined for this bean.
     */
    @Override
    public boolean hasConstructorArgumentValues() {
        return (this.constructorArgumentValues != null &amp;&amp; !this.constructorArgumentValues.isEmpty());
    }

    /**
     * Specify property values for this bean, if any.
     */
    public void setPropertyValues(MutablePropertyValues propertyValues) {
        this.propertyValues = propertyValues;
    }

    /**
     * Return property values for this bean (never {@code null}).
     */
    @Override
    public MutablePropertyValues getPropertyValues() {
        if (this.propertyValues == null) {
            this.propertyValues = new MutablePropertyValues();
        }
        return this.propertyValues;
    }

    /**
     * Return if there are property values values defined for this bean.
     * @since 5.0.2
     */
    @Override
    public boolean hasPropertyValues() {
        return (this.propertyValues != null &amp;&amp; !this.propertyValues.isEmpty());
    }

    /**
     * Specify method overrides for the bean, if any.
     */
    public void setMethodOverrides(MethodOverrides methodOverrides) {
        this.methodOverrides = methodOverrides;
    }

    /**
     * Return information about methods to be overridden by the IoC
     * container. This will be empty if there are no method overrides.
     * &lt;p&gt;Never returns {@code null}.
     */
    public MethodOverrides getMethodOverrides() {
        if (this.methodOverrides == null) {
            this.methodOverrides = new MethodOverrides();
        }
        return this.methodOverrides;
    }

    /**
     * Return if there are method overrides defined for this bean.
     * @since 5.0.2
     */
    public boolean hasMethodOverrides() {
        return (this.methodOverrides != null &amp;&amp; !this.methodOverrides.isEmpty());
    }

    /**
     * Set the name of the initializer method.
     * &lt;p&gt;The default is {@code null} in which case there is no initializer method.
     */
    public void setInitMethodName(@Nullable String initMethodName) {
        this.initMethodName = initMethodName;
    }

    /**
     * Return the name of the initializer method.
     */
    @Nullable
    public String getInitMethodName() {
        return this.initMethodName;
    }

    /**
     * Specify whether or not the configured init method is the default.
     * &lt;p&gt;The default value is {@code false}.
     * @see #setInitMethodName
     */
    public void setEnforceInitMethod(boolean enforceInitMethod) {
        this.enforceInitMethod = enforceInitMethod;
    }

    /**
     * Indicate whether the configured init method is the default.
     * @see #getInitMethodName()
     */
    public boolean isEnforceInitMethod() {
        return this.enforceInitMethod;
    }

    /**
     * Set the name of the destroy method.
     * &lt;p&gt;The default is {@code null} in which case there is no destroy method.
     */
    public void setDestroyMethodName(@Nullable String destroyMethodName) {
        this.destroyMethodName = destroyMethodName;
    }

    /**
     * Return the name of the destroy method.
     */
    @Nullable
    public String getDestroyMethodName() {
        return this.destroyMethodName;
    }

    /**
     * Specify whether or not the configured destroy method is the default.
     * &lt;p&gt;The default value is {@code false}.
     * @see #setDestroyMethodName
     */
    public void setEnforceDestroyMethod(boolean enforceDestroyMethod) {
        this.enforceDestroyMethod = enforceDestroyMethod;
    }

    /**
     * Indicate whether the configured destroy method is the default.
     * @see #getDestroyMethodName
     */
    public boolean isEnforceDestroyMethod() {
        return this.enforceDestroyMethod;
    }

    /**
     * Set whether this bean definition is 'synthetic', that is, not defined
     * by the application itself (for example, an infrastructure bean such
     * as a helper for auto-proxying, created through {@code &lt;aop:config&gt;}).
     */
    public void setSynthetic(boolean synthetic) {
        this.synthetic = synthetic;
    }

    /**
     * Return whether this bean definition is 'synthetic', that is,
     * not defined by the application itself.
     */
    public boolean isSynthetic() {
        return this.synthetic;
    }

    /**
     * Set the role hint for this {@code BeanDefinition}.
     */
    public void setRole(int role) {
        this.role = role;
    }

    /**
     * Return the role hint for this {@code BeanDefinition}.
     */
    @Override
    public int getRole() {
        return this.role;
    }

    /**
     * Set a human-readable description of this bean definition.
     */
    public void setDescription(@Nullable String description) {
        this.description = description;
    }

    /**
     * Return a human-readable description of this bean definition.
     */
    @Override
    @Nullable
    public String getDescription() {
        return this.description;
    }

    /**
     * Set the resource that this bean definition came from
     * (for the purpose of showing context in case of errors).
     */
    public void setResource(@Nullable Resource resource) {
        this.resource = resource;
    }

    /**
     * Return the resource that this bean definition came from.
     */
    @Nullable
    public Resource getResource() {
        return this.resource;
    }

    /**
     * Set a description of the resource that this bean definition
     * came from (for the purpose of showing context in case of errors).
     */
    public void setResourceDescription(@Nullable String resourceDescription) {
        this.resource = (resourceDescription != null ? new DescriptiveResource(resourceDescription) : null);
    }

    /**
     * Return a description of the resource that this bean definition
     * came from (for the purpose of showing context in case of errors).
     */
    @Override
    @Nullable
    public String getResourceDescription() {
        return (this.resource != null ? this.resource.getDescription() : null);
    }

    /**
     * Set the originating (e.g. decorated) BeanDefinition, if any.
     */
    public void setOriginatingBeanDefinition(BeanDefinition originatingBd) {
        this.resource = new BeanDefinitionResource(originatingBd);
    }

    /**
     * Return the originating BeanDefinition, or {@code null} if none.
     * Allows for retrieving the decorated bean definition, if any.
     * &lt;p&gt;Note that this method returns the immediate originator. Iterate through the
     * originator chain to find the original BeanDefinition as defined by the user.
     */
    @Override
    @Nullable
    public BeanDefinition getOriginatingBeanDefinition() {
        return (this.resource instanceof BeanDefinitionResource ?
                ((BeanDefinitionResource) this.resource).getBeanDefinition() : null);
    }

    /**
     * Validate this bean definition.
     * @throws BeanDefinitionValidationException in case of validation failure
     */
    public void validate() throws BeanDefinitionValidationException {
        if (hasMethodOverrides() &amp;&amp; getFactoryMethodName() != null) {
            throw new BeanDefinitionValidationException(
                    &quot;Cannot combine static factory method with method overrides: &quot; +
                    &quot;the static factory method must create the instance&quot;);
        }

        if (hasBeanClass()) {
            prepareMethodOverrides();
        }
    }

    /**
     * Validate and prepare the method overrides defined for this bean.
     * Checks for existence of a method with the specified name.
     * @throws BeanDefinitionValidationException in case of validation failure
     */
    public void prepareMethodOverrides() throws BeanDefinitionValidationException {
        // Check that lookup methods exists.
        if (hasMethodOverrides()) {
            Set&lt;MethodOverride&gt; overrides = getMethodOverrides().getOverrides();
            synchronized (overrides) {
                for (MethodOverride mo : overrides) {
                    prepareMethodOverride(mo);
                }
            }
        }
    }

    /**
     * Validate and prepare the given method override.
     * Checks for existence of a method with the specified name,
     * marking it as not overloaded if none found.
     * @param mo the MethodOverride object to validate
     * @throws BeanDefinitionValidationException in case of validation failure
     */
    protected void prepareMethodOverride(MethodOverride mo) throws BeanDefinitionValidationException {
        int count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());
        if (count == 0) {
            throw new BeanDefinitionValidationException(
                    &quot;Invalid method override: no method with name '&quot; + mo.getMethodName() +
                    &quot;' on class [&quot; + getBeanClassName() + &quot;]&quot;);
        }
        else if (count == 1) {
            // Mark override as not overloaded, to avoid the overhead of arg type checking.
            mo.setOverloaded(false);
        }
    }


    /**
     * Public declaration of Object's {@code clone()} method.
     * Delegates to {@link #cloneBeanDefinition()}.
     * @see Object#clone()
     */
    @Override
    public Object clone() {
        return cloneBeanDefinition();
    }

    /**
     * Clone this bean definition.
     * To be implemented by concrete subclasses.
     * @return the cloned bean definition object
     */
    public abstract AbstractBeanDefinition cloneBeanDefinition();

    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (!(other instanceof AbstractBeanDefinition)) {
            return false;
        }

        AbstractBeanDefinition that = (AbstractBeanDefinition) other;

        if (!ObjectUtils.nullSafeEquals(getBeanClassName(), that.getBeanClassName())) return false;
        if (!ObjectUtils.nullSafeEquals(this.scope, that.scope)) return false;
        if (this.abstractFlag != that.abstractFlag) return false;
        if (this.lazyInit != that.lazyInit) return false;

        if (this.autowireMode != that.autowireMode) return false;
        if (this.dependencyCheck != that.dependencyCheck) return false;
        if (!Arrays.equals(this.dependsOn, that.dependsOn)) return false;
        if (this.autowireCandidate != that.autowireCandidate) return false;
        if (!ObjectUtils.nullSafeEquals(this.qualifiers, that.qualifiers)) return false;
        if (this.primary != that.primary) return false;

        if (this.nonPublicAccessAllowed != that.nonPublicAccessAllowed) return false;
        if (this.lenientConstructorResolution != that.lenientConstructorResolution) return false;
        if (!ObjectUtils.nullSafeEquals(this.constructorArgumentValues, that.constructorArgumentValues)) return false;
        if (!ObjectUtils.nullSafeEquals(this.propertyValues, that.propertyValues)) return false;
        if (!ObjectUtils.nullSafeEquals(this.methodOverrides, that.methodOverrides)) return false;

        if (!ObjectUtils.nullSafeEquals(this.factoryBeanName, that.factoryBeanName)) return false;
        if (!ObjectUtils.nullSafeEquals(this.factoryMethodName, that.factoryMethodName)) return false;
        if (!ObjectUtils.nullSafeEquals(this.initMethodName, that.initMethodName)) return false;
        if (this.enforceInitMethod != that.enforceInitMethod) return false;
        if (!ObjectUtils.nullSafeEquals(this.destroyMethodName, that.destroyMethodName)) return false;
        if (this.enforceDestroyMethod != that.enforceDestroyMethod) return false;

        if (this.synthetic != that.synthetic) return false;
        if (this.role != that.role) return false;

        return super.equals(other);
    }

    @Override
    public int hashCode() {
        int hashCode = ObjectUtils.nullSafeHashCode(getBeanClassName());
        hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.scope);
        hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.constructorArgumentValues);
        hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.propertyValues);
        hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.factoryBeanName);
        hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.factoryMethodName);
        hashCode = 29 * hashCode + super.hashCode();
        return hashCode;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder(&quot;class [&quot;);
        sb.append(getBeanClassName()).append(&quot;]&quot;);
        sb.append(&quot;; scope=&quot;).append(this.scope);
        sb.append(&quot;; abstract=&quot;).append(this.abstractFlag);
        sb.append(&quot;; lazyInit=&quot;).append(this.lazyInit);
        sb.append(&quot;; autowireMode=&quot;).append(this.autowireMode);
        sb.append(&quot;; dependencyCheck=&quot;).append(this.dependencyCheck);
        sb.append(&quot;; autowireCandidate=&quot;).append(this.autowireCandidate);
        sb.append(&quot;; primary=&quot;).append(this.primary);
        sb.append(&quot;; factoryBeanName=&quot;).append(this.factoryBeanName);
        sb.append(&quot;; factoryMethodName=&quot;).append(this.factoryMethodName);
        sb.append(&quot;; initMethodName=&quot;).append(this.initMethodName);
        sb.append(&quot;; destroyMethodName=&quot;).append(this.destroyMethodName);
        if (this.resource != null) {
            sb.append(&quot;; defined in &quot;).append(this.resource.getDescription());
        }
        return sb.toString();
    }

}
</code></pre>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/spring/">Spring</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
</article>

     
        
    


<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script>
    const gitalk = new Gitalk({
        clientID: 'aaf5fc3a72ea9ce81d62',
        clientSecret: '7792527b47af3239ddbc2274fb5fd141c28d8339',
        repo: 'ymkNK.github.io',
        owner: 'ymkNK',
        admin: ['ymkNK'],
        id: window.location.pathname,
        title: document.title,
        distractionFreeMode: true
    })

    gitalk.render('gitalk-container')
</script>




    

    <footer class="site-footer">
    <section class="copyright">
        
        2018 -
        
        2021
        &copy;
        lllovol
    </section>
    
    <section class="powerby">
        
            <b><a href="https://github.com/ymkNK" target="_blank" rel="noopener" data-version="%s">Owner Rainbowly </a></b> <br/>
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.3.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>

    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
