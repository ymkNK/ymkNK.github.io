<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Spring on lllovol</title>
        <link>https://lllovol.com/tags/spring/</link>
        <description>Recent content in Spring on lllovol</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Mon, 27 Jul 2020 15:51:33 +0000</lastBuildDate><atom:link href="https://lllovol.com/tags/spring/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>SpringBoot开发中的一些小细节(十四）事件监听的使用</title>
        <link>https://lllovol.com/p/spring14/</link>
        <pubDate>Mon, 27 Jul 2020 15:51:33 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring14/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(十四）事件监听的使用" /&gt;&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近在做同步先关的工作，为了提升同步任务的处理效率，减少频繁的mongo数据库查询，因此需要将一些数据统一查询出来，在内存中进行处理。&lt;/p&gt;
&lt;h2 id=&#34;解决方式&#34;&gt;解决方式&lt;/h2&gt;
&lt;p&gt;在任务执行的之前，就需要将相关的数据查询出来，如何实现呢？使用一个&lt;code&gt;@EventListener&lt;/code&gt;进行ApplicationReadyEvent时间的监听，就能在应用启动之后，进行相应的操作&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@EventListener(classes = {ApplicationReadyEvent.class})
public void initialMap() {
    if (CollectionUtils.isEmpty(ridMobileMap)) {
        List&amp;lt;UserRecord&amp;gt; all = entranceUserRecordRepo.findAll();
        ridMobileMap = all.stream().filter(userRecord -&amp;gt; StringUtils.isNotEmpty(userRecord.getMobileNo())).collect(Collectors.toMap(UserRecord::getRid, UserRecord::getMobileNo));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;more&#34;&gt;More&lt;/h2&gt;
&lt;h3 id=&#34;application&#34;&gt;Application&lt;/h3&gt;
&lt;p&gt;spring application，一般就是spring boot项目中的 &lt;code&gt;Application&lt;/code&gt;这个类&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@SpringBootApplication
@EnableConfigurationProperties
@EnableAutoConfiguration(exclude = {DruidDataSourceAutoConfigure.class, DataSourceAutoConfiguration.class, RedisAutoConfiguration.class})
@EnableScheduling
@EnableFeignClients(basePackages = {&amp;#34;&amp;#34;})
@EnableAspectJAutoProxy(proxyTargetClass = true)
@EnableCircuitBreaker
@EnableLdapRepositories
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Bean
    LdapTemplate getLdapTemplate(ContextSource contextSource) {
        LdapTemplate ldapTemplate = new LdapTemplate(contextSource);
        ldapTemplate.setIgnorePartialResultException(true);
        return ldapTemplate;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个当中，我们可以设置很多配置，比如排除掉一些自动配置、设置feignClient的扫描路径等等操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/130309481&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring Boot详细生命周期介绍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;自定义事件和监听&#34;&gt;自定义事件和监听&lt;/h3&gt;
&lt;p&gt;在不同的Service当中的时候，两个service的职责差别很大，但是A会调用B的方法，或者在A中个别服务完成之后，我们需要通知B中的个别方法开始执行。（观察者模式的一种实现）&lt;/p&gt;
&lt;p&gt;自定义event&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class ObjectALifecycleEvent extends ApplicationEvent {

    private ObjectA objectA;

    /**
     * Create a new ApplicationEvent.
     *
     * @param source the object on which the event initially occurred (never {@code null})
     */
    public ObjectALifecycleEvent(Object source) {
        super(source);
        if (source instanceof ObjectA) {
            this.objectA = (ObjectA) source;
        }
    }

    public ObjectA getObjectA() {
        return objectA;
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自定义listener&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
@Component
@Slf4j
@Data
public class PolicyUpdater implements ApplicationListener&amp;lt;ObjectALifecycleEvent&amp;gt; {

 
    @Override
    public void onApplicationEvent(@NotNull ObjectALifecycleEvent event) {
        if (event instanceof ObjectABeforeScheduleEvent) {
            updatePolicyBeforeTaskSchedule((ObjectABeforeScheduleEvent) event);
        }
        if (event instanceof ObjectAFinishEvent) {
            updatePolicyWhenTaskFinish((ObjectAFinishEvent) event);
        }
    }
    
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>单例模式的实现方式</title>
        <link>https://lllovol.com/p/singleton-realization/</link>
        <pubDate>Sat, 04 Jul 2020 00:34:38 +0000</pubDate>
        
        <guid>https://lllovol.com/p/singleton-realization/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg" alt="Featured image of post 单例模式的实现方式" /&gt;&lt;h2 id=&#34;什么是单例模式&#34;&gt;什么是单例模式？&lt;/h2&gt;
&lt;p&gt;在整个程序运行过程中只会实现一次的对象，例如Runtime类。&lt;br&gt;
需要满足的条件有以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造器私有化&lt;/li&gt;
&lt;li&gt;自行创建，并且用静态变量保存&lt;/li&gt;
&lt;li&gt;向外提供这种实例&lt;/li&gt;
&lt;li&gt;为了强调这是单例模式，我们可以使用final修饰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见形式&#34;&gt;常见形式&lt;/h2&gt;
&lt;h3 id=&#34;饿汉式&#34;&gt;饿汉式&lt;/h3&gt;
&lt;p&gt;懒汉式就是直接就实例化了，在程序运行的时候，直接创建，不管是否需要这个对象.不存在线程安全问题&lt;/p&gt;
&lt;h4 id=&#34;饿汉式-直接实例化饿汉式&#34;&gt;饿汉式-直接实例化饿汉式&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-$xslt&#34; data-lang=&#34;$xslt&#34;&gt;public class Singleton(){
    public static final INSTANCE=new Singleton();
    private Singleton(){
        // 构造器私有化
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;饿汉式-枚举式&#34;&gt;饿汉式-枚举式&lt;/h4&gt;
&lt;p&gt;和上面的效果一模一样&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-$xslt&#34; data-lang=&#34;$xslt&#34;&gt;public enum Singleton(){
    INSTANCE,
    ;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;静态代码块饿汉式&#34;&gt;静态代码块饿汉式&lt;/h4&gt;
&lt;p&gt;这种情况和第一种效果也是一样的，但是如果需要配置的话，就需要使用这种方式了&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-$xslt&#34; data-lang=&#34;$xslt&#34;&gt;public class Singleton(){
    public static final INSTANCE;
    private String info;
    static {
        Properties pro=new Properties();
        pro.load( Singleton.class.getClassLoader().getResourceAsStream(&amp;#34;src/下面的资源文件&amp;#34;))
        INSTANCE=new Singleton(pro.getProperty(&amp;#34;info&amp;#34;));
    }

    private Singleton(String info){
        this.info=info;
        // 构造器私有化
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;懒汉式&#34;&gt;懒汉式&lt;/h3&gt;
&lt;p&gt;延迟创建，在需要的时候才创建对象&lt;/p&gt;
&lt;h4 id=&#34;线程不安全的懒汉式&#34;&gt;线程不安全的懒汉式&lt;/h4&gt;
&lt;p&gt;这种情况就是会有线程安全的问题&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-$xslt&#34; data-lang=&#34;$xslt&#34;&gt;public class Singleton(){
    private static final INSTANCE;
    private Singleton(){
        // 构造器私有化
    }
    public Singleton getInstance(){
        if(null==INSTANCE){
            INSTANCE=new Singleton();
        }
        return INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;线程安全的懒汉式&#34;&gt;线程安全的懒汉式&lt;/h4&gt;
&lt;p&gt;加上锁，保证多线程的时候，不会有问题&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-$xslt&#34; data-lang=&#34;$xslt&#34;&gt;public class Singleton(){
    private static final INSTANCE;
    private Singleton(){
        // 构造器私有化
    }
    public Singleton getInstance(){
        if(null==INSTANCE){
            synchronized(Singleton.class){
                INSTANCE=new Singleton();
            }
        }
        return INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;静态内部类形式适用于多线程&#34;&gt;静态内部类形式（适用于多线程）&lt;/h4&gt;
&lt;p&gt;静态内部类只有在被使用的时候，才会开始实例化。因此这个也将是线程安全的，并且只有再被需要的时候才会被加载&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-$xslt&#34; data-lang=&#34;$xslt&#34;&gt;public class Singleton{
    
    private Singleton(){
        // 构造器私有化
    }

    private static class Inner{
        private static final INSTANCE=new Singleton();
    }
    public Singleton getInstance(){
       return Inner.INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节（十三）使用AOP实现权限系统</title>
        <link>https://lllovol.com/p/spring13/</link>
        <pubDate>Tue, 12 May 2020 15:04:26 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring13/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/3.jpg" alt="Featured image of post SpringBoot开发中的一些小细节（十三）使用AOP实现权限系统" /&gt;&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近在做一个小工具的权限控制系统，由于是第一次做这方面的工作，而且对权限的控制会非常的详细，比如，需要细致到对每一个对象的控制。在前期有一些调研。&lt;/p&gt;
&lt;h2 id=&#34;想法&#34;&gt;想法&lt;/h2&gt;
&lt;p&gt;我大概实现的思路和设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建实体类，实现相应的数据存储化，用户可以设置相应的权限策略。权限设置，换一个说法就是主谓宾&amp;ndash;&amp;ldquo;谁&amp;rdquo; &amp;ldquo;能看/不能看&amp;rdquo; &amp;ldquo;什么东西&amp;rdquo;。将这个权限设置抽象为对象，并进行存储。&lt;/li&gt;
&lt;li&gt;根据实体类解析用户保存的策略，使之生效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说起来简单，做起来难。第一点设置权限，其实就是非常简单的单表查询维护。难点在于第二点，如何能让这个策略生效。按照我目前接触和掌握到的技术手段，主要的解决方式有下面几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写一个intercepor，拦截器。但是这个方式，只能处理请求的控制器和方法，控制不了具体的参数。这一点比较适合用来做整体的系统权限拦截，拦截接口。拦截控制的粒度比较粗糙。&lt;/li&gt;
&lt;li&gt;在每一个业务逻辑中，分别添加拦截的逻辑，即每一个返回对象的接口，都需要查询和判断权限表。优点：思路简单。缺点：可维护性差，写完第一次之后，再维护就是噩梦。&lt;/li&gt;
&lt;li&gt;使用Aspect，可以自定义切入的点，甚至能细化到拦截什么包什么类的什么方法等等。Perfectly，就是他了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了上面的Interceptor和Aspect，还有filter。这三者实际上都是对Aop的具体实现，都可以实现权限检查，日志记录等等的功能。都是对业务逻辑的提取，不同的是，使用的范围
规范、和深度不同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/11382761-484d129572258d9c.png?imageMogr2/auto-orient/strip%7cimageView2/2/w/1200/format/webp&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;执行顺序&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/c4ef6d232e8d&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Filter、Interceptor、Aop实现与区别&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;由于包含工作的涉密内容，真实实现的代码就不在此展示。而网上的Demo已经相当丰富。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.im/post/5c47e4b26fb9a049b50726d8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SpringBooot AOP的使用&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中实现权限控制的最简单的demo就是如下的代码&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Aspect
@Component
@RequiredArgsConstructor
@Slf4j
public class AuthAspect {

   
    @Pointcut(&amp;#34;execution(public * com.company.group.auth.service.AuthService.list(..))&amp;#34;)
    public void pointCutForListObjective() {
    }
    
    /**
     * 对list的方法返回值进行拦截处理
     */
    @AfterReturning(pointcut = &amp;#34;pointCutForListObjective()&amp;#34;, returning = &amp;#34;okrResponses&amp;#34;)
    public void afterReturningListObjective(JoinPoint joinPoint, Object okrResponses) {
        // 这个地方就能够对返回值直接进行处理
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;定义切点pointCut(),这个地方，就是定义一个我们需要切入的点，我们要进行拦截处理的地方。&lt;/li&gt;
&lt;li&gt;对这个切点有很多处理的方式，实现真正的权限拦截控制逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;其他的点&#34;&gt;其他的点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;对于用户的组织权限的控制，我们可以使用路径的方式来进行判断，类似于一个树，我们每一次，存储的时候，需要将用户所在的组织架构的路径进行存储。这样我们在进行权限判断的时候，就不想要每一次都从库中获取用户的组织架构信息了。&lt;/li&gt;
&lt;li&gt;对于model的校验可以写注解来进行实现。这一点，以后会专门写一篇文章来进行分享&lt;/li&gt;
&lt;li&gt;Npe问题可谓是开发过程中的一生之敌。在循环迭代过程中，不可以一遍迭代，一边删除list中的值。&lt;/li&gt;
&lt;li&gt;使用JPA的时候可以使用 pageable 来直接进行分页，不用再写mongoTemplate这种CustomRepo&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  @Override
    public List&amp;lt;Department&amp;gt; listAuthDepartment(String departmentName) {
        if (Strings.isEmpty(departmentName)) {
            return Lists.newArrayList();
        }
        Sort sort = new Sort(Sort.Direction.DESC, &amp;#34;name&amp;#34;);  
        Pageable pageable = PageRequest.of( 0, 20, sort); // （当前页， 每页记录数， 排序方式）
        return  departmentRepo.findAllByNameIsLike(departmentName, pageable);
    }
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节（十二）单元测试</title>
        <link>https://lllovol.com/p/spring12/</link>
        <pubDate>Fri, 10 Jan 2020 19:07:19 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring12/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg" alt="Featured image of post SpringBoot开发中的一些小细节（十二）单元测试" /&gt;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;2020将近，已经很久没有更新blog，但是每天的工作笔记都还是有在记录，趁着马上就要过年，没有那么忙碌了，把自己19年Q4的工作中遇到的问题以及一些有用的方法整理一下~&lt;/p&gt;
&lt;h2 id=&#34;测试的必要性&#34;&gt;测试的必要性&lt;/h2&gt;
&lt;p&gt;在程序员的日常工作中，实际上真正在编写代码的时间，在整个工作时间中所占的比例其实很小的一部分。在写代码之前我们需要撰写需求文档，以及充足的思考，画出uml图（虽然很多经验丰富的大佬都没有画，但是那是建立在经验相当丰富的基础之上的）；在写完代码之后，这个项目需要发布与部署到测试环境，这就是CI/CD所负责的部分了；再之后，我们就需要测试我们的项目，是否能够完成需求文档中的需求，实现了相应的功能。 如果没有进行充分完整的测试，直接上线，这个项目差不多就是穿着皇帝的新衣在大街上到处晃荡了。同样，在互联网高速发展的今天，测试也不再仅仅是人工进行测试，自动化测试的演进又再一次的提升了团队的生产效率。这和敏捷开发、持续集成、持续部署、DevOps是一脉相承的。&lt;/p&gt;
&lt;h2 id=&#34;测试金字塔test-pyramid&#34;&gt;测试金字塔Test Pyramid&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://insights.thoughtworks.cn/wp-content/uploads/2018/10/3.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;测试金字塔&#34;
	
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://insights.thoughtworks.cn/practical-test-pyramid/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;图来源于ThoughtWorks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上方的金字塔当中，越往金字塔尖尖方向的，集成的程度越高，测试所耗费的时间就越长，但是需要的测试数目并没有那么多；与之相反，越往金字塔底层方向的，集成的程度就越低，测试所消耗的时间也更快，但是所需要测试的数量就会更加的庞大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UI Tests 项目的ui界面测试，这一层面的测试比较适合在上线之后进行冒烟测试，能够知道项目的整个流程到底是不是有问题。但是通常由于集成的程度太高，不能很快的定位问题。&lt;/li&gt;
&lt;li&gt;Service Tests 这一层，用来测试服务是否可用，比如API测试。&lt;/li&gt;
&lt;li&gt;Unit Tests 在代码层面进行测试，通常可以针对某一个类，某一个方法进行测试，能够快速定位问题。这个层级的层级能够保证一个系统的每一个基石都能够按照预期的那样进行工作。单元测试的数量应该在测试组合中远远多于其他类型的测试。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;junit&#34;&gt;Junit&lt;/h2&gt;
&lt;h3 id=&#34;三段式结构&#34;&gt;三段式结构&lt;/h3&gt;
&lt;p&gt;我们通常采用三段式的结构来撰写单元测试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造部分。进行对象的构建、赋值等。&lt;/li&gt;
&lt;li&gt;逻辑部分。运行方法逻辑对第一部分的数据对象进行运算。&lt;/li&gt;
&lt;li&gt;断言部分。判断本次单元测试能否通过。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实例代码&#34;&gt;实例代码&lt;/h3&gt;
&lt;p&gt;要使用is（）方法首先需要导入hamcrest-library-1.3.jar和hamcrest-core-1.3.jar两个jar包&lt;/p&gt;
&lt;p&gt;依赖配置：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.hamcrest&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hamcrest-library&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;简单的UT代码实现&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;


@RunWith(SpringRunner.class)
@SpringBootTest
@Slf4j
public class ApplicationTests {
    
    @Test
    @Ignore
    public void contextLoads() {
    }

    public Boolean compare(String A, String B) {
        return A.equals(B);
    }

    @Test
    public void testCompare() {
        // 第一段
    	var tempParamA = &amp;#34;1&amp;#34;;
        var tempParamB = &amp;#34;2&amp;#34;;

        // 第二段
        var result = compare(tempParamA, tempParamB);

        // 第三段
		assertThat( result, is(false));
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码的意思是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义两个参数AB&lt;/li&gt;
&lt;li&gt;使用compare方法对两个参数进行比较&lt;/li&gt;
&lt;li&gt;断言，如果result是false，那么本次UT通过&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;其他需要注意的地方&#34;&gt;其他需要注意的地方&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通常在进行打包的时候，一般是会跳过这个打包阶段的&lt;code&gt;mvn clean package -DskipTests&lt;/code&gt;，当然如果我们想要执行单元测试，那么直接&lt;code&gt;mvn clean package&lt;/code&gt;这样就是ok的。&lt;/li&gt;
&lt;li&gt;在写单元测试的时候，我们需要将语义表达清楚，尤其是在写单元测试名字的时候，还有在写断言的时候，需要直接就是英文的一句具有完整语义的句子，这样在后期维护的时候会很方便，可以一眼就知道这是干什么的。&lt;/li&gt;
&lt;li&gt;在不想跑的Test上面加上&lt;code&gt;@Ignore&lt;/code&gt;就可以不执行我们不需要的依赖等等，因此我们最好就是使用充血模型，在每个model中最好就有本类能做到的相关功能的方法实现。（贫血模型，通常就是简单的POJO，主要的功能方法都是在Service等外界实现的）&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>从零开始搭建AD信息同步的项目</title>
        <link>https://lllovol.com/p/synchronize-job/</link>
        <pubDate>Mon, 23 Sep 2019 17:12:49 +0000</pubDate>
        
        <guid>https://lllovol.com/p/synchronize-job/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/5.jpg" alt="Featured image of post 从零开始搭建AD信息同步的项目" /&gt;&lt;h2 id=&#34;一-前言&#34;&gt;一 前言&lt;/h2&gt;
&lt;p&gt;最近独自完成了一个同步信息的项目，主要工作内容是从第三方的服务端将信息同步到公司的二方AD域当中。本文主要记录本项目的主要实现过程。&lt;/p&gt;
&lt;h2 id=&#34;二-项目设计&#34;&gt;二 项目设计&lt;/h2&gt;
&lt;p&gt;这是一个并不复杂的项目，因此项目主要涉及到两大部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从第三方服务器端获取到信息数据&lt;/li&gt;
&lt;li&gt;将信息数据进行处理，能够存入到公司的二方AD域当中&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;三-第三方数据获取&#34;&gt;三 第三方数据获取&lt;/h2&gt;
&lt;h3 id=&#34;1主要技术&#34;&gt;1.主要技术&lt;/h3&gt;
&lt;p&gt;本项目主要获取信息的方式，是通过FeignClient来获取的&lt;/p&gt;
&lt;h3 id=&#34;2主要实现&#34;&gt;2.主要实现&lt;/h3&gt;
&lt;h4 id=&#34;a最单纯的feign方式实现&#34;&gt;a.最单纯的feign方式实现&lt;/h4&gt;
&lt;h5 id=&#34;添加pom依赖&#34;&gt;添加pom依赖&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;feign-okhttp&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;10.1.0&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;feign-jackson&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;10.1.0&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;定义接收返回值所用到的model对象&#34;&gt;定义接收返回值所用到的model对象&lt;/h5&gt;
&lt;p&gt;这个地方的model定义，需要仔细阅读第三方服务端的api文档，然后根据上面的具体信息来进行定义&lt;br&gt;
eg:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Data
public class XxxApiResponse {
    private String code;
    private String message;
    private String timestamp;
    private String errcode;
    private String errmsg;
    private String detailMsg;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的变量名没有按照驼峰的方式进行定义，是因为官方文档返回值当中的字段key值就是这样非驼峰的方式，我们需要保证名字的一致性。&lt;/p&gt;
&lt;h5 id=&#34;定义feign&#34;&gt;定义Feign&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public interface XxxClient {

    @RequestLine(&amp;#34;GET /v3/xxx/details?param1={param1}&amp;#34;)
    XxxDetailsResponse getXxxDetails(@Param(&amp;#34;param1&amp;#34;) String param1);

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意这种RequestLine的方式和GetMapping和PostMapping的方式有所区别&lt;/p&gt;
&lt;h5 id=&#34;定义feign的factory&#34;&gt;定义Feign的Factory&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public class XxxClientFactory {
    private final static String URL = &amp;#34;https://api.xxx.com&amp;#34;;

    public XxxClient createXxxClient() {
        ObjectMapper mapper = new ObjectMapper()
                .setSerializationInclusion(JsonInclude.Include.NON_NULL)
                .setPropertyNamingStrategy(PropertyNamingStrategy.SNAKE_CASE)
                .configure(SerializationFeature.INDENT_OUTPUT, true)
                .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        return Feign.builder()
                .logger(new Slf4jLogger())
                .client(new OkHttpClient())
                .encoder(new FormEncoder(new JacksonEncoder(mapper)))
                .decoder(new JacksonDecoder(mapper))
                .logLevel(Logger.Level.FULL)
                .target(XxxClient.class, URL);
    }

    private XxxClientFactory() {

    }

    public static XxxClientFactory newInstance() {
        return new XxxClientFactory();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;b常用feignclient实现&#34;&gt;b.常用FeignClient实现&lt;/h4&gt;
&lt;h5 id=&#34;添加依赖&#34;&gt;添加依赖&lt;/h5&gt;
&lt;h5 id=&#34;application中增加注解允许指定包的feignclient有效&#34;&gt;Application中增加注解,允许指定包的feignClient有效&lt;/h5&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@EnableFeignClients(basePackages = {&amp;#34;com.shuidihuzhu.devops.xrxs.client&amp;#34;, &amp;#34;com.shuidihuzhu.devops.xrxs.feign&amp;#34;})
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3创建service&#34;&gt;3.创建service&lt;/h3&gt;
&lt;p&gt;创建获取第三方数据的service，所有三方数据的获取，按照内容分模块的进行封装实现，将通过上面的client获取到的数据进行处理然后分别进行返回。&lt;/p&gt;
&lt;h2 id=&#34;四-将数据同步到ad域&#34;&gt;四 将数据同步到AD域&lt;/h2&gt;
&lt;h3 id=&#34;1添加依赖和配置&#34;&gt;1.添加依赖和配置&lt;/h3&gt;
&lt;h4 id=&#34;a依赖&#34;&gt;a.依赖&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;		&amp;lt;dependency&amp;gt;
			&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
			&amp;lt;artifactId&amp;gt;spring-boot-starter-data-ldap&amp;lt;/artifactId&amp;gt;
		&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;b配置&#34;&gt;b.配置&lt;/h4&gt;
&lt;p&gt;LdapConfiguration.Java&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Configuration
@EnableLdapRepositories
public class LdapConfiguration {
    private LdapTemplate ldapTemplate;

    @Value(&amp;#34;${spring.ldap.urls}&amp;#34;)
    private String LDAP_URL;
    @Value(&amp;#34;${spring.ldap.username}&amp;#34;)
    private String USERNAME;
    @Value(&amp;#34;${spring.ldap.password}&amp;#34;)
    private String PASSWORD;
    @Value(&amp;#34;${spring.ldap.base}&amp;#34;)
    private String BASE;

    @Bean
    public LdapContextSource contextSource() {
        LdapContextSource contextSource = new LdapContextSource();
        Map&amp;lt;String, Object&amp;gt; config = new HashMap&amp;lt;&amp;gt;();
        contextSource.setUrl(LDAP_URL);
        contextSource.setBase(BASE);
        contextSource.setUserDn(USERNAME);
        contextSource.setPassword(PASSWORD);
        config.put(&amp;#34;java.naming.ldap.attributes.binary&amp;#34;, &amp;#34;objectGUID&amp;#34;);
        contextSource.setPooled(true);
        contextSource.setBaseEnvironmentProperties(config);
        return contextSource;
    }

    @Bean
    public LdapTemplate ldapTemplate() {
        if (null == ldapTemplate){
            ldapTemplate = new LdapTemplate(contextSource());
        }

        ldapTemplate.setIgnorePartialResultException(true);
        return ldapTemplate;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Application.Java&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@SpringBootApplication
@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
@EnableScheduling
@EnableFeignClients(basePackages = {&amp;#34;com.shuidihuzhu.devops.xrxs.client&amp;#34;, &amp;#34;com.shuidihuzhu.devops.xrxs.feign&amp;#34;})
@EnableAspectJAutoProxy(proxyTargetClass = true)
@EnableCircuitBreaker
@EnableLdapRepositories
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

    @Bean
    LdapTemplate getLdapTemplate(ContextSource contextSource) {
        LdapTemplate ldapTemplate = new LdapTemplate(contextSource);
        ldapTemplate.setIgnorePartialResultException(true);
        return ldapTemplate;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意&lt;code&gt;setIgnorePartialResultException(true)&lt;/code&gt;这个方法是必须要设置好的，不然对接AD的时候，会报出莫名其妙的错误&lt;/p&gt;
&lt;h3 id=&#34;2定义model和dao层&#34;&gt;2.定义model和DAO层&lt;/h3&gt;
&lt;p&gt;以人员为例,Ad中的user对应的objectClasses有四个类，base设置就是对应的AD域下的专门存放这些user的域&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Data
@Entry(objectClasses = {&amp;#34;top&amp;#34;, &amp;#34;person&amp;#34;, &amp;#34;organizationalPerson&amp;#34;, &amp;#34;user&amp;#34;}, base = &amp;#34;ou=XxxUser&amp;#34;)
public final class XxxUser {

    @Id
    @JsonIgnore
    private Name id;


    @Attribute(name = &amp;#34;mail&amp;#34;)
    private String mail;

    @Attribute(name = &amp;#34;mobile&amp;#34;)
    private String mobile;

    @Attribute(name = &amp;#34;sn&amp;#34;)
    private String sn;

    @Attribute(name = &amp;#34;cn&amp;#34;)
    @DnAttribute(value = &amp;#34;cn&amp;#34;, index = 1)
    private String cn;


    @Attribute(name = &amp;#34;displayName&amp;#34;)
    private String displayName;

    @Attribute(name = &amp;#34;ou&amp;#34;)
    @DnAttribute(value = &amp;#34;ou&amp;#34;, index = 1)
    private String ou;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义对应的DAO,在这个DAO接口中，可以使用JPA的函数命名来进行条件查询，但是还是做不了一些复杂的查询，如果需要复杂的查询依然还是需要在自定义的接口XxxUserExtension中进行定义，然后进行实现。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Repository
public interface XxxUserRepo extends LdapRepository&amp;lt;XxxUser&amp;gt;, XxxUserExtension {
 
    List&amp;lt;XxxUser&amp;gt; findByOu(String ou);

}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;3定义service层&#34;&gt;3.定义Service层&lt;/h2&gt;
&lt;p&gt;根据业务的需求，将获取到的第三方的信息，经过处理之后，将Response的有效内容解析到对应的AD的model中，通过对应的DAO层类，存入到AD中&lt;/p&gt;
&lt;h2 id=&#34;五-创建定时任务&#34;&gt;五 创建定时任务&lt;/h2&gt;
&lt;p&gt;根据cron或者fixedRate(每隔一段时间执行)来设置定时任务&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Slf4j
@Component
@EnableScheduling
public class XxxToAdJob {
    /**
     * 每20分钟同步一次
     */
//  @Scheduled(cron = &amp;#34;0 */20 * * * ?&amp;#34;) 
    @Scheduled(fixedRate = 1000 * 60 * 20)
    public void doExecuteJob() {
    	// 同步逻辑
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;六-注意事项&#34;&gt;六 注意事项&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;本文只是将本项目最简单的框架思路展现了出来，在具体实施的过程中，会有很多很多坑&lt;/li&gt;
&lt;li&gt;对接第三方数据源的时候，需要注意请求的一些频率，比如某些数据源要求，每分钟的请求调用不能超过200次&lt;/li&gt;
&lt;li&gt;对接AD的时候，需要it部门的人将对应功能模块所需要的端口都打开，不然会有问题&lt;/li&gt;
&lt;li&gt;如果需要ldaps访问，需要导出AD的证书然后使用java的keytool制作证书，然后在启动的时候增加参数（但是目前都没有成功）&lt;/li&gt;
&lt;li&gt;ldap常见错误码 &lt;a class=&#34;link&#34; href=&#34;https://docs.servicenow.com/bundle/jakarta-platform-administration/page/administer/reference-pages/reference/r_LDAPErrorCodes.html?title=LDAP_Error_Codes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;mac电脑可以使用Parallels Client这个软件远程登录AD的服务器进行查看（AD是搭建在一个windows的集群上的）&lt;/li&gt;
&lt;li&gt;AD自定义属性的创建 &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/llcs/archive/2018/04/26/8948315.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;相关文章&lt;/a&gt; 注意x500的中国区对象id必须是2.16.156开头的&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>FeignClient的FallBack处理</title>
        <link>https://lllovol.com/p/fallback/</link>
        <pubDate>Thu, 11 Jul 2019 16:31:53 +0000</pubDate>
        
        <guid>https://lllovol.com/p/fallback/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/8.jpg" alt="Featured image of post FeignClient的FallBack处理" /&gt;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;在使用FeignClient的时候，我们很难保证第三方的调用不会出问题，这个时候，可以写一个FallBack类，来对出错的时候进行处理，可以异常上报，也可以进行打点处理，可以不再单独地去做这些事情。&lt;/p&gt;
&lt;h1 id=&#34;feignclient的编写&#34;&gt;FeignClient的编写&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;添加maven依赖。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;		&amp;lt;dependency&amp;gt;
		    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
		    &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
		    &amp;lt;version&amp;gt;2.0.2.RELEASE&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
		    &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt;
		    &amp;lt;artifactId&amp;gt;feign-core&amp;lt;/artifactId&amp;gt;
		    &amp;lt;version&amp;gt;9.7.0&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
		&amp;lt;dependency&amp;gt;
		    &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt;
		    &amp;lt;artifactId&amp;gt;feign-slf4j&amp;lt;/artifactId&amp;gt;
		    &amp;lt;version&amp;gt;9.7.0&amp;lt;/version&amp;gt;
		&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;新建一个接口，在上方添加FeignClient注解，在value中使用占位符的方式，对参数进行调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;		@FeignClient(name = &amp;#34;gitApi&amp;#34;, url = &amp;#34;${api.server.gitlab.url}&amp;#34;,fallback = GitApiFeignFallBack.class)
		public interface GitApiFeign {

			@GetMapping(value = &amp;#34;/{namespace}/-/jobs/{jobId}/trace&amp;#34;)    
		    JSONObject getTrace(
		            @PathVariable(&amp;#34;namespace&amp;#34;) String namespace,
		            @PathVariable(&amp;#34;jobId&amp;#34;) Integer jobId,
		            @RequestParam(&amp;#34;private_token&amp;#34;) String accessToken);
		}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;@Autowired 注解就能对FeignClient进行使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Autowired
GitApiFeign gitApiFeign;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;feignclient的fallback实现&#34;&gt;FeignClient的Fallback实现&lt;/h1&gt;
&lt;p&gt;在上方的代码中，可以看见注解中有fallback的选项，这个就是新建这个Client对应的fallback类来实现FeignClient。&lt;br&gt;
在fallback类的实现代码大致如下，最简单的实现就是在fallBack类中重写一遍Client中的所有方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@Component
@Slf4j
public class GitApiFeignFallBack implements GitApiFeign {

    @Override
    public JSONObject getTrace(String namespace, Integer jobId, String accessToken) {
        log.error(&amp;#34;调用gitlab api 失败&amp;#34;);
        return null;
    }

}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(十一)CR笔记、阿里巴巴代码规约</title>
        <link>https://lllovol.com/p/spring11/</link>
        <pubDate>Wed, 10 Jul 2019 23:36:52 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring11/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/7.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(十一)CR笔记、阿里巴巴代码规约" /&gt;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近正式入职，第一周的事情主要就是进行代码的Code Review,将自己曾经的实习时候写的代码看一看，清掉一部分过时的代码。同时也从前辈们的分享中学习到了不少的小细节。
以及看了阿里巴巴的开发规范规约，将一些比较重要的地方、原来没有注意到的地方记录一下。&lt;/p&gt;
&lt;h1 id=&#34;测试用例&#34;&gt;测试用例&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在写Junit的时候，可以写一个BaseTest,以后test直接继承这个类即可，就不用每次都新建一个类然后在上面重新写上好多注解了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; @SpringBootTest(classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  
 @RunWith(SpringJUnit4ClassRunner.class)  
 @Slf4j  
 public class BaseTests {
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在写CRUD的测试用例的时候，一定要写成一个闭环，新加了测试用例，最后测试结束的时候一定要删除，防止在数据库中产生脏数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;阿里巴巴的规约阅读笔记&#34;&gt;阿里巴巴的规约阅读笔记&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;外部正在调用或者二方库依赖的接口（二方库就是公司内部各个服务之间相互依赖的库）不允许修改方法的签名，避免对接口调用方造成影响。&lt;/li&gt;
&lt;li&gt;接口过时的时候必须加上**@Deprecated**注解。&lt;/li&gt;
&lt;li&gt;Object的equals方法容易报NPE，应该使用常量或者确定有值的对象来使用equals方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;正例:&amp;ldquo;test&amp;rdquo;.equals(object);&lt;br&gt;
反例:object.equals(&amp;ldquo;test&amp;rdquo;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;所有整型包装类对象之间&lt;strong&gt;值的比较&lt;/strong&gt;，全部使用equals方法比较。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;说明:对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产 生，会复用已有对象，这个区间内的 Integer 值可以直接使用==进行判断，但是这个区间之外的所有数 据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用equals来判断。&lt;/li&gt;
&lt;li&gt;定义数据对象DO类时，属性类型要与数据库字段类型相匹配。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;正例:数据库字段的 bigint 必须与类属性的 Long 类型相对应。&lt;br&gt;
反例:某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来 越大，超过 Integer 的表示范围而溢出成为负数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;为了防止精度损失，禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;说明:BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。&lt;br&gt;
如:BigDecimal g = new BigDecimal(0.1f); 实际的存储值为:0.10000000149&lt;br&gt;
正例:优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了 Double 的 toString，而 Double 的 toString 按 double 的实际能表达的精度对尾数进行了截断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;BigDecimal recommend1 = new BigDecimal(&amp;#34;0.1&amp;#34;);
BigDecimal recommend2 = BigDecimal.valueOf(0.1);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;所有POJO类属性必须使用包装数据类型。&lt;/li&gt;
&lt;li&gt;RPC方法和返回值必须使用包装数据类型。&lt;/li&gt;
&lt;li&gt;所有的局部变量推荐使用基本数据类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;说明:POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。&lt;br&gt;
正例:数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。 反例:比如显示成交总额涨跌情况，即正负 x%，x为基本数据类型，调用的RPC 服务，调用不成功时，返回的是默认值，页面显示为 0%，这是不合理的，应该显示成中划线。所以包装数据类型的 null 值，能 够表示额外的信息，如:远程调用失败，异常退出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;定义DO、DTO、VO等POJO类的时候，不要设定任何属性的默认值。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;反例:POJO 类的createTime默认值为 new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。&lt;/li&gt;
&lt;li&gt;序列化类新增属性的时候，不要修改serialVersionUID字段避免反序列化失败;如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID的值。&lt;/li&gt;
&lt;li&gt;使用索引访问String的split方法得到的数组时，需要做到最后一个分隔符后有误内容的检查，否则有抛IndexOutOfBoundsException的风险&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;String str = &amp;#34;a,b,c,,&amp;#34;;
String[] ary = str.split(&amp;#34;,&amp;#34;);
// 预期大于 3，结果是 3 System.out.println(ary.length);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;循环体类，字符串的连接方式，使用StringBuilder的append方法进行拓展，或者使用Guava的Joiner来进行拓展。如果使用str=str+“new str”的方式来进行字符串连接的话，每一次循环都会产生一个新的StringBuilder对象然后进行append操作，最后通过toString方法返回String对象，造成内存资源的浪费。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;反例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;String str = &amp;#34;start&amp;#34;;
for (int i = 0; i &amp;lt; 100; i++) {
str = str + &amp;#34;hello&amp;#34;; }
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;16&#34;&gt;
&lt;li&gt;表达异常的分支时，少用if-else方式，这种方式可以改写成:&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if (condition) { ...
return obj; }
// 接着写 else 的业务逻辑代码;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明:如果非使用 if()&amp;hellip;else if()&amp;hellip;else&amp;hellip;方式表达逻辑，避免后续代码维护困难，请勿超过3层。 正例:超过3层的if-else的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句,即代码逻辑先考虑失败、异常、中断、退出等直接返回的情况，以方法多个出口的方式，解决代码中判断分支嵌套的问题，这是逆向思维的体现。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;public void findBoyfriend(Man man) {
if (man.isUgly()) { System.out.println(&amp;#34;本姑娘是外貌协会的资深会员&amp;#34;);
return; }
if (man.isPoor()) { System.out.println(&amp;#34;贫贱夫妻百事哀&amp;#34;);
return; }
if (man.isBadTemper()) { System.out.println(&amp;#34;银河有多远，你就给我滚多远&amp;#34;);
return; }
System.out.println(&amp;#34;可以先交往一段时间看看&amp;#34;); }
//he,woman
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;17&#34;&gt;
&lt;li&gt;除常用方法(如getXxx/isXxx)等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;说明:很多if语句内的逻辑表达式相当复杂，与、或、取反混合运算，甚至各种方法纵深调用，理解成本非常高。如果赋值一个非常好理解的布尔变量名字，则是件令人爽心悦目的事情。&lt;br&gt;
正例:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 伪代码如下
final boolean existed = (file.open(fileName, &amp;#34;w&amp;#34;) != null) &amp;amp;&amp;amp; (...) || (...);
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;18&#34;&gt;
&lt;li&gt;在高并发场景中，避免使用”等于”判断作为中断或退出的条件。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果并发控制没有做好，那么容易产生等值判断被“击穿”的情况，最好使用区间判断来代替。&lt;br&gt;
反例： 判断剩余奖品数量等于0时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;19&#34;&gt;
&lt;li&gt;类、类属性、类方法的注释必须使用Javadoc规范，使用/**内容*/格式，不得使用 // xxx 方式。&lt;/li&gt;
&lt;li&gt;所有的抽象方法(包括接口中的方法)必须要用Javadoc注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。 说明:对子类的实现要求，或者调用注意事项，请一并说明。&lt;/li&gt;
&lt;li&gt;所有的类都必须添加创建者和创建日期。&lt;/li&gt;
&lt;li&gt;方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释
使用/* */注释，注意与代码对齐。&lt;/li&gt;
&lt;li&gt;所有的枚举类型字段必须要有注释，说明每个数据项的用途。&lt;/li&gt;
&lt;li&gt;避免出现重复的代码(&lt;strong&gt;Don&amp;rsquo;t Repeat Yourself&lt;/strong&gt;)，即DRY原则。说明:随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。&lt;/li&gt;
&lt;li&gt;应用中不可直接使用日志系统(Log4j、Logback)中的API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;code-review&#34;&gt;Code Review&lt;/h1&gt;
&lt;ol start=&#34;26&#34;&gt;
&lt;li&gt;使用Response&lt;!-- raw HTML omitted --&gt;代替Response，list数据为空时后端不要返回NULL而要返回空集合。&lt;/li&gt;
&lt;li&gt;DTO（Data Transfer Object）类一般是用于两个系统之间的数据传输，而VO(Value Object)一般是用于后端向前端进行展示的数据对象。&lt;/li&gt;
&lt;li&gt;尽量不要使用BeanUtils.copyProperties，可以在目标方法里面写一个构造方法。使用getter和setter，使用上面那个工具类，如果属性有一点不一样的时候，就会出错。&lt;/li&gt;
&lt;li&gt;一个方法需要判断是不是为空的时候，可以在入参的时候就进行判断。&lt;/li&gt;
&lt;li&gt;尽量不要使用map来进行返回，最好是通过定义对象的方式来进行返回。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(十）泛型、分布式锁</title>
        <link>https://lllovol.com/p/spring10/</link>
        <pubDate>Fri, 29 Mar 2019 17:19:15 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring10/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/3.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(十）泛型、分布式锁" /&gt;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;本文主要记录最近工作中关于开发中的一些小技巧以及感悟&lt;/p&gt;
&lt;h1 id=&#34;小细节&#34;&gt;小细节&lt;/h1&gt;
&lt;h4 id=&#34;权重转换百分比的问题&#34;&gt;权重转换百分比的问题&lt;/h4&gt;
&lt;p&gt;在工作中需要将各个对象所对应的权重转换成百分比，并且要求最后转换出来的百分比，同一类型的相加必须为百分之百，解决思路主要如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将各个类型的对象都分别分类&lt;/li&gt;
&lt;li&gt;算出各个类型的总权重&lt;/li&gt;
&lt;li&gt;算出每个对象在自己类型下的所占百分比&lt;/li&gt;
&lt;li&gt;判断每个类型下的对象百分比相加是否等于100&lt;/li&gt;
&lt;li&gt;在List处理的时候，可以将List分割成当前类型，和非当前类型
其中需要注意的是，在算百分比的时候，*100应该写在分子&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;eg:
//这样会一直为0，是错误的
//原因是运算符是从左往右计算
//前面除法算出来之后会直接去尾，不足1就是0，所以最后乘以100结果还是0
percent / totalWeight * 100
//这样是正确的
percent * 100 / totalWeight&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    private List&amp;lt;GreyDestination&amp;gt; getDestinationsPercent(List&amp;lt;GreyDestination&amp;gt; tempDestinations) {
        HashMap&amp;lt;String, Integer&amp;gt; serviceAndTotalWeight = new HashMap&amp;lt;&amp;gt;();
        HashMap&amp;lt;String, Integer&amp;gt; serviceAndCount = new HashMap&amp;lt;&amp;gt;();
        getServiceWeightAndCount(tempDestinations, serviceAndTotalWeight, serviceAndCount);
        List&amp;lt;GreyDestination&amp;gt; finalDestinations = tempDestinations.stream().map(
                destination -&amp;gt; {
                    String service = destination.getService();
                    Integer count = serviceAndCount.get(service);
                    if (count == 1) {
                        destination.setPercent(100);
                    } else {
                        Integer totalWeight = serviceAndTotalWeight.get(service);
                        if (totalWeight == 0) {
                            totalWeight = 1;
                        }
                        destination.setPercent(destination.getWeight() * 100 / serviceAndTotalWeight.get(service));
                    }
                    return destination;
                }
        ).collect(Collectors.toList());

        for (String service : serviceAndCount.keySet()) {
            if (serviceAndCount.get(service) &amp;gt; 1) {
                List&amp;lt;GreyDestination&amp;gt; collectService = finalDestinations.stream().filter(destination -&amp;gt; destination.getService().equals(service)).collect(Collectors.toList());
                List&amp;lt;GreyDestination&amp;gt; collectRest = finalDestinations.stream().filter(destination -&amp;gt; !destination.getService().equals(service)).collect(Collectors.toList());

                Integer firstPercet= 100;
                for (int i = 1; i &amp;lt; collectService.size(); i++) {
                    firstPercet = firstPercet-collectService.get(i).getPercent();
                }
                GreyDestination firstDestination = collectService.get(0);
                firstDestination.setPercent(firstPercet);
                collectService.set(0, firstDestination);
                collectService.addAll(collectRest);
                finalDestinations=collectService;
            }
        }
        return finalDestinations;
    }

    private void getServiceWeightAndCount(List&amp;lt;GreyDestination&amp;gt; tempDestinations, HashMap&amp;lt;String, Integer&amp;gt; serviceAndTotalWeight, HashMap&amp;lt;String, Integer&amp;gt; serviceAndCount) {
        for (GreyDestination tempDestination : tempDestinations) {
            String service = tempDestination.getService();
            Integer weight = tempDestination.getWeight();
            //存储每个service的count
            if (serviceAndCount.containsKey(service)) {
                serviceAndCount.put(service, serviceAndCount.get(service) + 1);
            } else {
                serviceAndCount.put(service, 1);
            }
            //增加每个Service的total weight
            if (serviceAndTotalWeight.containsKey(service)) {
                serviceAndTotalWeight.put(service, serviceAndTotalWeight.get(service) + weight);
            } else {
                serviceAndTotalWeight.put(service, weight);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;公共基础父类&#34;&gt;公共基础父类&lt;/h4&gt;
&lt;p&gt;例如 分页模块，应该在父类定制一个最简单的模型，然后在各个业务Service中继承的时候，分别定制化各个服务中特有的特征，已达到方法真正的可扩展性和可复用性。&lt;/p&gt;
&lt;h4 id=&#34;单例模式&#34;&gt;单例模式&lt;/h4&gt;
&lt;p&gt;这个常见的设计模式，主要是用来保证这个对象，只会被实例化一次，比如在线程池中的时候&lt;/p&gt;
&lt;h4 id=&#34;泛型&#34;&gt;泛型&lt;/h4&gt;
&lt;h5 id=&#34;三种类型&#34;&gt;三种类型&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;泛型接口（写在接口名之后）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public interface List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泛型类（将泛型写在类名之后）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  class Test&amp;lt;T&amp;gt;{ 
  	private T data;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泛型方法（将泛型写在方法返回值之前）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  public static &amp;lt;T extends Comparable&amp;gt; void sort(T[] arr, int left, int right)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;实例code&#34;&gt;实例code&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;	package QuickSort;
	import com.google.common.base.Joiner;
	/**
	 * Created by ymk on 2019/3/29.
	 * 这个类主要是用来实现快速排序的
	 */
	public class QuickSort {

	    public static &amp;lt;T extends Comparable&amp;gt; void sort(T[] arr, int left, int right) {
	        if (left &amp;gt;= right)
	            return;
	        int i = left, j = right;
	        T key = arr[i];

	        while (i &amp;lt; j) {
	            while (arr[j].compareTo(key) &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; j) {
	                j--;
	            }
	            //j找到第一个比key小的值,i和j交换值
	            swap(arr,i,j);
	            while (arr[i].compareTo(key) &amp;lt;= 0 &amp;amp;&amp;amp; i &amp;lt; j) {
	                i++;
	            }
	            //i找到第一个比key大的值,i和j交换值
	            swap(arr,i,j);
	        }
	        //开始递归
	        sort(arr,left,i);
	        sort(arr,i+1,right);
	    }

	    public static &amp;lt;T&amp;gt; void swap(T[] arr, int i, int j) {
	        T temp = arr[i];
	        arr[i] = arr[j];
	        arr[j] = temp;
	    }

	    public static void main(String[] args) {
	        Integer[] arr={1,2,325,52,34,5346,23,23,56,74,34,634,74,34};
	        Joiner joiner = Joiner.on(&amp;quot;,&amp;quot;);
	        System.out.println(joiner.join(arr));
	        sort(arr,0,arr.length-1);
	        System.out.println(joiner.join(arr));

	    }

	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;分布式锁的问题&#34;&gt;分布式锁的问题&lt;/h4&gt;
&lt;p&gt;最近工作中的后台服务，部署在了测试环境中的两个节点上，然后执行同一个定时任务的时候，虽然都写了在更新之前先删除库中信息，然后再将新的数据入库的操作，但是实际部署之后，还是会出现数据的冗余，原因应该是在某一瞬间，两个服务同时删除了库，然后同时插入了相同的数据。虽然过一段时间后就数据再次就正常了，但是这还是一个问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/seesun2012/p/9214653.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java分布式锁&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以使用分布式锁，将锁放在redis当中（分布式问题之所以复杂，就是因为网络延迟和网络不可靠的问题）setnx ，get等等（有可能会出现阻塞的情况，比如在操作的时候宕机了，来不及释放），具体有机会的时候，实践一下吧&lt;/p&gt;
&lt;p&gt;顺便复习一下死锁的四个必要条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排他性&lt;/li&gt;
&lt;li&gt;请求和保持资源&lt;/li&gt;
&lt;li&gt;不剥夺资源&lt;/li&gt;
&lt;li&gt;形成等待环路&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(九）Guava库</title>
        <link>https://lllovol.com/p/spring9/</link>
        <pubDate>Sun, 24 Mar 2019 17:23:42 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring9/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/9.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(九）Guava库" /&gt;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;本文主要记录最近工作中关于开发中的一些小技巧以及感悟&lt;/p&gt;
&lt;h1 id=&#34;小细节&#34;&gt;小细节&lt;/h1&gt;
&lt;h4 id=&#34;string转long&#34;&gt;String转Long&lt;/h4&gt;
&lt;p&gt;使用Long.parseLong,而不是Long.getLong&lt;/p&gt;
&lt;h4 id=&#34;guava库&#34;&gt;Guava库&lt;/h4&gt;
&lt;h5 id=&#34;joiner&#34;&gt;Joiner&lt;/h5&gt;
&lt;p&gt;超好用的Guava库，主要用于字符串的拼接，可以自动在中间加上分隔符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    String yamlStart = &amp;quot;---\n&amp;quot;;
    String yamlEnd = &amp;quot;...\n&amp;quot;;
    Joiner joinerContent = Joiner.on(&amp;quot;...\n---\n&amp;quot;).skipNulls();
    return Joiner.on(&amp;quot;&amp;quot;).join(yamlStart, joinerContent.join(yamlList), yamlEnd);
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;splitter&#34;&gt;Splitter&lt;/h5&gt;
&lt;p&gt;可以很方便的将字符串分割成对应的数据结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	//将source进行处理
    List&amp;lt;String&amp;gt; tempSource = Splitter.on(&amp;quot;,&amp;quot;).splitToList(param.getSource());
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;string占位符的用法&#34;&gt;String占位符的用法&lt;/h4&gt;
&lt;p&gt;原来：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	String title = &amp;quot;[&amp;quot; + characterName + &amp;quot;][&amp;quot; + task.getEnv() + &amp;quot;][&amp;quot; + pipelineStage.getService() + &amp;quot;]&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改进：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	String title = String.format(&amp;quot;[%s][%s][%s]&amp;quot;,
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;线程中的问题&#34;&gt;线程中的问题&lt;/h4&gt;
&lt;p&gt;不能直接使用Autowired，需要定义了成员变量之后，使用外界已经加载好的service作为入参传入初始化这个线程，如果每一个线程都启一个service的话，资源消耗会很大。
（仅仅是我暂时这么理解，TODO 搞清楚原因）&lt;/p&gt;
&lt;h4 id=&#34;数据入库的操作&#34;&gt;数据入库的操作&lt;/h4&gt;
&lt;p&gt;建议先入队列，然后再入库&lt;/p&gt;
&lt;h4 id=&#34;configuration的问题&#34;&gt;Configuration的问题&lt;/h4&gt;
&lt;p&gt;定义了两个configuration，一个masterClient，一个jobClient
然后有个地方使用了@Autowired来进行配置（一个在外层service，一个是另外一个service），这时候就出现了冲突，开始报错。配置一定要清晰&lt;/p&gt;
&lt;h4 id=&#34;重复代码的问题&#34;&gt;重复代码的问题&lt;/h4&gt;
&lt;p&gt;在mac中，如果是在同一个类中的重复冗余的代码，可以使用option+command加上m，可以将重复代码进行抽离。如果是在不同的类中，可以使用将重复方法抽离到父类的方法，或者是抽离到静态工具类的方法。避免重复代码的最好的方式，就是在编码的时候，尽量不要使用复制粘贴的方式来进行编码，而应该想办法，提高自己的代码的可复用性和可扩展性。&lt;/p&gt;
&lt;h1 id=&#34;小感悟&#34;&gt;小感悟&lt;/h1&gt;
&lt;p&gt;工作不知不觉已经是第七个月，但是自己的能力，还有薪资，都是处于一个“穷”的状态，俗话说得好，穷则独善其身。现在的我，还没有资格去管别人的事情，能将自己的事情做好就已经不错了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(八)装箱与拆箱，基本数据类型与包装类</title>
        <link>https://lllovol.com/p/spring8/</link>
        <pubDate>Thu, 14 Mar 2019 17:03:05 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring8/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/6.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(八)装箱与拆箱，基本数据类型与包装类" /&gt;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;主要用来记录整理最近一周工作学习中遇到，学到的一些小知识，积少成多，聚沙成塔&lt;/p&gt;
&lt;h1 id=&#34;小细节&#34;&gt;小细节&lt;/h1&gt;
&lt;h4 id=&#34;swagger-ui显示枚举类型的时候&#34;&gt;Swagger-ui显示枚举类型的时候&lt;/h4&gt;
&lt;p&gt;定义的枚举类型的头上不需要加一些莫名其妙的注解，就可以在Swagger-ui界面自动生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	public enum GreyTaskType {
	    SCALE,
	    PERSON,
	    DEMAND,
	    HOST
	    ;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/spring8/1.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;例子&#34;
	
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;swagger-ui的参数显示的问题&#34;&gt;Swagger-ui的参数显示的问题&lt;/h4&gt;
&lt;p&gt;这个是在帮忙解决朋友的问题的时候发现的，其实就是Getter的问题，他定义了俩Getter，这样就会有俩参数跑出来了。&lt;/p&gt;
&lt;h4 id=&#34;双向的验证&#34;&gt;双向的验证&lt;/h4&gt;
&lt;p&gt;在两个模块相互依赖的时候，一方在进行某些操作的时候，需要判断另一方的状态，同样，另一方在进行某些操作的时候，也需要对这边的状态进行判断。
（主要是在删除和发布操作的时候）&lt;/p&gt;
&lt;h4 id=&#34;burp-suite和kali系统&#34;&gt;Burp Suite和Kali系统&lt;/h4&gt;
&lt;p&gt;能够用于web应用攻击的，主要使用这个工具来进行网络安全方面的测试。而Kali系统主要就是黑客使用的系统了，用于网络渗透&lt;/p&gt;
&lt;h4 id=&#34;spring-cloud配置中心&#34;&gt;Spring cloud配置中心&lt;/h4&gt;
&lt;p&gt;能够使用这个工具，实现项目发布在不同环境的情况下， 自行加载对应环境下的配置，而不再用手动修改&lt;/p&gt;
&lt;h5 id=&#34;配置的优先级顺序&#34;&gt;配置的优先级顺序：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;配置中心的&lt;!-- raw HTML omitted --&gt;/&lt;!-- raw HTML omitted --&gt;-(env).yml （一般不存在）&lt;/li&gt;
&lt;li&gt;配置中心的application-env.yml （一般不存在）&lt;/li&gt;
&lt;li&gt;配置中心的 &lt;!-- raw HTML omitted --&gt;/&lt;!-- raw HTML omitted --&gt;-test.yml&lt;/li&gt;
&lt;li&gt;配置中心的application-test.yml&lt;/li&gt;
&lt;li&gt;配置中心的 &lt;!-- raw HTML omitted --&gt;/&lt;!-- raw HTML omitted --&gt;.yml&lt;/li&gt;
&lt;li&gt;配置中心的application.yml&lt;/li&gt;
&lt;li&gt;项目内的application.yml&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上到下，优先级依次降低&lt;/p&gt;
&lt;h4 id=&#34;debug的时候的细节&#34;&gt;debug的时候的细节&lt;/h4&gt;
&lt;p&gt;在debug的时候，停到某一行的时候，可以按optional+f8，可以单独对函数进行调试，包括修改参数等等操作&lt;/p&gt;
&lt;h4 id=&#34;栈和队列有什么区别&#34;&gt;栈和队列有什么区别&lt;/h4&gt;
&lt;p&gt;吃多了拉就是队列，吃多了吐就是栈（段子区看到的23333对栈和队列最形象生动的解释了）&lt;/p&gt;
&lt;h1 id=&#34;java中的装箱和拆箱&#34;&gt;Java中的装箱和拆箱&lt;/h1&gt;
&lt;p&gt;这个是一个前辈教授于我的，同时还推荐了一些书籍给我&lt;/p&gt;
&lt;h4 id=&#34;spring-相关书籍推荐&#34;&gt;spring 相关书籍推荐&lt;/h4&gt;
&lt;p&gt;spring boot 编程思想
原生类型，装箱和拆箱（int 和Integer）
&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/dolphin0520/p/3780005.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/dolphin0520/p/3780005.html&lt;/a&gt;&lt;/p&gt;
&lt;h6 id=&#34;为什么会有装箱和拆箱&#34;&gt;为什么会有装箱和拆箱&lt;/h6&gt;
&lt;p&gt;我的理解，是将一个基本类型装箱，变成一个类，比如int 比那成Integer，这样做了之后，就能赋予这个类其他的各种方法和函数操作。&lt;br&gt;
当然这只是我很浅显的理解，下面是我在网上查阅相关的资料所了解到原因&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhidao.baidu.com/question/306015038512789844.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;为什么会有装箱和拆箱&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/dolphin0520/p/3780005.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入浅出java装箱和拆箱&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将一个基本类型包装成一个类， 可以使得这个类有很多可以调用的方法&lt;/li&gt;
&lt;li&gt;java还不算纯面向对象的语言，真正的面向对象，是没有基本数据类型的&lt;/li&gt;
&lt;li&gt;在java的泛型中，基本类型是不能够作为泛型参数的，因此需要使用包装类的类型解决泛型参数的问题&lt;/li&gt;
&lt;li&gt;这也是早期java的设计缺陷，基本的数据类型是数据，不是对象，也不是Object的子类，因此需要装箱，才能和其他的Object子类公用一个接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;基本数据类型和对应的包装类&#34;&gt;基本数据类型和对应的包装类&lt;/h6&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本数据类型&lt;/th&gt;
&lt;th&gt;包装类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;int（4字节）&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;byte（1字节）&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short（2字节）&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long（8字节）&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float（4字节）&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double（8字节）&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char（2字节）&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;boolean（未定）&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;装箱和拆箱的过程&#34;&gt;装箱和拆箱的过程&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;装箱过程：通过调用包装器的valueOf方法实现的&lt;/li&gt;
&lt;li&gt;拆箱过程：通过调用包装器的xxxValue方法实现的。（xxx代表对应的基本数据类型）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;其他注意点&#34;&gt;其他注意点&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。有面试题考察Integer A=100，B=100，问A==B结果是什么，答案是true，但是如果是200的话，答案就是false。原因就是前面所说的那样。&lt;/li&gt;
&lt;li&gt;Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现，因此上面那一点里面的题，如果是200.0的话，答案都是false。原因是因为，在某个范围内的整型数值的个数是有限的，但是浮点数的个数可以说是无数个。（Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。而Double、Float的实现方式是类似的）&lt;/li&gt;
&lt;li&gt;Boolean类型，在遇到上面的问题的时候，答案都是true&lt;/li&gt;
&lt;li&gt;Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别，前者不会触发自动装箱，后者会触发自动装箱，其次，在一般情况下，第二种执行方式在执行效率和资源占用方面优于第一种情况&lt;/li&gt;
&lt;li&gt;对于包装类型，equals函数不会触发自动转换，&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>源码阅读SpringDataJPA</title>
        <link>https://lllovol.com/p/springdatajpa/</link>
        <pubDate>Mon, 11 Mar 2019 19:28:16 +0000</pubDate>
        
        <guid>https://lllovol.com/p/springdatajpa/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/5.jpg" alt="Featured image of post 源码阅读SpringDataJPA" /&gt;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;CRUD是平常业务开发过程中最常接触到的，因此想通过阅读这个最常接触模块的代码，使得自己能够更加深入的了解Spring，提升自己的技术能力，而不是只会CRUD，却都不知道它是怎么实现的。&lt;/p&gt;
&lt;h4 id=&#34;hibernate&#34;&gt;Hibernate&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm（Object Relational Mapping）框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，完成数据持久化的重任。&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/Hibernate/206989?fr=aladdin&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Hibernate百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;jpa&#34;&gt;JPA&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;JPA诞生的缘由是为了整合第三方ORM框架，建立一种标准的方式，百度百科说是JDK为了实现ORM的天下归一，目前也是在按照这个方向发展，但是还没能完全实现。在ORM框架中，Hibernate是一支很大的部队，使用很广泛，也很方便，能力也很强，同时Hibernate也是和JPA整合的比较良好，我们可以认为JPA是标准，事实上也是，JPA几乎都是接口，实现都是Hibernate在做，宏观上面看，在JPA的统一之下Hibernate很良好的运行。&lt;br&gt;
我们都知道，在使用持久化工具的时候，一般都有一个对象来操作数据库，在原生的Hibernate中叫做Session，在JPA中叫做EntityManager，在MyBatis中叫做SqlSession，通过这个对象来操作数据库。我们一般按照三层结构来看的话，Service层做业务逻辑处理，Dao层和数据库打交道，在Dao中，就存在着上面的对象。那么ORM框架本身提供的功能有什么呢？答案是基本的CRUD，所有的基础CRUD框架都提供，我们使用起来感觉很方便，很给力，业务逻辑层面的处理ORM是没有提供的，如果使用原生的框架，业务逻辑代码我们一般会自定义，会自己去写SQL语句，然后执行。在这个时候，Spring-data-jpa的威力就体现出来了，ORM提供的能力他都提供，ORM框架没有提供的业务逻辑功能Spring-data-jpa也提供，全方位的解决用户的需求。使用Spring-data-jpa进行开发的过程中，常用的功能，我们几乎不需要写一条sql语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http.csdn.net/qq_22172133/article/details/81192040&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;博文地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring-data/jpa/docs/2.1.5.RELEASE/reference/html/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JPA官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;应用实例&#34;&gt;应用实例&lt;/h1&gt;
&lt;p&gt;在大家的日常开发中都用到了很多，再次就不细致列举了，详情可以查看另外一篇博文&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://lllovol.com/spring6/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring开发的小细节（六）&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;源码解析&#34;&gt;源码解析&lt;/h1&gt;
&lt;h2 id=&#34;repository&#34;&gt;Repository&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;	@Indexed
	public interface Repository&amp;lt;T, ID&amp;gt; {
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;crudrepository&#34;&gt;CrudRepository&lt;/h2&gt;
&lt;h4 id=&#34;主要接口&#34;&gt;主要接口&lt;/h4&gt;
&lt;p&gt;CurdRepository&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	public interface CrudRepository&amp;lt;T, ID&amp;gt; extends Repository&amp;lt;T, ID&amp;gt; {
	    &amp;lt;S extends T&amp;gt; S save(S var1);

	    &amp;lt;S extends T&amp;gt; Iterable&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; var1);

	    Optional&amp;lt;T&amp;gt; findById(ID var1);

	    boolean existsById(ID var1);

	    Iterable&amp;lt;T&amp;gt; findAll();

	    Iterable&amp;lt;T&amp;gt; findAllById(Iterable&amp;lt;ID&amp;gt; var1);

	    long count();

	    void deleteById(ID var1);

	    void delete(T var1);

	    void deleteAll(Iterable&amp;lt;? extends T&amp;gt; var1);

	    void deleteAll();
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MongoRepository&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	@NoRepositoryBean
	public interface MongoRepository&amp;lt;T, ID&amp;gt; extends PagingAndSortingRepository&amp;lt;T, ID&amp;gt;
	, QueryByExampleExecutor&amp;lt;T&amp;gt; {
	    &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; var1);

	    List&amp;lt;T&amp;gt; findAll();

	    List&amp;lt;T&amp;gt; findAll(Sort var1);

	    &amp;lt;S extends T&amp;gt; S insert(S var1);

	    &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; insert(Iterable&amp;lt;S&amp;gt; var1);

	    &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; var1);

	    &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; var1, Sort var2);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;接口实现&#34;&gt;接口实现&lt;/h4&gt;
&lt;p&gt;除了SimpleKeyValueRepository的实现之外，还有SimpleMongoRepository、SimpleLdapRepository等的实现&lt;br&gt;
这里主要是看的是最Mongo的SimpleMongoRepository的接口实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	public class SimpleMongoRepository&amp;lt;T, ID&amp;gt; implements MongoRepository&amp;lt;T, ID&amp;gt; {
		//定义了Mongo里面的各种操作的方法
	    private final MongoOperations mongoOperations;
	    private final MongoEntityInformation&amp;lt;T, ID&amp;gt; entityInformation;

	    public SimpleMongoRepository(MongoEntityInformation&amp;lt;T, ID&amp;gt; metadata
	    	, MongoOperations mongoOperations) {
	        Assert.notNull(metadata, &amp;quot;MongoEntityInformation must not be null!&amp;quot;);
	        Assert.notNull(mongoOperations, &amp;quot;MongoOperations must not be null!&amp;quot;);
	        this.entityInformation = metadata;
	        this.mongoOperations = mongoOperations;
	    }

	    public &amp;lt;S extends T&amp;gt; S save(S entity) {
	        Assert.notNull(entity, &amp;quot;Entity must not be null!&amp;quot;);
	        if(this.entityInformation.isNew(entity)) {
	            this.mongoOperations.insert(entity, this.entityInformation.getCollectionName());
	        } else {
	            this.mongoOperations.save(entity, this.entityInformation.getCollectionName());
	        }

	        return entity;
	    }

	    public &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; entities) {
	        Assert.notNull(entities, &amp;quot;The given Iterable of entities not be null!&amp;quot;);
	        Streamable source = Streamable.of(entities);
	        boolean allNew = source.stream().allMatch((it) -&amp;gt; {
	            return this.entityInformation.isNew(it);
	        });
	        if(allNew) {
	            List result = (List)source.stream().collect(Collectors.toList());
	            this.mongoOperations.insert(result, this.entityInformation.getCollectionName());
	            return result;
	        } else {
	            return (List)source.stream().map(this::save).collect(Collectors.toList());
	        }
	    }

	    public Optional&amp;lt;T&amp;gt; findById(ID id) {
	        Assert.notNull(id, &amp;quot;The given id must not be null!&amp;quot;);
	        return Optional.ofNullable(this.mongoOperations
	        	.findById(id
	        		, this.entityInformation.getJavaType()
	        		, this.entityInformation.getCollectionName()));
	    }

	    public boolean existsById(ID id) {
	        Assert.notNull(id, &amp;quot;The given id must not be null!&amp;quot;);
	        return this.mongoOperations.exists(this.getIdQuery(id)
	        , this.entityInformation.getJavaType()
	        , this.entityInformation.getCollectionName());
	    }

	    public long count() {
	        return this.mongoOperations.getCollection(this
	        	.entityInformation
	        	.getCollectionName()).count();
	    }

	    public void deleteById(ID id) {
	        Assert.notNull(id, &amp;quot;The given id must not be null!&amp;quot;);
	        this.mongoOperations.remove(this.getIdQuery(id)
	        , this.entityInformation.getJavaType()
	        , this.entityInformation.getCollectionName());
	    }

	    public void delete(T entity) {
	        Assert.notNull(entity, &amp;quot;The given entity must not be null!&amp;quot;);
	        this.deleteById(this.entityInformation.getRequiredId(entity));
	    }

	    public void deleteAll(Iterable&amp;lt;? extends T&amp;gt; entities) {
	        Assert.notNull(entities, &amp;quot;The given Iterable of entities not be null!&amp;quot;);
	        entities.forEach(this::delete);
	    }

	    public void deleteAll() {
	        this.mongoOperations.remove(new Query()
	        , this.entityInformation.getCollectionName());
	    }

	    public List&amp;lt;T&amp;gt; findAll() {
	        return this.findAll(new Query());
	    }

	    public Iterable&amp;lt;T&amp;gt; findAllById(Iterable&amp;lt;ID&amp;gt; ids) {
	        return this.findAll(new Query((new Criteria(this.entityInformation
	        	.getIdAttribute()))
	        	.in((Collection)Streamable
	        	.of(ids)
	        	.stream()
	        	.collect(StreamUtils.toUnmodifiableList()))));
	    }

	    public Page&amp;lt;T&amp;gt; findAll(Pageable pageable) {
	        Assert.notNull(pageable, &amp;quot;Pageable must not be null!&amp;quot;);
	        Long count = Long.valueOf(this.count());
	        List list = this.findAll((new Query()).with(pageable));
	        return new PageImpl(list, pageable, count.longValue());
	    }

	    public List&amp;lt;T&amp;gt; findAll(Sort sort) {
	        Assert.notNull(sort, &amp;quot;Sort must not be null!&amp;quot;);
	        return this.findAll((new Query()).with(sort));
	    }

	    public &amp;lt;S extends T&amp;gt; S insert(S entity) {
	        Assert.notNull(entity, &amp;quot;Entity must not be null!&amp;quot;);
	        this.mongoOperations.insert(entity, this.entityInformation.getCollectionName());
	        return entity;
	    }

	    public &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; insert(Iterable&amp;lt;S&amp;gt; entities) {
	        Assert.notNull(entities, &amp;quot;The given Iterable of entities not be null!&amp;quot;);
	        List list = (List)Streamable.of(entities)
	        .stream().collect(StreamUtils.toUnmodifiableList());
	        if(list.isEmpty()) {
	            return list;
	        } else {
	            this.mongoOperations.insertAll(list);
	            return list;
	        }
	    }

	    public &amp;lt;S extends T&amp;gt; Page&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; example, Pageable pageable) {
	        Assert.notNull(example, &amp;quot;Sample must not be null!&amp;quot;);
	        Assert.notNull(pageable, &amp;quot;Pageable must not be null!&amp;quot;);
	        Query q = (new Query((new Criteria()).alike(example))).with(pageable);
	        List list = this.mongoOperations.find(q
	        	, example.getProbeType()
	        	, this.entityInformation.getCollectionName());
	        return PageableExecutionUtils.getPage(list, pageable, () -&amp;gt; {
	            return this.mongoOperations.count(q
	            	, example.getProbeType()
	            	, this.entityInformation.getCollectionName());
	        });
	    }

	    public &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; example, Sort sort) {
	        Assert.notNull(example, &amp;quot;Sample must not be null!&amp;quot;);
	        Assert.notNull(sort, &amp;quot;Sort must not be null!&amp;quot;);
	        Query q = (new Query((new Criteria()).alike(example))).with(sort);
	        return this.mongoOperations.find(q
	        	, example.getProbeType()
	        	, this.entityInformation.getCollectionName());
	    }

	    public &amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; example) {
	        return this.findAll(example, Sort.unsorted());
	    }

	    public &amp;lt;S extends T&amp;gt; Optional&amp;lt;S&amp;gt; findOne(Example&amp;lt;S&amp;gt; example) {
	        Assert.notNull(example, &amp;quot;Sample must not be null!&amp;quot;);
	        Query q = new Query((new Criteria()).alike(example));
	        return Optional.ofNullable(
	        	this.mongoOperations.findOne(q
	        		, example.getProbeType()
	        		, this.entityInformation.getCollectionName()));
	    }

	    public &amp;lt;S extends T&amp;gt; long count(Example&amp;lt;S&amp;gt; example) {
	        Assert.notNull(example, &amp;quot;Sample must not be null!&amp;quot;);
	        Query q = new Query((new Criteria()).alike(example));
	        return this.mongoOperations.count(q
	        	, example.getProbeType()
	        	, this.entityInformation.getCollectionName());
	    }

	    public &amp;lt;S extends T&amp;gt; boolean exists(Example&amp;lt;S&amp;gt; example) {
	        Assert.notNull(example, &amp;quot;Sample must not be null!&amp;quot;);
	        Query q = new Query((new Criteria()).alike(example));
	        return this.mongoOperations.exists(q
	        	, example.getProbeType()
	        	, this.entityInformation.getCollectionName());
	    }

	    private Query getIdQuery(Object id) {
	        return new Query(this.getIdCriteria(id));
	    }

	    private Criteria getIdCriteria(Object id) {
	        return Criteria.where(this.entityInformation.getIdAttribute()).is(id);
	    }findInRange(pageable.getOffset(), 
	    pageable.getPageSize(), 
	    pageable.getSort(), 
	    this.entityInformation.getJavaType());

	    private List&amp;lt;T&amp;gt; findAll(@Nullable Query query) {
	        return query == null?Collections.emptyList():this.mongoOperations.
	        find(query
	        	, this.entityInformation.getJavaType()
	        	, this.entityInformation.getCollectionName());
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(七)Controller路由以及分页查询</title>
        <link>https://lllovol.com/p/spring7/</link>
        <pubDate>Wed, 20 Feb 2019 11:35:51 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring7/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(七)Controller路由以及分页查询" /&gt;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;过年后第一次开始更新啦，这一篇主要就用来总结年后以来有意思，有用的一些信息&lt;/p&gt;
&lt;h2 id=&#34;在controller中的一些注解&#34;&gt;在Controller中的一些注解&lt;/h2&gt;
&lt;h4 id=&#34;controller的类型&#34;&gt;Controller的类型&lt;/h4&gt;
&lt;p&gt;主要有两种，一种是普通的,通常是被使用服务于web页面的。默认，你的controller方法返回的是一个string串，是表示要展示哪个模板页面或者是要跳转到哪里去。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Controller
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外一种是专门用在编写API的时候，返回一个JSON，或者是XML等等。然后方法返回的是可以是一个对象，或者是一个可以被序列化的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;路由的类型&#34;&gt;路由的类型&lt;/h4&gt;
&lt;p&gt;这里的路由就是指http method。（GET,POST,PUT,PATCH,DELETE）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@GetMapping
@PostMapping
@PutMapping
@PatchMapping
@DeleteMapping
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时，在Controller上面可以加上一个@RequestMapping，可以将所有类型路由的前缀都放在上面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RestController
@Slf4j
@Api(tags = &amp;quot;11. xxxxx&amp;quot;)
@RequestMapping(&amp;quot;/api/v1&amp;quot;)
@RequiredArgsConstructor
public class DataController {

private final DataService dataService;

@ApiOperation(&amp;quot;11.1 xxxx&amp;quot;)
@GetMapping(&amp;quot;/statistics&amp;quot;)
public Response&amp;lt;DataDeployDto&amp;gt; deployTask(@Validated DataParam query){
      log.info(&amp;quot;data Query {}&amp;quot;, JSONObject.toJSON(query));

      return ResponseUtil.makeSuccess(dataService.deployData(query));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;在controller内的传参的注解&#34;&gt;在Controller内的传参的注解&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@ApiOperation(&amp;quot;1.1 创建业务线&amp;quot;)
@PostMapping(&amp;quot;/save&amp;quot;)
public Response save(@RequestBody @Validated CustomProductAddParam customProductAddDto) {
log.info(&amp;quot;save() {}&amp;quot;, JSONObject.toJSON(customProductAddDto));

customProductService.save(customProductAddDto, true);

return ResponseUtil.makeSuccess(null);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;@RequestBody&lt;/em&gt; 就是要求传的数据是一个json格式的body传入的，这样前端会比较麻烦，因此在不需要的时候可以将这个注解取消掉&lt;br&gt;
&lt;img src=&#34;https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/spring7/41620289.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;有@RequestBody&#34;
	
	
&gt;
&lt;strong&gt;有@RequestBody&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/spring7/notRequest.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;无@RequestBody&#34;
	
	
&gt;
&lt;strong&gt;无@RequestBody&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;@Validated&lt;/em&gt; 就是在传参的时候需要判断验证，比如是不是为空什么（NotNull）&lt;/p&gt;
&lt;h2 id=&#34;空指针的问题&#34;&gt;空指针的问题&lt;/h2&gt;
&lt;p&gt;这是个老问题了，前面什么都没传的时候，到后端的时候是变成的null，CollectionUtils.isEmpty()可以用来判断Collection是空还是null，源码实现如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static boolean isEmpty(Collection coll) {
  return (coll == null || coll.isEmpty());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;int到long的转换&#34;&gt;Int到Long的转换&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;Long count = (long) all.size();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;强制转换int到long，注意括号里面是小写&lt;/p&gt;
&lt;h2 id=&#34;mongodbtemplate的查询分页&#34;&gt;MongoDBTemplate的查询分页&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@Override
public PagerData&amp;lt;GreyTask&amp;gt; list(GreyTaskListParam param) {
Criteria criteria = new Criteria();

if (StringUtils.isNotEmpty(param.getName())) {
    criteria.and(&amp;quot;name&amp;quot;).regex(param.getName());
}
if (StringUtils.isNotEmpty(param.getType().toString())) {
    criteria.and(&amp;quot;type&amp;quot;).is(param.getType());
}

Query query = new Query();
query.addCriteria(criteria)
        .with(new Sort(Sort.Direction.DESC, &amp;quot;createTime&amp;quot;))
        .skip(param.getSkip()).limit(param.getPageSize());

List&amp;lt;GreyTask&amp;gt; all = greyTaskRepo.findAll(query);

Long count = (long) all.size();
return new PagerData&amp;lt;&amp;gt;(all, count, param.getPageSize(), param.getPageNo());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;阿里云域名备案&#34;&gt;阿里云域名备案&lt;/h2&gt;
&lt;p&gt;会有一个验证短信，要自己上网页去验证，不要因为自己疏忽就忘了，然后就被打回来了QAQ，开始以为是什么骚扰短信呢&lt;/p&gt;
&lt;h2 id=&#34;kali-linux&#34;&gt;Kali Linux&lt;/h2&gt;
&lt;p&gt;黑客专用的系统，有空的时候可以看看，学习一下系统安全知识&lt;/p&gt;
&lt;h2 id=&#34;gfw&#34;&gt;GFW&lt;/h2&gt;
&lt;p&gt;自己搭的vpn突然用不了，后来发现就是被墙了（ip banned），解决方式，就是换一个ip&lt;/p&gt;
</description>
        </item>
        <item>
        <title>《Spring源码深度解析》读后感(二)Bean的标签解析</title>
        <link>https://lllovol.com/p/spring-source-code-2/</link>
        <pubDate>Thu, 17 Jan 2019 11:56:50 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring-source-code-2/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/1.jpg" alt="Featured image of post 《Spring源码深度解析》读后感(二)Bean的标签解析" /&gt;&lt;h1 id=&#34;两种标签&#34;&gt;两种标签&lt;/h1&gt;
&lt;p&gt;Spring中的标签的包括默认的标签和自定义的标签两种，而这两种标签的用法和解析方式存在着很大的不同。&lt;/p&gt;
&lt;h1 id=&#34;默认标签的解析&#34;&gt;默认标签的解析&lt;/h1&gt;
&lt;p&gt;默认标签的解析是在parseDefaultElement函数中进行的，函数中的功能逻辑一目了然，分别对4种不同的标签做了不同的处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;import&lt;/li&gt;
&lt;li&gt;alias&lt;/li&gt;
&lt;li&gt;bean&lt;/li&gt;
&lt;li&gt;beans&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;bean标签的解析以及注册&#34;&gt;bean标签的解析以及注册&lt;/h1&gt;
&lt;p&gt;在4种标签的解析中，对bean的解析最为复杂也最为重要。因此由此深入，如果将此标签的解析过程理解了，其他标签的解析自然也会迎刃而解。&lt;/p&gt;
&lt;h2 id=&#34;processbeandefinitioneledelegate&#34;&gt;processBeanDefinition（ele,delegate）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Process the given bean element, parsing the bean definition
 * and registering it with the registry.
 */
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
  if (bdHolder != null) {
    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
    try {
      // Register the final decorated instance.
      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
    }
    catch (BeanDefinitionStoreException ex) {
      getReaderContext().error(&amp;quot;Failed to register bean definition with name &#39;&amp;quot; +
          bdHolder.getBeanName() + &amp;quot;&#39;&amp;quot;, ele, ex);
    }
    // Send registration event.
    getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;首先委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析，返回BeanDefinitionHolder类型的实例bdHolder。在这个方法之后，bdHolder实例已经包含了我们配置中的各种属性了，例如class、name、id、alias之类的属性了。&lt;/li&gt;
&lt;li&gt;当返回的bdHolder不为空的情况下，如果存在默认标签下的子节点下再有自定义属性，还需要在此对自定义标签进行解析。&lt;/li&gt;
&lt;li&gt;解析完成后，需要对解析后的bdHolder进行注册，同样，注册操作委托给了BeanDefinitionReaderUtils的registerBeanDefinition方法。&lt;/li&gt;
&lt;li&gt;最后发出响应时间，通知相关的监听器，在这个时候，这个bean已经加载完成了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解析beandefinition&#34;&gt;解析BeanDefinition&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Parses the supplied {@code &amp;lt;bean&amp;gt;} element. May return {@code null}
 * if there were errors during parse. Errors are reported to the
 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
 */
@Nullable
public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
  return parseBeanDefinitionElement(ele, null);
}

 /**
  * Parses the supplied {@code &amp;lt;bean&amp;gt;} element. May return {@code null}
  * if there were errors during parse. Errors are reported to the
  * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
  */
 @Nullable
 public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
    //解析id的属性
  String id = ele.getAttribute(ID_ATTRIBUTE);
    //解析name的属性
  String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
    //分割name的属性
  List&amp;lt;String&amp;gt; aliases = new ArrayList&amp;lt;&amp;gt;();
  if (StringUtils.hasLength(nameAttr)) {
   String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
   aliases.addAll(Arrays.asList(nameArr));
  }

  String beanName = id;
  if (!StringUtils.hasText(beanName) &amp;amp;&amp;amp; !aliases.isEmpty()) {
   beanName = aliases.remove(0);
   if (logger.isDebugEnabled()) {
    logger.debug(&amp;quot;No XML &#39;id&#39; specified - using &#39;&amp;quot; + beanName +
      &amp;quot;&#39; as bean name and &amp;quot; + aliases + &amp;quot; as aliases&amp;quot;);
   }
  }

  if (containingBean == null) {
   checkNameUniqueness(beanName, aliases, ele);
  }
   //对标签中其他属性的解析过程
  AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
  if (beanDefinition != null) {
   if (!StringUtils.hasText(beanName)) {
    try {
    //如果bean没有beanName，就使用默认方法生成beanName
     if (containingBean != null) {
      beanName = BeanDefinitionReaderUtils.generateBeanName(
        beanDefinition, this.readerContext.getRegistry(), true);
     }
     else {
      beanName = this.readerContext.generateBeanName(beanDefinition);
      // Register an alias for the plain bean class name, if still possible,
      // if the generator returned the class name plus a suffix.
      // This is expected for Spring 1.2/2.0 backwards compatibility.
      String beanClassName = beanDefinition.getBeanClassName();
      if (beanClassName != null &amp;amp;&amp;amp;
        beanName.startsWith(beanClassName) &amp;amp;&amp;amp; beanName.length() &amp;gt; beanClassName.length() &amp;amp;&amp;amp;
        !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
       aliases.add(beanClassName);
      }
     }
     if (logger.isDebugEnabled()) {
      logger.debug(&amp;quot;Neither XML &#39;id&#39; nor &#39;name&#39; specified - &amp;quot; +
        &amp;quot;using generated bean name [&amp;quot; + beanName + &amp;quot;]&amp;quot;);
     }
    }
    catch (Exception ex) {
     error(ex.getMessage(), ele);
     return null;
    }
   }
   String[] aliasesArray = StringUtils.toStringArray(aliases);
   return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
  }

  return null;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在当前层，完成的主要工作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.提取了元素中的id和name属性&lt;/li&gt;
&lt;li&gt;2.进一步解析其他所有属性并封装至AbstractBeanDefinition类型的实例中&lt;/li&gt;
&lt;li&gt;3.如果检测到bean没有指定beanName，那么使用默认的规则为此Bean生成BeanName&lt;/li&gt;
&lt;li&gt;4.将获取到的信息封装到BeanDefinitionHolder的实例中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们接着来看一下步骤2中的对标签其他属性的解析过程：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
  * Parse the bean definition itself, without regard to name or aliases. May return
  * {@code null} if problems occurred during the parsing of the bean definition.
  */
 @Nullable
 public AbstractBeanDefinition parseBeanDefinitionElement(
   Element ele, String beanName, @Nullable BeanDefinition containingBean) {

  this.parseState.push(new BeanEntry(beanName));
    //解析class属性
  String className = null;
  if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
   className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
  }
    //解析parent属性
  String parent = null;
  if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
   parent = ele.getAttribute(PARENT_ATTRIBUTE);
  }

  try {
    //使用className和parent创建一个用于承载各种属性的AbstractBeanDefinition实例 bd
   AbstractBeanDefinition bd = createBeanDefinition(className, parent);
    //硬编码解析默认bean的各种属性
   parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
    //提取description
   bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));
    //解析元数据
   parseMetaElements(ele, bd);
    //解析lookup-method属性
   parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
    //解析replace-method属性
   parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

    //解析构造函数参数
   parseConstructorArgElements(ele, bd);

    //解析property子元素
   parsePropertyElements(ele, bd);

    //解析qualified子元素
   parseQualifierElements(ele, bd);

   bd.setResource(this.readerContext.getResource());
   bd.setSource(extractSource(ele));

   return bd;
  }
  catch (ClassNotFoundException ex) {
   error(&amp;quot;Bean class [&amp;quot; + className + &amp;quot;] not found&amp;quot;, ele, ex);
  }
  catch (NoClassDefFoundError err) {
   error(&amp;quot;Class that bean class [&amp;quot; + className + &amp;quot;] depends on not found&amp;quot;, ele, err);
  }
  catch (Throwable ex) {
   error(&amp;quot;Unexpected failure during bean definition parsing&amp;quot;, ele, ex);
  }
  finally {
   this.parseState.pop();
  }

  return null;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;bean标签的所有属性，不论是常用的还是不常用的我们都按到了，尽管有些复杂的属性需要进一步解析。接下来主要就是看一些复杂标签属性的解析。&lt;/p&gt;
&lt;h3 id=&#34;创建用于属性承载的beandefinitioncreatebeandefinition&#34;&gt;创建用于属性承载的BeanDefinition（CreateBeanDefinition）&lt;/h3&gt;
&lt;p&gt;BeanDefinition是一个接口，在Spring中存在三种实现：RootBeanDefinition，ChildBeanDefinition,GenericBeanDefinition。三种实现方式均集成了AbstractBeanDefinition，其中BeanDefinition是配置文件&lt;!-- raw HTML omitted --&gt;元素标签的内部表示形式。（&lt;!-- raw HTML omitted --&gt;元素标签拥有class、scope、lazy-init等配置属性，而BeanDefinition咋提供了相应的beanClass、scope、LazyInit属性，BeanDefinition和&lt;!-- raw HTML omitted --&gt;中的属性是一一对应的。其中RootBeanDefinition是最常用的实现类）。&lt;br&gt;
在配置文件中可以定义父&lt;!-- raw HTML omitted --&gt;和子&lt;!-- raw HTML omitted --&gt;，父&lt;!-- raw HTML omitted --&gt;使用RootBeanDefinition来表示，子&lt;!-- raw HTML omitted --&gt;使用ChildBeanDefinition来表示，而没有父&lt;!-- raw HTML omitted --&gt;的&lt;!-- raw HTML omitted --&gt;就用RootBeanDefinition来表示。AbstractBeanDefinition对两者共同的类信息进行抽象。
Spring通过BeanDefinition将配置文件中的&lt;!-- raw HTML omitted --&gt;配置信息转化为容器的内部表示，然后将这些BeanDefinition注册到BeanDefinitionRegistry当中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/%e3%80%8aSpring%e6%ba%90%e7%a0%81%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90%e3%80%8b%e8%af%bb%e5%90%8e%e6%84%9f%28%e4%ba%8c%29_files/64484741.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;64484741.png&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;要解析属性，首先要创建用于承载属性的实例，也就是创建GenericBeanDefinition类型的实例，而  AbstractBeanDefinition bd = createBeanDefinition(className, parent);就是实现这个功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
  * Create a new GenericBeanDefinition for the given parent name and class name,
  * eagerly loading the bean class if a ClassLoader has been specified.
  * @param parentName the name of the parent bean, if any
  * @param className the name of the bean class, if any
  * @param classLoader the ClassLoader to use for loading bean classes
  * (can be {@code null} to just register bean classes by name)
  * @return the bean definition
  * @throws ClassNotFoundException if the bean class could not be loaded
  */
 public static AbstractBeanDefinition createBeanDefinition(
   @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {

  GenericBeanDefinition bd = new GenericBeanDefinition();
  bd.setParentName(parentName);
  if (className != null) {
   if (classLoader != null) {
    //如果classLoader不为空，则使用以传入的classLoader同一虚拟机加载类对象，否则只是记录ClassName
    bd.setBeanClass(ClassUtils.forName(className, classLoader));
   }
   else {
    bd.setBeanClassName(className);
   }
  }
  return bd;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解析各种属性parsebeandefinitionattributes方法&#34;&gt;解析各种属性(parseBeanDefinitionAttributes方法)&lt;/h3&gt;
&lt;p&gt;在上一步，创建了Bean信息的承载实例字后，就可以进行bean信息的各种属性的解析了。我们进入到parseBeanDefinitionAttributes方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
  * Apply the attributes of the given bean element to the given bean * definition.
  * @param ele bean declaration element
  * @param beanName bean name
  * @param containingBean containing bean definition
  * @return a bean definition initialized according to the bean element attributes
  */
 public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
   @Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {
    //判断是否是单例的属性，如果有的话需要报错
  if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {
   error(&amp;quot;Old 1.x &#39;singleton&#39; attribute in use - upgrade to &#39;scope&#39; declaration&amp;quot;, ele);
  }
    //解析scope属性
  else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
   bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));
  }
  else if (containingBean != null) {
   // Take default from containing bean in case of an inner bean definition.
    //如果在嵌入beanDefinition情况下且没有单独制定scope属性的时候则使用父类默认的属性
   bd.setScope(containingBean.getScope());
  }
    //解析Abstract属性
  if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
   bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));
  }
    //解析lazy-Init属性
  String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);
  if (DEFAULT_VALUE.equals(lazyInit)) {
   lazyInit = this.defaults.getLazyInit();
  }
  bd.setLazyInit(TRUE_VALUE.equals(lazyInit));
    //解析autowire属性
  String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);
  bd.setAutowireMode(getAutowireMode(autowire));
    //解析depend-on的属性
  if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
   String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);
   bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));
  }
    //解析autowireCandidate属性
  String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
  if (&amp;quot;&amp;quot;.equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {
   String candidatePattern = this.defaults.getAutowireCandidates();
   if (candidatePattern != null) {
    String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);
    bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));
   }
  }
  else {
   bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));
  }
    //解析primary属性
  if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
   bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));
  }
    //解析init-method属性
  if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
   String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);
   bd.setInitMethodName(initMethodName);
  }
  else if (this.defaults.getInitMethod() != null) {
   bd.setInitMethodName(this.defaults.getInitMethod());
   bd.setEnforceInitMethod(false);
  }
    //解析destroy-method属性
  if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
   String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);
   bd.setDestroyMethodName(destroyMethodName);
  }
  else if (this.defaults.getDestroyMethod() != null) {
   bd.setDestroyMethodName(this.defaults.getDestroyMethod());
   bd.setEnforceDestroyMethod(false);
  }
    //解析factory-method属性
  if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
   bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));
  }
    //解析factory-bean属性
  if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
   bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));
  }
  return bd;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以看到，这个方法完成了对所有bean属性的解析。&lt;/p&gt;
&lt;h3 id=&#34;解析子元素meta&#34;&gt;解析子元素meta&lt;/h3&gt;
&lt;h4 id=&#34;meta属性的使用&#34;&gt;meta属性的使用&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bean id=&amp;quot;myTestBean&amp;quot; class=&amp;quot;bean.myTestBean&amp;quot;&amp;gt;
　　&amp;lt;meta key = &amp;quot;testStr&amp;quot; value = &amp;quot;aaaaaaaaa&amp;quot;&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码并不会体现在MyTestBean的属性当中，而是一个额外的声明，当需要使用里面的信息的时候可以通过BeanDefinition的getAttribute(key)的方法获取&lt;/p&gt;
&lt;h4 id=&#34;对meta属性的解析代码如下&#34;&gt;对meta属性的解析代码如下&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
    //获取当前节点
  NodeList nl = ele.getChildNodes();
  for (int i = 0; i &amp;lt; nl.getLength(); i++) {
    //提取meta
    Node node = nl.item(i);
    if (isCandidateElement(node) &amp;amp;&amp;amp; nodeNameEquals(node, META_ELEMENT)) {
      Element metaElement = (Element) node;
      String key = metaElement.getAttribute(KEY_ATTRIBUTE);
      String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
        //使用key和value构造BeanMetadataAttribute
      BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
      attribute.setSource(extractSource(metaElement));
        //记录信息
      attributeAccessor.addMetadataAttribute(attribute);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解析子元素lookup-method&#34;&gt;解析子元素lookup-method&lt;/h3&gt;
&lt;p&gt;这个属性不是很常用，通常称这个为获取器注入。（P44）&lt;/p&gt;
&lt;h3 id=&#34;解析子元素replaced-method&#34;&gt;解析子元素replaced-method&lt;/h3&gt;
&lt;p&gt;方法替换：可以在运行时用新的方法替换现有的方法。replaced-method不但可以动态返回实体bean，而且还能动态地更改原有方法的逻辑。（P46）&lt;/p&gt;
&lt;h3 id=&#34;解析子元素constructor-arg&#34;&gt;解析子元素constructor-arg&lt;/h3&gt;
&lt;p&gt;对构造函数进行的解析（P48）&lt;/p&gt;
&lt;h3 id=&#34;解析子元素property&#34;&gt;解析子元素property&lt;/h3&gt;
&lt;p&gt;p53&lt;/p&gt;
&lt;h3 id=&#34;解析子元素qualifier&#34;&gt;解析子元素qualifier&lt;/h3&gt;
&lt;p&gt;p54&lt;/p&gt;
&lt;h2 id=&#34;abstractbeandefinition属性&#34;&gt;AbstractBeanDefinition属性&lt;/h2&gt;
&lt;p&gt;至此完成了XML文档到GenericBeanDefinition的转换。但是Generic只是子类实现，大部分通用的属性都是保存在AbstractBeanDefinition这个类中的。下面查看了一下spring boot的AbstractBeanDefinition,和书中的spring 的差别还是很大的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Base class for concrete, full-fledged {@link BeanDefinition} classes,
 * factoring out common properties of {@link GenericBeanDefinition},
 * {@link RootBeanDefinition}, and {@link ChildBeanDefinition}.
 *
 * &amp;lt;p&amp;gt;The autowire constants match the ones defined in the
 * {@link org.springframework.beans.factory.config.AutowireCapableBeanFactory}
 * interface.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Rob Harrop
 * @author Mark Fisher
 * @see GenericBeanDefinition
 * @see RootBeanDefinition
 * @see ChildBeanDefinition
 */
@SuppressWarnings(&amp;quot;serial&amp;quot;)
public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor
        implements BeanDefinition, Cloneable {

    /**
     * Constant for the default scope name: {@code &amp;quot;&amp;quot;}, equivalent to singleton
     * status unless overridden from a parent bean definition (if applicable).
     */
    public static final String SCOPE_DEFAULT = &amp;quot;&amp;quot;;

    /**
     * Constant that indicates no autowiring at all.
     * @see #setAutowireMode
     */
    public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;

    /**
     * Constant that indicates autowiring bean properties by name.
     * @see #setAutowireMode
     */
    public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;

    /**
     * Constant that indicates autowiring bean properties by type.
     * @see #setAutowireMode
     */
    public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;

    /**
     * Constant that indicates autowiring a constructor.
     * @see #setAutowireMode
     */
    public static final int AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;

    /**
     * Constant that indicates determining an appropriate autowire strategy
     * through introspection of the bean class.
     * @see #setAutowireMode
     * @deprecated as of Spring 3.0: If you are using mixed autowiring strategies,
     * use annotation-based autowiring for clearer demarcation of autowiring needs.
     */
    @Deprecated
    public static final int AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;

    /**
     * Constant that indicates no dependency check at all.
     * @see #setDependencyCheck
     */
    public static final int DEPENDENCY_CHECK_NONE = 0;

    /**
     * Constant that indicates dependency checking for object references.
     * @see #setDependencyCheck
     */
    public static final int DEPENDENCY_CHECK_OBJECTS = 1;

    /**
     * Constant that indicates dependency checking for &amp;quot;simple&amp;quot; properties.
     * @see #setDependencyCheck
     * @see org.springframework.beans.BeanUtils#isSimpleProperty
     */
    public static final int DEPENDENCY_CHECK_SIMPLE = 2;

    /**
     * Constant that indicates dependency checking for all properties
     * (object references as well as &amp;quot;simple&amp;quot; properties).
     * @see #setDependencyCheck
     */
    public static final int DEPENDENCY_CHECK_ALL = 3;

    /**
     * Constant that indicates the container should attempt to infer the
     * {@link #setDestroyMethodName destroy method name} for a bean as opposed to
     * explicit specification of a method name. The value {@value} is specifically
     * designed to include characters otherwise illegal in a method name, ensuring
     * no possibility of collisions with legitimately named methods having the same
     * name.
     * &amp;lt;p&amp;gt;Currently, the method names detected during destroy method inference
     * are &amp;quot;close&amp;quot; and &amp;quot;shutdown&amp;quot;, if present on the specific bean class.
     */
    public static final String INFER_METHOD = &amp;quot;(inferred)&amp;quot;;


    @Nullable
    private volatile Object beanClass;
    //bean的作用范围，对应bean属性scope
    @Nullable
    private String scope = SCOPE_DEFAULT;

    private boolean abstractFlag = false;

    private boolean lazyInit = false;

    private int autowireMode = AUTOWIRE_NO;

    private int dependencyCheck = DEPENDENCY_CHECK_NONE;

    @Nullable
    private String[] dependsOn;

    private boolean autowireCandidate = true;

    private boolean primary = false;

    private final Map&amp;lt;String, AutowireCandidateQualifier&amp;gt; qualifiers = new LinkedHashMap&amp;lt;&amp;gt;(0);

    @Nullable
    private Supplier&amp;lt;?&amp;gt; instanceSupplier;

    private boolean nonPublicAccessAllowed = true;

    private boolean lenientConstructorResolution = true;

    @Nullable
    private String factoryBeanName;

    @Nullable
    private String factoryMethodName;

    @Nullable
    private ConstructorArgumentValues constructorArgumentValues;

    @Nullable
    private MutablePropertyValues propertyValues;

    @Nullable
    private MethodOverrides methodOverrides;

    @Nullable
    private String initMethodName;

    @Nullable
    private String destroyMethodName;

    private boolean enforceInitMethod = true;

    private boolean enforceDestroyMethod = true;

    private boolean synthetic = false;

    private int role = BeanDefinition.ROLE_APPLICATION;

    @Nullable
    private String description;

    @Nullable
    private Resource resource;


    /**
     * Create a new AbstractBeanDefinition with default settings.
     */
    protected AbstractBeanDefinition() {
        this(null, null);
    }

    /**
     * Create a new AbstractBeanDefinition with the given
     * constructor argument values and property values.
     */
    protected AbstractBeanDefinition(@Nullable ConstructorArgumentValues cargs, @Nullable MutablePropertyValues pvs) {
        this.constructorArgumentValues = cargs;
        this.propertyValues = pvs;
    }

    /**
     * Create a new AbstractBeanDefinition as a deep copy of the given
     * bean definition.
     * @param original the original bean definition to copy from
     */
    protected AbstractBeanDefinition(BeanDefinition original) {
        setParentName(original.getParentName());
        setBeanClassName(original.getBeanClassName());
        setScope(original.getScope());
        setAbstract(original.isAbstract());
        setLazyInit(original.isLazyInit());
        setFactoryBeanName(original.getFactoryBeanName());
        setFactoryMethodName(original.getFactoryMethodName());
        setRole(original.getRole());
        setSource(original.getSource());
        copyAttributesFrom(original);

        if (original instanceof AbstractBeanDefinition) {
            AbstractBeanDefinition originalAbd = (AbstractBeanDefinition) original;
            if (originalAbd.hasBeanClass()) {
                setBeanClass(originalAbd.getBeanClass());
            }
            if (originalAbd.hasConstructorArgumentValues()) {
                setConstructorArgumentValues(new ConstructorArgumentValues(original.getConstructorArgumentValues()));
            }
            if (originalAbd.hasPropertyValues()) {
                setPropertyValues(new MutablePropertyValues(original.getPropertyValues()));
            }
            if (originalAbd.hasMethodOverrides()) {
                setMethodOverrides(new MethodOverrides(originalAbd.getMethodOverrides()));
            }
            setAutowireMode(originalAbd.getAutowireMode());
            setDependencyCheck(originalAbd.getDependencyCheck());
            setDependsOn(originalAbd.getDependsOn());
            setAutowireCandidate(originalAbd.isAutowireCandidate());
            setPrimary(originalAbd.isPrimary());
            copyQualifiersFrom(originalAbd);
            setInstanceSupplier(originalAbd.getInstanceSupplier());
            setNonPublicAccessAllowed(originalAbd.isNonPublicAccessAllowed());
            setLenientConstructorResolution(originalAbd.isLenientConstructorResolution());
            setInitMethodName(originalAbd.getInitMethodName());
            setEnforceInitMethod(originalAbd.isEnforceInitMethod());
            setDestroyMethodName(originalAbd.getDestroyMethodName());
            setEnforceDestroyMethod(originalAbd.isEnforceDestroyMethod());
            setSynthetic(originalAbd.isSynthetic());
            setResource(originalAbd.getResource());
        }
        else {
            setConstructorArgumentValues(new ConstructorArgumentValues(original.getConstructorArgumentValues()));
            setPropertyValues(new MutablePropertyValues(original.getPropertyValues()));
            setResourceDescription(original.getResourceDescription());
        }
    }


    /**
     * Override settings in this bean definition (presumably a copied parent
     * from a parent-child inheritance relationship) from the given bean
     * definition (presumably the child).
     * &amp;lt;ul&amp;gt;
     * &amp;lt;li&amp;gt;Will override beanClass if specified in the given bean definition.
     * &amp;lt;li&amp;gt;Will always take {@code abstract}, {@code scope},
     * {@code lazyInit}, {@code autowireMode}, {@code dependencyCheck},
     * and {@code dependsOn} from the given bean definition.
     * &amp;lt;li&amp;gt;Will add {@code constructorArgumentValues}, {@code propertyValues},
     * {@code methodOverrides} from the given bean definition to existing ones.
     * &amp;lt;li&amp;gt;Will override {@code factoryBeanName}, {@code factoryMethodName},
     * {@code initMethodName}, and {@code destroyMethodName} if specified
     * in the given bean definition.
     * &amp;lt;/ul&amp;gt;
     */
    public void overrideFrom(BeanDefinition other) {
        if (StringUtils.hasLength(other.getBeanClassName())) {
            setBeanClassName(other.getBeanClassName());
        }
        if (StringUtils.hasLength(other.getScope())) {
            setScope(other.getScope());
        }
        setAbstract(other.isAbstract());
        setLazyInit(other.isLazyInit());
        if (StringUtils.hasLength(other.getFactoryBeanName())) {
            setFactoryBeanName(other.getFactoryBeanName());
        }
        if (StringUtils.hasLength(other.getFactoryMethodName())) {
            setFactoryMethodName(other.getFactoryMethodName());
        }
        setRole(other.getRole());
        setSource(other.getSource());
        copyAttributesFrom(other);

        if (other instanceof AbstractBeanDefinition) {
            AbstractBeanDefinition otherAbd = (AbstractBeanDefinition) other;
            if (otherAbd.hasBeanClass()) {
                setBeanClass(otherAbd.getBeanClass());
            }
            if (otherAbd.hasConstructorArgumentValues()) {
                getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues());
            }
            if (otherAbd.hasPropertyValues()) {
                getPropertyValues().addPropertyValues(other.getPropertyValues());
            }
            if (otherAbd.hasMethodOverrides()) {
                getMethodOverrides().addOverrides(otherAbd.getMethodOverrides());
            }
            setAutowireMode(otherAbd.getAutowireMode());
            setDependencyCheck(otherAbd.getDependencyCheck());
            setDependsOn(otherAbd.getDependsOn());
            setAutowireCandidate(otherAbd.isAutowireCandidate());
            setPrimary(otherAbd.isPrimary());
            copyQualifiersFrom(otherAbd);
            setInstanceSupplier(otherAbd.getInstanceSupplier());
            setNonPublicAccessAllowed(otherAbd.isNonPublicAccessAllowed());
            setLenientConstructorResolution(otherAbd.isLenientConstructorResolution());
            if (otherAbd.getInitMethodName() != null) {
                setInitMethodName(otherAbd.getInitMethodName());
                setEnforceInitMethod(otherAbd.isEnforceInitMethod());
            }
            if (otherAbd.getDestroyMethodName() != null) {
                setDestroyMethodName(otherAbd.getDestroyMethodName());
                setEnforceDestroyMethod(otherAbd.isEnforceDestroyMethod());
            }
            setSynthetic(otherAbd.isSynthetic());
            setResource(otherAbd.getResource());
        }
        else {
            getConstructorArgumentValues().addArgumentValues(other.getConstructorArgumentValues());
            getPropertyValues().addPropertyValues(other.getPropertyValues());
            setResourceDescription(other.getResourceDescription());
        }
    }

    /**
     * Apply the provided default values to this bean.
     * @param defaults the defaults to apply
     */
    public void applyDefaults(BeanDefinitionDefaults defaults) {
        setLazyInit(defaults.isLazyInit());
        setAutowireMode(defaults.getAutowireMode());
        setDependencyCheck(defaults.getDependencyCheck());
        setInitMethodName(defaults.getInitMethodName());
        setEnforceInitMethod(false);
        setDestroyMethodName(defaults.getDestroyMethodName());
        setEnforceDestroyMethod(false);
    }


    /**
     * Specify the bean class name of this bean definition.
     */
    @Override
    public void setBeanClassName(@Nullable String beanClassName) {
        this.beanClass = beanClassName;
    }

    /**
     * Return the current bean class name of this bean definition.
     */
    @Override
    @Nullable
    public String getBeanClassName() {
        Object beanClassObject = this.beanClass;
        if (beanClassObject instanceof Class) {
            return ((Class&amp;lt;?&amp;gt;) beanClassObject).getName();
        }
        else {
            return (String) beanClassObject;
        }
    }

    /**
     * Specify the class for this bean.
     */
    public void setBeanClass(@Nullable Class&amp;lt;?&amp;gt; beanClass) {
        this.beanClass = beanClass;
    }

    /**
     * Return the class of the wrapped bean, if already resolved.
     * @return the bean class, or {@code null} if none defined
     * @throws IllegalStateException if the bean definition does not define a bean class,
     * or a specified bean class name has not been resolved into an actual Class
     */
    public Class&amp;lt;?&amp;gt; getBeanClass() throws IllegalStateException {
        Object beanClassObject = this.beanClass;
        if (beanClassObject == null) {
            throw new IllegalStateException(&amp;quot;No bean class specified on bean definition&amp;quot;);
        }
        if (!(beanClassObject instanceof Class)) {
            throw new IllegalStateException(
                    &amp;quot;Bean class name [&amp;quot; + beanClassObject + &amp;quot;] has not been resolved into an actual Class&amp;quot;);
        }
        return (Class&amp;lt;?&amp;gt;) beanClassObject;
    }

    /**
     * Return whether this definition specifies a bean class.
     */
    public boolean hasBeanClass() {
        return (this.beanClass instanceof Class);
    }

    /**
     * Determine the class of the wrapped bean, resolving it from a
     * specified class name if necessary. Will also reload a specified
     * Class from its name when called with the bean class already resolved.
     * @param classLoader the ClassLoader to use for resolving a (potential) class name
     * @return the resolved bean class
     * @throws ClassNotFoundException if the class name could be resolved
     */
    @Nullable
    public Class&amp;lt;?&amp;gt; resolveBeanClass(@Nullable ClassLoader classLoader) throws ClassNotFoundException {
        String className = getBeanClassName();
        if (className == null) {
            return null;
        }
        Class&amp;lt;?&amp;gt; resolvedClass = ClassUtils.forName(className, classLoader);
        this.beanClass = resolvedClass;
        return resolvedClass;
    }

    /**
     * Set the name of the target scope for the bean.
     * &amp;lt;p&amp;gt;The default is singleton status, although this is only applied once
     * a bean definition becomes active in the containing factory. A bean
     * definition may eventually inherit its scope from a parent bean definition.
     * For this reason, the default scope name is an empty string (i.e., {@code &amp;quot;&amp;quot;}),
     * with singleton status being assumed until a resolved scope is set.
     * @see #SCOPE_SINGLETON
     * @see #SCOPE_PROTOTYPE
     */
    @Override
    public void setScope(@Nullable String scope) {
        this.scope = scope;
    }

    /**
     * Return the name of the target scope for the bean.
     */
    @Override
    @Nullable
    public String getScope() {
        return this.scope;
    }

    /**
     * Return whether this a &amp;lt;b&amp;gt;Singleton&amp;lt;/b&amp;gt;, with a single shared instance
     * returned from all calls.
     * @see #SCOPE_SINGLETON
     */
    @Override
    public boolean isSingleton() {
        return SCOPE_SINGLETON.equals(scope) || SCOPE_DEFAULT.equals(scope);
    }

    /**
     * Return whether this a &amp;lt;b&amp;gt;Prototype&amp;lt;/b&amp;gt;, with an independent instance
     * returned for each call.
     * @see #SCOPE_PROTOTYPE
     */
    @Override
    public boolean isPrototype() {
        return SCOPE_PROTOTYPE.equals(scope);
    }

    /**
     * Set if this bean is &amp;quot;abstract&amp;quot;, i.e. not meant to be instantiated itself but
     * rather just serving as parent for concrete child bean definitions.
     * &amp;lt;p&amp;gt;Default is &amp;quot;false&amp;quot;. Specify true to tell the bean factory to not try to
     * instantiate that particular bean in any case.
     */
    public void setAbstract(boolean abstractFlag) {
        this.abstractFlag = abstractFlag;
    }

    /**
     * Return whether this bean is &amp;quot;abstract&amp;quot;, i.e. not meant to be instantiated
     * itself but rather just serving as parent for concrete child bean definitions.
     */
    @Override
    public boolean isAbstract() {
        return this.abstractFlag;
    }

    /**
     * Set whether this bean should be lazily initialized.
     * &amp;lt;p&amp;gt;If {@code false}, the bean will get instantiated on startup by bean
     * factories that perform eager initialization of singletons.
     */
    @Override
    public void setLazyInit(boolean lazyInit) {
        this.lazyInit = lazyInit;
    }

    /**
     * Return whether this bean should be lazily initialized, i.e. not
     * eagerly instantiated on startup. Only applicable to a singleton bean.
     */
    @Override
    public boolean isLazyInit() {
        return this.lazyInit;
    }

    /**
     * Set the autowire mode. This determines whether any automagical detection
     * and setting of bean references will happen. Default is AUTOWIRE_NO,
     * which means there&#39;s no autowire.
     * @param autowireMode the autowire mode to set.
     * Must be one of the constants defined in this class.
     * @see #AUTOWIRE_NO
     * @see #AUTOWIRE_BY_NAME
     * @see #AUTOWIRE_BY_TYPE
     * @see #AUTOWIRE_CONSTRUCTOR
     * @see #AUTOWIRE_AUTODETECT
     */
    public void setAutowireMode(int autowireMode) {
        this.autowireMode = autowireMode;
    }

    /**
     * Return the autowire mode as specified in the bean definition.
     */
    public int getAutowireMode() {
        return this.autowireMode;
    }

    /**
     * Return the resolved autowire code,
     * (resolving AUTOWIRE_AUTODETECT to AUTOWIRE_CONSTRUCTOR or AUTOWIRE_BY_TYPE).
     * @see #AUTOWIRE_AUTODETECT
     * @see #AUTOWIRE_CONSTRUCTOR
     * @see #AUTOWIRE_BY_TYPE
     */
    public int getResolvedAutowireMode() {
        if (this.autowireMode == AUTOWIRE_AUTODETECT) {
            // Work out whether to apply setter autowiring or constructor autowiring.
            // If it has a no-arg constructor it&#39;s deemed to be setter autowiring,
            // otherwise we&#39;ll try constructor autowiring.
            Constructor&amp;lt;?&amp;gt;[] constructors = getBeanClass().getConstructors();
            for (Constructor&amp;lt;?&amp;gt; constructor : constructors) {
                if (constructor.getParameterCount() == 0) {
                    return AUTOWIRE_BY_TYPE;
                }
            }
            return AUTOWIRE_CONSTRUCTOR;
        }
        else {
            return this.autowireMode;
        }
    }

    /**
     * Set the dependency check code.
     * @param dependencyCheck the code to set.
     * Must be one of the four constants defined in this class.
     * @see #DEPENDENCY_CHECK_NONE
     * @see #DEPENDENCY_CHECK_OBJECTS
     * @see #DEPENDENCY_CHECK_SIMPLE
     * @see #DEPENDENCY_CHECK_ALL
     */
    public void setDependencyCheck(int dependencyCheck) {
        this.dependencyCheck = dependencyCheck;
    }

    /**
     * Return the dependency check code.
     */
    public int getDependencyCheck() {
        return this.dependencyCheck;
    }

    /**
     * Set the names of the beans that this bean depends on being initialized.
     * The bean factory will guarantee that these beans get initialized first.
     * &amp;lt;p&amp;gt;Note that dependencies are normally expressed through bean properties or
     * constructor arguments. This property should just be necessary for other kinds
     * of dependencies like statics (*ugh*) or database preparation on startup.
     */
    @Override
    public void setDependsOn(@Nullable String... dependsOn) {
        this.dependsOn = dependsOn;
    }

    /**
     * Return the bean names that this bean depends on.
     */
    @Override
    @Nullable
    public String[] getDependsOn() {
        return this.dependsOn;
    }

    /**
     * Set whether this bean is a candidate for getting autowired into some other bean.
     * &amp;lt;p&amp;gt;Note that this flag is designed to only affect type-based autowiring.
     * It does not affect explicit references by name, which will get resolved even
     * if the specified bean is not marked as an autowire candidate. As a consequence,
     * autowiring by name will nevertheless inject a bean if the name matches.
     * @see #AUTOWIRE_BY_TYPE
     * @see #AUTOWIRE_BY_NAME
     */
    @Override
    public void setAutowireCandidate(boolean autowireCandidate) {
        this.autowireCandidate = autowireCandidate;
    }

    /**
     * Return whether this bean is a candidate for getting autowired into some other bean.
     */
    @Override
    public boolean isAutowireCandidate() {
        return this.autowireCandidate;
    }

    /**
     * Set whether this bean is a primary autowire candidate.
     * &amp;lt;p&amp;gt;If this value is {@code true} for exactly one bean among multiple
     * matching candidates, it will serve as a tie-breaker.
     */
    @Override
    public void setPrimary(boolean primary) {
        this.primary = primary;
    }

    /**
     * Return whether this bean is a primary autowire candidate.
     */
    @Override
    public boolean isPrimary() {
        return this.primary;
    }

    /**
     * Register a qualifier to be used for autowire candidate resolution,
     * keyed by the qualifier&#39;s type name.
     * @see AutowireCandidateQualifier#getTypeName()
     */
    public void addQualifier(AutowireCandidateQualifier qualifier) {
        this.qualifiers.put(qualifier.getTypeName(), qualifier);
    }

    /**
     * Return whether this bean has the specified qualifier.
     */
    public boolean hasQualifier(String typeName) {
        return this.qualifiers.keySet().contains(typeName);
    }

    /**
     * Return the qualifier mapped to the provided type name.
     */
    @Nullable
    public AutowireCandidateQualifier getQualifier(String typeName) {
        return this.qualifiers.get(typeName);
    }

    /**
     * Return all registered qualifiers.
     * @return the Set of {@link AutowireCandidateQualifier} objects.
     */
    public Set&amp;lt;AutowireCandidateQualifier&amp;gt; getQualifiers() {
        return new LinkedHashSet&amp;lt;&amp;gt;(this.qualifiers.values());
    }

    /**
     * Copy the qualifiers from the supplied AbstractBeanDefinition to this bean definition.
     * @param source the AbstractBeanDefinition to copy from
     */
    public void copyQualifiersFrom(AbstractBeanDefinition source) {
        Assert.notNull(source, &amp;quot;Source must not be null&amp;quot;);
        this.qualifiers.putAll(source.qualifiers);
    }

    /**
     * Specify a callback for creating an instance of the bean,
     * as an alternative to a declaratively specified factory method.
     * &amp;lt;p&amp;gt;If such a callback is set, it will override any other constructor
     * or factory method metadata. However, bean property population and
     * potential annotation-driven injection will still apply as usual.
     * @since 5.0
     * @see #setConstructorArgumentValues(ConstructorArgumentValues)
     * @see #setPropertyValues(MutablePropertyValues)
     */
    public void setInstanceSupplier(@Nullable Supplier&amp;lt;?&amp;gt; instanceSupplier) {
        this.instanceSupplier = instanceSupplier;
    }

    /**
     * Return a callback for creating an instance of the bean, if any.
     * @since 5.0
     */
    @Nullable
    public Supplier&amp;lt;?&amp;gt; getInstanceSupplier() {
        return this.instanceSupplier;
    }

    /**
     * Specify whether to allow access to non-public constructors and methods,
     * for the case of externalized metadata pointing to those. The default is
     * {@code true}; switch this to {@code false} for public access only.
     * &amp;lt;p&amp;gt;This applies to constructor resolution, factory method resolution,
     * and also init/destroy methods. Bean property accessors have to be public
     * in any case and are not affected by this setting.
     * &amp;lt;p&amp;gt;Note that annotation-driven configuration will still access non-public
     * members as far as they have been annotated. This setting applies to
     * externalized metadata in this bean definition only.
     */
    public void setNonPublicAccessAllowed(boolean nonPublicAccessAllowed) {
        this.nonPublicAccessAllowed = nonPublicAccessAllowed;
    }

    /**
     * Return whether to allow access to non-public constructors and methods.
     */
    public boolean isNonPublicAccessAllowed() {
        return this.nonPublicAccessAllowed;
    }

    /**
     * Specify whether to resolve constructors in lenient mode ({@code true},
     * which is the default) or to switch to strict resolution (throwing an exception
     * in case of ambiguous constructors that all match when converting the arguments,
     * whereas lenient mode would use the one with the &#39;closest&#39; type matches).
     */
    public void setLenientConstructorResolution(boolean lenientConstructorResolution) {
        this.lenientConstructorResolution = lenientConstructorResolution;
    }

    /**
     * Return whether to resolve constructors in lenient mode or in strict mode.
     */
    public boolean isLenientConstructorResolution() {
        return this.lenientConstructorResolution;
    }

    /**
     * Specify the factory bean to use, if any.
     * This the name of the bean to call the specified factory method on.
     * @see #setFactoryMethodName
     */
    @Override
    public void setFactoryBeanName(@Nullable String factoryBeanName) {
        this.factoryBeanName = factoryBeanName;
    }

    /**
     * Return the factory bean name, if any.
     */
    @Override
    @Nullable
    public String getFactoryBeanName() {
        return this.factoryBeanName;
    }

    /**
     * Specify a factory method, if any. This method will be invoked with
     * constructor arguments, or with no arguments if none are specified.
     * The method will be invoked on the specified factory bean, if any,
     * or otherwise as a static method on the local bean class.
     * @see #setFactoryBeanName
     * @see #setBeanClassName
     */
    @Override
    public void setFactoryMethodName(@Nullable String factoryMethodName) {
        this.factoryMethodName = factoryMethodName;
    }

    /**
     * Return a factory method, if any.
     */
    @Override
    @Nullable
    public String getFactoryMethodName() {
        return this.factoryMethodName;
    }

    /**
     * Specify constructor argument values for this bean.
     */
    public void setConstructorArgumentValues(ConstructorArgumentValues constructorArgumentValues) {
        this.constructorArgumentValues = constructorArgumentValues;
    }

    /**
     * Return constructor argument values for this bean (never {@code null}).
     */
    @Override
    public ConstructorArgumentValues getConstructorArgumentValues() {
        if (this.constructorArgumentValues == null) {
            this.constructorArgumentValues = new ConstructorArgumentValues();
        }
        return this.constructorArgumentValues;
    }

    /**
     * Return if there are constructor argument values defined for this bean.
     */
    @Override
    public boolean hasConstructorArgumentValues() {
        return (this.constructorArgumentValues != null &amp;amp;&amp;amp; !this.constructorArgumentValues.isEmpty());
    }

    /**
     * Specify property values for this bean, if any.
     */
    public void setPropertyValues(MutablePropertyValues propertyValues) {
        this.propertyValues = propertyValues;
    }

    /**
     * Return property values for this bean (never {@code null}).
     */
    @Override
    public MutablePropertyValues getPropertyValues() {
        if (this.propertyValues == null) {
            this.propertyValues = new MutablePropertyValues();
        }
        return this.propertyValues;
    }

    /**
     * Return if there are property values values defined for this bean.
     * @since 5.0.2
     */
    @Override
    public boolean hasPropertyValues() {
        return (this.propertyValues != null &amp;amp;&amp;amp; !this.propertyValues.isEmpty());
    }

    /**
     * Specify method overrides for the bean, if any.
     */
    public void setMethodOverrides(MethodOverrides methodOverrides) {
        this.methodOverrides = methodOverrides;
    }

    /**
     * Return information about methods to be overridden by the IoC
     * container. This will be empty if there are no method overrides.
     * &amp;lt;p&amp;gt;Never returns {@code null}.
     */
    public MethodOverrides getMethodOverrides() {
        if (this.methodOverrides == null) {
            this.methodOverrides = new MethodOverrides();
        }
        return this.methodOverrides;
    }

    /**
     * Return if there are method overrides defined for this bean.
     * @since 5.0.2
     */
    public boolean hasMethodOverrides() {
        return (this.methodOverrides != null &amp;amp;&amp;amp; !this.methodOverrides.isEmpty());
    }

    /**
     * Set the name of the initializer method.
     * &amp;lt;p&amp;gt;The default is {@code null} in which case there is no initializer method.
     */
    public void setInitMethodName(@Nullable String initMethodName) {
        this.initMethodName = initMethodName;
    }

    /**
     * Return the name of the initializer method.
     */
    @Nullable
    public String getInitMethodName() {
        return this.initMethodName;
    }

    /**
     * Specify whether or not the configured init method is the default.
     * &amp;lt;p&amp;gt;The default value is {@code false}.
     * @see #setInitMethodName
     */
    public void setEnforceInitMethod(boolean enforceInitMethod) {
        this.enforceInitMethod = enforceInitMethod;
    }

    /**
     * Indicate whether the configured init method is the default.
     * @see #getInitMethodName()
     */
    public boolean isEnforceInitMethod() {
        return this.enforceInitMethod;
    }

    /**
     * Set the name of the destroy method.
     * &amp;lt;p&amp;gt;The default is {@code null} in which case there is no destroy method.
     */
    public void setDestroyMethodName(@Nullable String destroyMethodName) {
        this.destroyMethodName = destroyMethodName;
    }

    /**
     * Return the name of the destroy method.
     */
    @Nullable
    public String getDestroyMethodName() {
        return this.destroyMethodName;
    }

    /**
     * Specify whether or not the configured destroy method is the default.
     * &amp;lt;p&amp;gt;The default value is {@code false}.
     * @see #setDestroyMethodName
     */
    public void setEnforceDestroyMethod(boolean enforceDestroyMethod) {
        this.enforceDestroyMethod = enforceDestroyMethod;
    }

    /**
     * Indicate whether the configured destroy method is the default.
     * @see #getDestroyMethodName
     */
    public boolean isEnforceDestroyMethod() {
        return this.enforceDestroyMethod;
    }

    /**
     * Set whether this bean definition is &#39;synthetic&#39;, that is, not defined
     * by the application itself (for example, an infrastructure bean such
     * as a helper for auto-proxying, created through {@code &amp;lt;aop:config&amp;gt;}).
     */
    public void setSynthetic(boolean synthetic) {
        this.synthetic = synthetic;
    }

    /**
     * Return whether this bean definition is &#39;synthetic&#39;, that is,
     * not defined by the application itself.
     */
    public boolean isSynthetic() {
        return this.synthetic;
    }

    /**
     * Set the role hint for this {@code BeanDefinition}.
     */
    public void setRole(int role) {
        this.role = role;
    }

    /**
     * Return the role hint for this {@code BeanDefinition}.
     */
    @Override
    public int getRole() {
        return this.role;
    }

    /**
     * Set a human-readable description of this bean definition.
     */
    public void setDescription(@Nullable String description) {
        this.description = description;
    }

    /**
     * Return a human-readable description of this bean definition.
     */
    @Override
    @Nullable
    public String getDescription() {
        return this.description;
    }

    /**
     * Set the resource that this bean definition came from
     * (for the purpose of showing context in case of errors).
     */
    public void setResource(@Nullable Resource resource) {
        this.resource = resource;
    }

    /**
     * Return the resource that this bean definition came from.
     */
    @Nullable
    public Resource getResource() {
        return this.resource;
    }

    /**
     * Set a description of the resource that this bean definition
     * came from (for the purpose of showing context in case of errors).
     */
    public void setResourceDescription(@Nullable String resourceDescription) {
        this.resource = (resourceDescription != null ? new DescriptiveResource(resourceDescription) : null);
    }

    /**
     * Return a description of the resource that this bean definition
     * came from (for the purpose of showing context in case of errors).
     */
    @Override
    @Nullable
    public String getResourceDescription() {
        return (this.resource != null ? this.resource.getDescription() : null);
    }

    /**
     * Set the originating (e.g. decorated) BeanDefinition, if any.
     */
    public void setOriginatingBeanDefinition(BeanDefinition originatingBd) {
        this.resource = new BeanDefinitionResource(originatingBd);
    }

    /**
     * Return the originating BeanDefinition, or {@code null} if none.
     * Allows for retrieving the decorated bean definition, if any.
     * &amp;lt;p&amp;gt;Note that this method returns the immediate originator. Iterate through the
     * originator chain to find the original BeanDefinition as defined by the user.
     */
    @Override
    @Nullable
    public BeanDefinition getOriginatingBeanDefinition() {
        return (this.resource instanceof BeanDefinitionResource ?
                ((BeanDefinitionResource) this.resource).getBeanDefinition() : null);
    }

    /**
     * Validate this bean definition.
     * @throws BeanDefinitionValidationException in case of validation failure
     */
    public void validate() throws BeanDefinitionValidationException {
        if (hasMethodOverrides() &amp;amp;&amp;amp; getFactoryMethodName() != null) {
            throw new BeanDefinitionValidationException(
                    &amp;quot;Cannot combine static factory method with method overrides: &amp;quot; +
                    &amp;quot;the static factory method must create the instance&amp;quot;);
        }

        if (hasBeanClass()) {
            prepareMethodOverrides();
        }
    }

    /**
     * Validate and prepare the method overrides defined for this bean.
     * Checks for existence of a method with the specified name.
     * @throws BeanDefinitionValidationException in case of validation failure
     */
    public void prepareMethodOverrides() throws BeanDefinitionValidationException {
        // Check that lookup methods exists.
        if (hasMethodOverrides()) {
            Set&amp;lt;MethodOverride&amp;gt; overrides = getMethodOverrides().getOverrides();
            synchronized (overrides) {
                for (MethodOverride mo : overrides) {
                    prepareMethodOverride(mo);
                }
            }
        }
    }

    /**
     * Validate and prepare the given method override.
     * Checks for existence of a method with the specified name,
     * marking it as not overloaded if none found.
     * @param mo the MethodOverride object to validate
     * @throws BeanDefinitionValidationException in case of validation failure
     */
    protected void prepareMethodOverride(MethodOverride mo) throws BeanDefinitionValidationException {
        int count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());
        if (count == 0) {
            throw new BeanDefinitionValidationException(
                    &amp;quot;Invalid method override: no method with name &#39;&amp;quot; + mo.getMethodName() +
                    &amp;quot;&#39; on class [&amp;quot; + getBeanClassName() + &amp;quot;]&amp;quot;);
        }
        else if (count == 1) {
            // Mark override as not overloaded, to avoid the overhead of arg type checking.
            mo.setOverloaded(false);
        }
    }


    /**
     * Public declaration of Object&#39;s {@code clone()} method.
     * Delegates to {@link #cloneBeanDefinition()}.
     * @see Object#clone()
     */
    @Override
    public Object clone() {
        return cloneBeanDefinition();
    }

    /**
     * Clone this bean definition.
     * To be implemented by concrete subclasses.
     * @return the cloned bean definition object
     */
    public abstract AbstractBeanDefinition cloneBeanDefinition();

    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (!(other instanceof AbstractBeanDefinition)) {
            return false;
        }

        AbstractBeanDefinition that = (AbstractBeanDefinition) other;

        if (!ObjectUtils.nullSafeEquals(getBeanClassName(), that.getBeanClassName())) return false;
        if (!ObjectUtils.nullSafeEquals(this.scope, that.scope)) return false;
        if (this.abstractFlag != that.abstractFlag) return false;
        if (this.lazyInit != that.lazyInit) return false;

        if (this.autowireMode != that.autowireMode) return false;
        if (this.dependencyCheck != that.dependencyCheck) return false;
        if (!Arrays.equals(this.dependsOn, that.dependsOn)) return false;
        if (this.autowireCandidate != that.autowireCandidate) return false;
        if (!ObjectUtils.nullSafeEquals(this.qualifiers, that.qualifiers)) return false;
        if (this.primary != that.primary) return false;

        if (this.nonPublicAccessAllowed != that.nonPublicAccessAllowed) return false;
        if (this.lenientConstructorResolution != that.lenientConstructorResolution) return false;
        if (!ObjectUtils.nullSafeEquals(this.constructorArgumentValues, that.constructorArgumentValues)) return false;
        if (!ObjectUtils.nullSafeEquals(this.propertyValues, that.propertyValues)) return false;
        if (!ObjectUtils.nullSafeEquals(this.methodOverrides, that.methodOverrides)) return false;

        if (!ObjectUtils.nullSafeEquals(this.factoryBeanName, that.factoryBeanName)) return false;
        if (!ObjectUtils.nullSafeEquals(this.factoryMethodName, that.factoryMethodName)) return false;
        if (!ObjectUtils.nullSafeEquals(this.initMethodName, that.initMethodName)) return false;
        if (this.enforceInitMethod != that.enforceInitMethod) return false;
        if (!ObjectUtils.nullSafeEquals(this.destroyMethodName, that.destroyMethodName)) return false;
        if (this.enforceDestroyMethod != that.enforceDestroyMethod) return false;

        if (this.synthetic != that.synthetic) return false;
        if (this.role != that.role) return false;

        return super.equals(other);
    }

    @Override
    public int hashCode() {
        int hashCode = ObjectUtils.nullSafeHashCode(getBeanClassName());
        hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.scope);
        hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.constructorArgumentValues);
        hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.propertyValues);
        hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.factoryBeanName);
        hashCode = 29 * hashCode + ObjectUtils.nullSafeHashCode(this.factoryMethodName);
        hashCode = 29 * hashCode + super.hashCode();
        return hashCode;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder(&amp;quot;class [&amp;quot;);
        sb.append(getBeanClassName()).append(&amp;quot;]&amp;quot;);
        sb.append(&amp;quot;; scope=&amp;quot;).append(this.scope);
        sb.append(&amp;quot;; abstract=&amp;quot;).append(this.abstractFlag);
        sb.append(&amp;quot;; lazyInit=&amp;quot;).append(this.lazyInit);
        sb.append(&amp;quot;; autowireMode=&amp;quot;).append(this.autowireMode);
        sb.append(&amp;quot;; dependencyCheck=&amp;quot;).append(this.dependencyCheck);
        sb.append(&amp;quot;; autowireCandidate=&amp;quot;).append(this.autowireCandidate);
        sb.append(&amp;quot;; primary=&amp;quot;).append(this.primary);
        sb.append(&amp;quot;; factoryBeanName=&amp;quot;).append(this.factoryBeanName);
        sb.append(&amp;quot;; factoryMethodName=&amp;quot;).append(this.factoryMethodName);
        sb.append(&amp;quot;; initMethodName=&amp;quot;).append(this.initMethodName);
        sb.append(&amp;quot;; destroyMethodName=&amp;quot;).append(this.destroyMethodName);
        if (this.resource != null) {
            sb.append(&amp;quot;; defined in &amp;quot;).append(this.resource.getDescription());
        }
        return sb.toString();
    }

}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>《Spring源码深度解析》读后感(一)Spring的容器Bean</title>
        <link>https://lllovol.com/p/spring-source-code/</link>
        <pubDate>Tue, 15 Jan 2019 17:06:53 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring-source-code/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/8.jpg" alt="Featured image of post 《Spring源码深度解析》读后感(一)Spring的容器Bean" /&gt;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;这个系列主要是用来记录自己读这本书的一些笔记和想法的记录，不过买书好像买错了，应该买spring boot的相关解读的书籍，这是spring的深入解读的书。吃了一亏，不过这也是spring boot的前身，其中的源码也是有价值的。&lt;br&gt;
首先开始的，是整个spring当中最核心的用法，但是却十分重要的一个部分&amp;ndash;容器。大道至简，大音希声。&lt;/p&gt;
&lt;h1 id=&#34;容器的基本用法&#34;&gt;容器的基本用法&lt;/h1&gt;
&lt;p&gt;bean是spring中最核心的东西，因为spring就像一个大水桶，而bean就像是水桶中的水，水桶脱离了水便没有了什么用处。而spring 的目的，就是让我们的bean，能够成为纯粹的POJO（plain ordinary java object）。
需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个成员属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个属性的getter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个属性的setter
然后在配置文件xml当中添加相关的bean&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;bean id=&amp;quot;myTestBean&amp;quot; class=&amp;quot;bean.MyTestBean&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后就可以在测试代码中使用我们所测试的bean了&lt;/p&gt;
&lt;h1 id=&#34;容器的基础xmlbeanfactory&#34;&gt;容器的基础XmlBeanFactory&lt;/h1&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    BeanFactory bf= new XmlBeanFactory(new ClassPathResource(&amp;quot;beanFactoryTest.xml&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实现流程&#34;&gt;实现流程&lt;/h2&gt;
&lt;h3 id=&#34;首先调用了classpathresource的构造函数&#34;&gt;首先调用了ClassPathResource的构造函数&lt;/h3&gt;
&lt;p&gt;来构造了Resource资源文件的实例对象，然后后续的资源处理就可以使用Resource提供的各种服务来操作了。然后当我们有了Resource之后，就可以进行XmlBeanFactory的初始化了。&lt;br&gt;
与之同理，对于不同来源的资源文件都有相应的Resource实现。有了Resource接口之后便可以对所有资源文件进行统一的处理。例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    Resource resource=new ClassPathResource(&amp;quot;beanFactoryTest.xml&amp;quot;);
    InputStream inputStream=resource.getInputStream();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;xmlbeandefinition&#34;&gt;XmlBeanDefinition&lt;/h3&gt;
&lt;p&gt;然后，当Resource的相关类完成了对配置文件进行封住后配置文件的读取工作就全权交给XmlBeanDefinition来处理了。&lt;br&gt;
（ignoreDependencyInterface（）函数的主要功能是忽略给定接口的自动装配功能）  (时序图书 p20)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;封装资源文件。&lt;/li&gt;
&lt;li&gt;获取输入流&lt;/li&gt;
&lt;li&gt;通过构造的InputSource实例和Resource实例继续调用函数doLoadbeanDefinitions&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;支撑着整个spring容器部分的实现基础&#34;&gt;支撑着整个Spring容器部分的实现基础&lt;/h3&gt;
&lt;p&gt;然后就是3个步骤，支撑着整个Spring容器部分的实现基础&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;获取对XML文件的验证模式&lt;/li&gt;
&lt;li&gt;加载XML文件，并得到对应的Document&lt;/li&gt;
&lt;li&gt;根据返回的Document注册Bean信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;doregisterbeandefinitionsroot&#34;&gt;doRegisterBeanDefinitions(root)&lt;/h3&gt;
&lt;p&gt;然后，又通过一系列的处理之后，终于可以到了核心逻辑的底部doRegisterBeanDefinitions(root)&lt;br&gt;
终于开始真正的解析了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理profile（profile可以让我们在配置文件中部署配置两套配置来适用于测试环境和开发环境，在springboot中变成了bootstrap.yml中的一种属性）&lt;/li&gt;
&lt;li&gt;模板模式的使用（解析前后的函数preProcessXml（）和postProcessXml（）并没有实现，顺便复习一下面向对象的三大特性：封装多态继承，五大原则：单一功能原则，开闭原则，里氏代换原则，依赖原则，接口分离原则，迪米特原则）&lt;/li&gt;
&lt;li&gt;pariseBeanDefinitions方法来对bean进行解析，然后并注册BeanDefinition&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为在Spring中的xml配置中有两大类Bean的声明：默认的和自定义的。在以后的文章中将会提及。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(六)JPA</title>
        <link>https://lllovol.com/p/spring6/</link>
        <pubDate>Tue, 08 Jan 2019 10:51:00 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring6/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/7.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(六)JPA" /&gt;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;本文主要总结于如下的官方文档的部分内容，如有翻译不当理解不当的地方，欢迎留言指正&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://spring.io/docs&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring官方文档&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring-data/jdbc/docs/1.0.3.RELEASE/reference/html/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring JDBC官方文档&lt;/a&gt;&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring-data/mongodb/docs/2.1.3.RELEASE/reference/html/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring MongoDB官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;jpa&#34;&gt;JPA&lt;/h1&gt;
&lt;p&gt;JAVA Persistence API，java持久化的api&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JPA的主要目标之一就是提供更加简单的编程模型：在JPA框架下创建实体和创建Java 类一样简单，没有任何的约束和限制，只需要使用 javax.persistence.Entity进行注释，JPA的框架和接口也都非常简单，没有太多特别的规则和设计模式的要求，开发者可以很容易地掌握。JPA基于非侵入式原则设计，因此可以很容易地和其它框架或者容器集成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;mongodb与jdbc&#34;&gt;MongoDB与JDBC&lt;/h1&gt;
&lt;p&gt;mongoDB和JDBC（JAVA DATABASE CONNECTIVITY）最顶级的抽象类CrudRepository有很多相似的地方，下面就来看看CrudRepository和MongoRepository的对比，根据源码来看看两者之间的关系&lt;/p&gt;
&lt;h3 id=&#34;mongorepository&#34;&gt;MongoRepository&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;@NoRepositoryBean
public interface MongoRepository&amp;lt;T, ID&amp;gt; extends PagingAndSortingRepository&amp;lt;T, ID&amp;gt;, QueryByExampleExecutor&amp;lt;T&amp;gt; {

	@Override
	&amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; saveAll(Iterable&amp;lt;S&amp;gt; entites);

	@Override
	List&amp;lt;T&amp;gt; findAll();

	@Override
	List&amp;lt;T&amp;gt; findAll(Sort sort);

	&amp;lt;S extends T&amp;gt; S insert(S entity);

	&amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; insert(Iterable&amp;lt;S&amp;gt; entities);

	@Override
	&amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; example);

	@Override
	&amp;lt;S extends T&amp;gt; List&amp;lt;S&amp;gt; findAll(Example&amp;lt;S&amp;gt; example, Sort sort);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;crudrepository&#34;&gt;CrudRepository&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public interface CrudRepository&amp;lt;T, ID extends Serializable&amp;gt;
  extends Repository&amp;lt;T, ID&amp;gt; {

  &amp;lt;S extends T&amp;gt; S save(S entity);      

  Optional&amp;lt;T&amp;gt; findById(ID primaryKey);

  Iterable&amp;lt;T&amp;gt; findAll();               

  long count();                        

  void delete(T entity);               

  boolean existsById(ID primaryKey);   

  // … more functionality omitted.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两者的接口函数真的很相似&lt;br&gt;
如果继续往上追根溯源，我们会发现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface MongoRepository&amp;lt;T, ID&amp;gt; extends PagingAndSortingRepository&amp;lt;T, ID&amp;gt;, QueryByExampleExecutor&amp;lt;T&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;MongoRepository继承了PagingAndSortingRepository这个接口，这个接口主要是用来实现查询的分页的功能，点进去再仔细一看，就会发现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface PagingAndSortingRepository&amp;lt;T, ID&amp;gt; extends CrudRepository&amp;lt;T, ID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候，就会发现MongoRepository的最上层，就是CrudRepository，由此可见，CrudRepository就是MongoRepository的最上层的抽象类，因此两者之间有这么多相似的地方也就没有什么奇怪了。但是因为MongoDb是一种非关系型的数据库，因此实现的方式才会有所区别。&lt;/p&gt;
&lt;h1 id=&#34;crudrepository派生的查询derive的-query&#34;&gt;CrudRepository派生的查询（Derive的 Query）&lt;/h1&gt;
&lt;p&gt;在CrudRepository中有派生的count以及派生的delete等其他的查询，这样可以通过自定义的驼峰的形式来进行的CRUD等操作。&lt;/p&gt;
&lt;h3 id=&#34;derived-count-query&#34;&gt;Derived Count Query&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;interface UserRepository extends CrudRepository&amp;lt;User, Long&amp;gt; {
    long countByLastname(String lastname);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;derived-delete-query&#34;&gt;Derived Delete Query&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;interface UserRepository extends CrudRepository&amp;lt;User, Long&amp;gt; {
    long deleteByLastname(String lastname);
    List&amp;lt;User&amp;gt; removeByLastname(String lastname);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;mongorepository中派生的查询&#34;&gt;MongoRepository中派生的查询&lt;/h1&gt;
&lt;p&gt;既然MongoRepository是CrudRepository的派生类，那么应该也可以实现相应的派生的自定义的CRUD操作&lt;br&gt;
这个Repository proxy有两种方式来派生出来查询的query&lt;/p&gt;
&lt;h2 id=&#34;使用name来生成query&#34;&gt;使用Name来生成Query&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;By deriving the query from the method name directly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public interface CustomProjectRepo extends MongoRepository&amp;lt;CustomProject,Integer&amp;gt; {
    List&amp;lt;CustomProject&amp;gt; findByIdInAndNameRegex(List&amp;lt;Integer&amp;gt; ids, String name);
    List&amp;lt;CustomProject&amp;gt; findByIdIn(List&amp;lt;Integer&amp;gt; ids);
    List&amp;lt;CustomProject&amp;gt; findByName(String name);
    Optional&amp;lt;CustomProject&amp;gt; findByPathWithNamespace(String pathWithNamespace);
    List&amp;lt;CustomProject&amp;gt; findByNamespaceIdIn(List&amp;lt;Integer&amp;gt; groupIds);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无需自己另外实现，函数会自行的解析，重上到下的依次实现的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id在ids中，并且名字符合name的正则的的CustomProject&lt;/li&gt;
&lt;li&gt;id在ids中的CustomProject&lt;/li&gt;
&lt;li&gt;找到对应name的CustomProject&lt;/li&gt;
&lt;li&gt;找到指定pathWithNamespace的CustomProject&lt;/li&gt;
&lt;li&gt;找到namespaceId匹配groupIds中的CustomProject&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基本用法&#34;&gt;基本用法&lt;/h3&gt;
&lt;p&gt;这种机制来创造MongoDB Query,很方便，只需要相应的前缀加上相应的名字，使用java标准的命名方式（驼峰的方式）,该机制就会自动的开始解析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;find&amp;hellip;By&lt;/li&gt;
&lt;li&gt;read&amp;hellip;By&lt;/li&gt;
&lt;li&gt;query&amp;hellip;By&lt;/li&gt;
&lt;li&gt;get&amp;hellip;By&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，这些语句还能够包含其他更加深层次的表达式，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Distinct 去重&lt;/li&gt;
&lt;li&gt;IgnoreCase 无视大小写&lt;/li&gt;
&lt;li&gt;OrderBy&amp;hellip;Asc 按照某个属性升序&lt;/li&gt;
&lt;li&gt;OrderBy&amp;hellip;Desc 按照某个属性降序&lt;/li&gt;
&lt;li&gt;Between 在&amp;hellip;之间&lt;/li&gt;
&lt;li&gt;LessThan 少于&lt;/li&gt;
&lt;li&gt;GreaterThan 多于&lt;/li&gt;
&lt;li&gt;Like 模糊查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个By是当做最基础的查询语句的基础，除此之外，还可以使用And和Or来连接表达式&lt;/p&gt;
&lt;h3 id=&#34;歧义处理&#34;&gt;歧义处理&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Person&amp;gt; findByAddressZipCode(ZipCode zipCode);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能会被解析成AddressZipCode当成一个字段，AddressZip Code,也有可能Address ZipCode.为了解决这种歧义，MongoRepository使用了下划线来手动设置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;List&amp;lt;Person&amp;gt; findByAddress_ZipCode(ZipCode zipCode);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这也是为什么下划线被设置成了保留字，而推荐用户使用标准java命名方式的原因&lt;/p&gt;
&lt;h3 id=&#34;特殊参数处理&#34;&gt;特殊参数处理&lt;/h3&gt;
&lt;p&gt;可以传入特殊的参数，比如Pageable和sort,可以动态的设置分页和排序，例子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Page&amp;lt;User&amp;gt; findByLastname(String lastname, Pageable pageable);

Slice&amp;lt;User&amp;gt; findByLastname(String lastname, Pageable pageable);

List&amp;lt;User&amp;gt; findByLastname(String lastname, Sort sort);

List&amp;lt;User&amp;gt; findByLastname(String lastname, Pageable pageable);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一种返回page的方式在查询的结果集比较庞大的时候，代价也就会特别大，因此可以选择返回Slice,Slice可以知道下一个slice是否是有用的，能够在大的数量级下产生作用。&lt;/p&gt;
&lt;h3 id=&#34;限制结果集的数量&#34;&gt;限制结果集的数量&lt;/h3&gt;
&lt;p&gt;就像在数据查询的时候，可以查第一条或者若干条和最上面的一条或者若干条，MongoDBRepository也可以实现这个功能，同时也可以实现分页和排序的功能&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;User findFirstByOrderByLastnameAsc();

User findTopByOrderByAgeDesc();

Page&amp;lt;User&amp;gt; queryFirst10ByLastname(String lastname, Pageable pageable);

Slice&amp;lt;User&amp;gt; findTop3ByLastname(String lastname, Pageable pageable);

List&amp;lt;User&amp;gt; findFirst10ByLastname(String lastname, Sort sort);

List&amp;lt;User&amp;gt; findTop10ByLastname(String lastname, Pageable pageable);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;手动定义来生成query&#34;&gt;手动定义来生成Query&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This section covers repository customization and how fragments form a composite repository.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当需要的方法不能直接通过派生的机制直接派生的时候，就需要自己手动定义了，步骤如下&lt;/p&gt;
&lt;h3 id=&#34;定义自定义接口&#34;&gt;定义自定义接口&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;interface CustomizedUserRepository {
  void someCustomMethod(User user);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实现自定义接口中的函数&#34;&gt;实现自定义接口中的函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;class CustomizedUserRepositoryImpl implements CustomizedUserRepository {
  public void someCustomMethod(User user) {
  // Your custom implementation
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;原始库的修改&#34;&gt;原始库的修改&lt;/h3&gt;
&lt;p&gt;集成自定义的接口即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface UserRepository extends CrudRepository&amp;lt;User, Long&amp;gt;, CustomizedUserRepository {
// Declare query methods here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;还有MongoTemplate的方式来实现各种Query，但是由于工作中遇到过了一次bug，mongo中的其中一个库的数据突然不见了，由于mongo没有什么特定的sql语句可以查询，而且使用的是mongoTemplate，出现的地方很多，排查bug的时候耗费了很大的精力。从那之后，前辈就推荐使用repo的方式来进行对mongoDB的Crud操作了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(五)String、StringBuffer和StringBuilder、</title>
        <link>https://lllovol.com/p/spring5/</link>
        <pubDate>Sat, 05 Jan 2019 17:05:33 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring5/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(五)String、StringBuffer和StringBuilder、" /&gt;&lt;h1 id=&#34;code-review&#34;&gt;Code Review&lt;/h1&gt;
&lt;p&gt;这一周主要是一个前辈的code Review，在此期间能学到很多新的东西，也能看到自己的不足&lt;/p&gt;
&lt;h1 id=&#34;变量名的命名&#34;&gt;变量名的命名&lt;/h1&gt;
&lt;p&gt;禁止使用拼音，真的显得很没有水平，而且可读性会非常差，除非这个对象真的只有拼音名字&lt;/p&gt;
&lt;h1 id=&#34;关于异常的抛出&#34;&gt;关于异常的抛出&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;异常不要怕抛出的多，有异常一定要打出来，不然出了错都不知道是什么地方出的错&lt;/li&gt;
&lt;li&gt;禁止一个Exception就把一大段代码的所有异常给吞了&lt;/li&gt;
&lt;li&gt;异常一定要用log.error()将栈给打出来&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;stringbufferstringbuilder和string&#34;&gt;StringBuffer、StringBuilder和String&lt;/h1&gt;
&lt;h3 id=&#34;运行速度执行速度在这方面运行速度快慢为stringbuilder--stringbuffer--string&#34;&gt;运行速度：执行速度，在这方面运行速度快慢为：StringBuilder &amp;gt; StringBuffer &amp;gt; String&lt;/h3&gt;
&lt;p&gt;String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String str=&amp;quot;abc&amp;quot;+&amp;quot;de&amp;quot;;
StringBuilder stringBuilder=new StringBuilder().append(&amp;quot;abc&amp;quot;).append(&amp;quot;de&amp;quot;);
System.out.println(str);
System.out.println(stringBuilder.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种情况下除外，String的速度会比StringBuilder要快，因为第一行等价于String str=&amp;ldquo;abcde&amp;rdquo;。&lt;/p&gt;
&lt;h3 id=&#34;在线程安全上stringbuilder是线程不安全的而stringbuffer是线程安全的&#34;&gt;在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的&lt;/h3&gt;
&lt;p&gt;如果一个StringBuffer对象在字符串缓冲区被多个线程使用时，StringBuffer中很多方法可以带有synchronized关键字，所以可以保证线程是安全的，但StringBuilder的方法则没有该关键字，所以不能保证线程安全，有可能会出现一些错误的操作。所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。&lt;/p&gt;
&lt;h3 id=&#34;使用的情况&#34;&gt;使用的情况&lt;/h3&gt;
&lt;p&gt;String：适用于少量的字符串操作的情况&lt;br&gt;
StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况&lt;br&gt;
StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况&lt;/p&gt;
&lt;h1 id=&#34;代码复用性&#34;&gt;代码复用性&lt;/h1&gt;
&lt;p&gt;都是http的请求的话，封装成一个功能函数就好了，不用每次都写一个http的函数，复用性太低。而且最好的方式是使用feign的方式，更加的漂亮&lt;/p&gt;
&lt;h1 id=&#34;正则和alike有什么区别吗&#34;&gt;正则和alike有什么区别吗？&lt;/h1&gt;
&lt;p&gt;好像用alike好一点，但是mongo里面好像只有正则，其实都可以&lt;/p&gt;
&lt;h1 id=&#34;stream流的方式&#34;&gt;Stream流的方式&lt;/h1&gt;
&lt;p&gt;主要用在将一个list转成另外一个list或者map转map的时候用的，入参一个，出参一个
list.stream().map（）使用java的，都能实现，主要是map可以不用写那么多代码。map(CustomVersion::new).collect(Collectors.toList());
这个new 就是要创造一个传入的参数的构造函数&lt;/p&gt;
&lt;h1 id=&#34;数据库的crud&#34;&gt;数据库的CRUD&lt;/h1&gt;
&lt;h3 id=&#34;查询的时候注意&#34;&gt;查询的时候注意&lt;/h3&gt;
&lt;p&gt;不建议使用findAll，最好做一个分页，看一下表有多大，除非是表小，而且不会有爆炸性的数据增长的时候可以用。其他时候最好都有分页&lt;/p&gt;
&lt;h3 id=&#34;删除的时候&#34;&gt;删除的时候&lt;/h3&gt;
&lt;p&gt;最好是确认了可以保存了，然后再去删，这个，不应该一来就删了&lt;/p&gt;
&lt;h1 id=&#34;profile&#34;&gt;profile&lt;/h1&gt;
&lt;p&gt;想了解应用运行的状态，在什么环境下的，应该去看activity的profile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;spring:
  profiles:
    active: debug
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面是在bootstrap.yml中的，下面是如何使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Value(&amp;quot;${spring.profiles.active}&amp;quot;)
String active;
log.info(&amp;quot;start kubernetes watch,active:{}&amp;quot;,active);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;将mongotemplate改为repo的形式&#34;&gt;将mongoTemplate改为repo的形式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring-data/mongodb/docs/2.1.3.RELEASE/reference/html/#repositories.query-methods.query-creation&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相当的方便，好处就是出问题的时候，可以找到对应的表的对应的repo类，快速排查问题。&lt;br&gt;
如果想要自定义函数的话，需要自定义一个接口，再实现之后，用repo来继承自定义的接口。&lt;br&gt;
如果直接实现repo的接口的话，需要重写很多函数。&lt;/p&gt;
&lt;p&gt;在实现的时候部分代码，记得加上上面的两个注解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Repository
@RequiredArgsConstructor
public class CustomizeProjectRepoImpl implements CustomizeProjectRepo {
  @Autowired
  MongoTemplate mongoTemplate;
  @Override
  public void updateDeployToYesByIds(List&amp;lt;Integer&amp;gt; ids) {
      Query query = Query.query(Criteria.where(&amp;quot;id&amp;quot;).in(ids));
      Update update = Update.update(&amp;quot;deployOrNot&amp;quot;, YesOrNot.YES.getValue());
      mongoTemplate.updateMulti(query, update, CustomProject.class);
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(四)CR笔记ApplicationListener等等</title>
        <link>https://lllovol.com/p/spring4/</link>
        <pubDate>Fri, 28 Dec 2018 17:12:32 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring4/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/5.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(四)CR笔记ApplicationListener等等" /&gt;&lt;h1 id=&#34;code-review&#34;&gt;Code Review&lt;/h1&gt;
&lt;p&gt;这周被点名来做code view了来着，然后昨天晚上做了一个小时的code review，还是相当紧张，然后今天改了一天代码 特此总结&lt;/p&gt;
&lt;h1 id=&#34;applicationlistener&#34;&gt;ApplicationListener&lt;/h1&gt;
&lt;p&gt;这个地方原来主要实现的功能是spring3中的功能，在启动了整个项目之后，让watch pods和watch service启动并且只启动一次。&lt;br&gt;
（启动一个单线程，回调函数，生命周期）
原来的做法是使用spring task在应用启动之后，就启动一次然后一直运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//    @Scheduled(cron = &amp;quot;${schedule.kubeService}&amp;quot;)
    @Scheduled(fixedDelay = 999999999)
    protected void gitlabProjectTask() {
        kubernetesService.collectServices();
        customServiceService.bindServiceAndProject();
        kubernetesService.watchServices();
    }

//    @Scheduled(cron = &amp;quot;${schedule.kubePod}&amp;quot;)
//    @Scheduled(cron = &amp;quot;0 0,14 6,18 * * ? &amp;quot;)
    //taskexecutor
//    ScheduledExecutorTask
//    new 一个单线程一直跑就可以了
    @Scheduled(fixedDelay = 999999999)
    public void collectPod() {
        kubernetesService.collectPods();
        kubernetesService.watchPods();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在使用的是ApplicationListener&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class KubernetesServiceImpl implements KubernetesService, ApplicationListener&amp;lt;ApplicationReadyEvent&amp;gt; {
 //生命周期
    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        collectServices();
        customServiceService.bindServiceAndProject();
        watchServices();

        collectPods();
        watchPods();

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样既可&lt;br&gt;
这样就可以在线程启动的时候异步的启动这些服务&lt;br&gt;
使用注解（to do）或者继承ApplicationListener&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h1 id=&#34;mongodb的修改操作方式&#34;&gt;MongoDB的修改操作方式&lt;/h1&gt;
&lt;p&gt;在修改mongoTemplate的update的时候，会发现使用update的话，会需要修改很多的key值，这样的操作不如直接全部删了然后全部再加进去&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Query query = Query.query(Criteria.where(&amp;quot;classId&amp;quot;).is(&amp;quot;1&amp;quot;));
Student student = new Student(&amp;quot;1&amp;quot;, &amp;quot;lisi&amp;quot;, 18, &amp;quot;man&amp;quot;);
Update update = new Update();
//update.push(&amp;quot;Students&amp;quot;, student);
update.addToSet(&amp;quot;Students&amp;quot;, student);
mongoTemplate.upsert(query, update, &amp;quot;class&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;使用strings的时候nullorempty的判断&#34;&gt;使用Strings的时候nullOrEmpty的判断&lt;/h1&gt;
&lt;p&gt;Strings.isNullOrEmpty(username)&lt;br&gt;
推荐使用的是Apache的StringUtil或者google的&lt;br&gt;
不能使用 username.equals(&amp;quot;&amp;quot;)&lt;/p&gt;
&lt;h1 id=&#34;如何只在debug的时候才开始打印日志&#34;&gt;如何只在debug的时候才开始打印日志&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;log.debug(&amp;quot;user: {}&amp;quot;, username);
if (log.isDebugEnabled()) {
    for (Map.Entry&amp;lt;String, CustomServiceDeployDto&amp;gt; stringCustomServiceDeployDtoEntry : serviceAndTag.entrySet()) {
        log.debug(&amp;quot;      service and tags: {}&amp;quot;, JSONObject.toJSON(stringCustomServiceDeployDtoEntry));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;泛型警告的问题&#34;&gt;泛型警告的问题&lt;/h1&gt;
&lt;p&gt;将redisTemplate修改为StringRedisTemplate&lt;/p&gt;
&lt;h1 id=&#34;返回空的集合应该使用&#34;&gt;返回空的集合应该使用&lt;/h1&gt;
&lt;p&gt;Collections.emptyList()&lt;/p&gt;
&lt;h1 id=&#34;bug修复&#34;&gt;bug修复&lt;/h1&gt;
&lt;p&gt;历史记录刷新的时候，value是一个map，而map中的service的值没有&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(三)KubernetesClient的使用与配置</title>
        <link>https://lllovol.com/p/spring3/</link>
        <pubDate>Tue, 25 Dec 2018 15:08:35 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring3/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/4.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(三)KubernetesClient的使用与配置" /&gt;&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近主要在获取到的k8s中的相关service和pod的信息的变化，将原来全量获取数据的方式改进为增量的方式，此篇主要记录使用过程中遇到的坑和相信的解决方式&lt;/p&gt;
&lt;h2 id=&#34;kubernetesclient的包的依赖的引用&#34;&gt;KubernetesClient的包的依赖的引用&lt;/h2&gt;
&lt;p&gt;使用的是fabric8的kubernetes-client，添加如下依赖即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--在pom.xml文件--&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;io.fabric8&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;kubernetes-client&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;4.0.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置文件配置相关的属性&#34;&gt;配置文件配置相关的属性&lt;/h2&gt;
&lt;h3 id=&#34;applicationyml文件&#34;&gt;application.yml文件&lt;/h3&gt;
&lt;p&gt;添加k8s集群的主机url,token&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;api:
  server:
    k8s:
      key: &amp;quot;kubernetes.auth.token&amp;quot;
      token: &amp;quot;***********************************&amp;quot;
      url: &amp;quot;https://10.0.0.0:6443&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里就有一个坑，就是这个token,由于kubernetes的安全机制，原来获取到的token都只有一天的时效，第二天都需要重新更新一个新的token&lt;br&gt;
这样是肯定不行的，解决的方式有大概下面几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用证书的方式，需要三个文件，CaCertFile,ClientCertFile,ClientKeyFile&lt;/li&gt;
&lt;li&gt;获取一种长效的永久的token，这个需要的权限比较高，需要找到kubernetes的负责人，拥有的权限比较高的人&lt;br&gt;
（查看本地的token,cd ~/.kube,然后cat config,就能看到自己本地的token）&lt;/li&gt;
&lt;li&gt;使用账号密码进行登录&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;configuration的实现&#34;&gt;configuration的实现&lt;/h3&gt;
&lt;p&gt;在configuration文件夹下面新建一个class，取名为KubernetesConfig&lt;br&gt;
主要文件内容如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Setter
@Configuration
@ConfigurationProperties(prefix = &amp;quot;api.server&amp;quot;)
public class KubernetesConfig {
    private K8s k8s;

    private static final int REQUEST_TIMEOUT = 3 * 1000;
    private static final int CONNECTION_TIMEOUT = 3 * 1000;

    @Bean(&amp;quot;kubernetesClient&amp;quot;)
    public KubernetesClient kubernetesClient() {
        Config config = new ConfigBuilder()
                .withMasterUrl(k8s.getUrl())
                .withOauthToken(k8s.getToken())
                .withTrustCerts(true)
                .removeFromTlsVersions(TlsVersion.TLS_1_0)
                .removeFromTlsVersions(TlsVersion.TLS_1_1)
                .removeFromTlsVersions(TlsVersion.TLS_1_2)
                .withRequestTimeout(REQUEST_TIMEOUT)
                .withConnectionTimeout(CONNECTION_TIMEOUT)
                .build();
        KubernetesClient client = new DefaultKubernetesClient(config);
        return client;
    }

    @Bean(&amp;quot;k8s&amp;quot;)
    public K8s getK8s() {
        return k8s;
    }

    @Setter
    @Getter
    public static class K8s {
        private String token;
        private String key;
        private String url;
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上是使用的是token的方式，进行的登录&lt;/p&gt;
&lt;h4 id=&#34;还可以使用证书的方式&#34;&gt;还可以使用证书的方式：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将需要的三个证书文件放到项目当中，右键copy path,然后删除src前面的路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将上面代码中的.withOauthToken(k8s.getToken())替换为&lt;/p&gt;
&lt;p&gt;.withCaCertFile(&amp;ldquo;src/main/resources/CaCert.crt&amp;rdquo;)&lt;br&gt;
.withClientCertFile(&amp;ldquo;src/main/resources/ClientCert.crt&amp;rdquo;)&lt;br&gt;
.withClientKeyFile(&amp;ldquo;src/main/resources/ClientKey.key&amp;rdquo;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;还可以使用账号密码的方式进行登录&#34;&gt;还可以使用账号密码的方式进行登录：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将上面代码中的.withOauthToken(k8s.getToken())替换为&lt;/p&gt;
&lt;p&gt;.withUsername(&amp;ldquo;username&amp;rdquo;)&lt;br&gt;
.withPassword(&amp;ldquo;password&amp;rdquo;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用kubernetesclient实现watch的功能&#34;&gt;使用KubernetesClient实现watch的功能&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;kubernetesClient.services().inAnyNamespace().watch(new Watcher&amp;lt;Service&amp;gt;() {
      @Override
      public void eventReceived(Action action, Service service) {
          log.debug(&amp;quot;service watch action:{}&amp;quot;,action);
          log.debug(&amp;quot;service watch service:{}&amp;quot;,service.toString());
          log.debug(&amp;quot;                                            &amp;quot;);
      }

      @Override
      public void onClose(KubernetesClientException e) {

      }
  });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要的功能实现都在这个event类中实现了，如果想watch pod的话，只需要将services()换成pods()即可&lt;/p&gt;
&lt;h3 id=&#34;主要的坑是在何处实现&#34;&gt;主要的坑是在何处实现？&lt;/h3&gt;
&lt;p&gt;原本的kubernetes中相关的信息收集，是在定时任务中实现的&lt;br&gt;
但是kubernetes的watch就已经相当于是一个线程了，如果做到让这个功能随着服务的启动而直接就启动了呢？&lt;/p&gt;
&lt;p&gt;我的处理方式，依然是使用的定时任务，不过是将定时任务的时间，设置了一个特别长的间隔，这样就算是只启动了一次了&lt;br&gt;
代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Scheduled(fixedDelay = 999999999)
public void collectPod() {
    kubernetesService.watchPods();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(二)CR笔记</title>
        <link>https://lllovol.com/p/spring2/</link>
        <pubDate>Thu, 20 Dec 2018 20:01:33 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring2/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(二)CR笔记" /&gt;&lt;h1 id=&#34;code-review&#34;&gt;Code Review&lt;/h1&gt;
&lt;p&gt;让大家对代码质量的标准是在一个线上，
是一个相互学习的过程。
blog主要是用来记录当时的笔记与自己的一些感想&lt;/p&gt;
&lt;h4 id=&#34;用户中心的接口需要查用户之前捐过的一些订单&#34;&gt;用户中心的接口，需要查用户之前捐过的一些订单&lt;/h4&gt;
&lt;p&gt;ContextUtil.getUserId(()不建议使用
限制了使用线程的场景，可能每一段代码执行的线程可能不在一起了
讲究的是 变量来源应该是外部的,参数是传入的
swing local ？本地的东西 context 在子线程中是无法工作的，Util这个工具类，不应该涉及到线程这种复杂的东西&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interceptor， implements HandlerMethodargumentResolver，//可以直接解析参数（将token解析的过程，就放到这个里面了）
(@LoginUidAttribute String uid)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;拿到userid的isdelete可以不用判断&#34;&gt;拿到userId的，isDelete()可以不用判断&lt;/h4&gt;
&lt;h4 id=&#34;解决泛型warning-加t&#34;&gt;解决泛型，warning 加&lt;!-- raw HTML omitted --&gt;&lt;/h4&gt;
&lt;h4 id=&#34;pagehelper是用的swing-local&#34;&gt;PageHelper是用的swing local&lt;/h4&gt;
&lt;h4 id=&#34;mapper上面的select-一定要体现一个sql查询条件一定要解耦不要太复杂了&#34;&gt;mapper上面的select 一定要体现一个sql,查询条件一定要解耦，不要太复杂了&lt;/h4&gt;
&lt;p&gt;不要写太多的if
OrderBizMapper.xml 这样可以更好的去维护索引&lt;/p&gt;
&lt;h4 id=&#34;不建议使用copyproperties只要一个属性对不上可能就会&#34;&gt;不建议使用copyProperties，只要一个属性对不上可能就会&lt;/h4&gt;
&lt;h4 id=&#34;使用long不建议使用intjava中一直诟病的就是java中的对象看不出来到底是不是long-null&#34;&gt;使用long不建议使用int，java中一直诟病的，就是java中的对象看不出来到底是不是long null&lt;/h4&gt;
&lt;p&gt;新的语言都解决了 null会不会有问题的东西。
创建一个 optional&lt;!-- raw HTML omitted --&gt; 约定就是，可能为null
int 是不能为null的
interger是可以为null的
这样可以增加代码的意义的传递，这个就是一种约定
，使用原生的类型比较好&lt;/p&gt;
&lt;h4 id=&#34;链式的一个使用的方式每一个点放一个行因为一个点就表示一个操作了&#34;&gt;链式的一个使用的方式，每一个点放一个行,因为一个点就表示一个操作了&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;order.stream()
.map(OrderBizVo::new)
.collect(Collection.toList())这样会更加java 8一点
.map()
.distinct()
.collect(Collections.toList()) //就可以
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;返回给前端最好返回是一个空的集合而不是一个null这样前端会更好处理一点&#34;&gt;返回给前端最好返回是一个空的集合而不是一个null，这样前端会更好处理一点&lt;/h4&gt;
&lt;h4 id=&#34;每一个表建表的时候都需要加一个-isdelete&#34;&gt;每一个表建表的时候都需要加一个 isDelete&lt;/h4&gt;
&lt;h4 id=&#34;update-不涉及索引的不能一味使用&#34;&gt;update 不涉及索引的，不能一味使用&lt;/h4&gt;
&lt;h4 id=&#34;查sql一般不应该根据sql来加先是业务来看怎么查的冲突与建议查询的时候只能将sql交给dba沟通的简洁&#34;&gt;查sql，一般不应该根据sql来加，先是业务来看怎么查的？（冲突与建议）查询的时候只能将sql交给dba，沟通的简洁&lt;/h4&gt;
&lt;h4 id=&#34;连点增加锁的操作token不用放在数据库中这种没必要持久化的东西就放到redis中&#34;&gt;连点增加锁的操作，token不用放在数据库中，这种没必要持久化的东西，就放到redis中&lt;/h4&gt;
&lt;h4 id=&#34;为什么是double-check&#34;&gt;为什么是double check?&lt;/h4&gt;
&lt;p&gt;是处理单例的时候才会使用double check，早起的java处理指令重排的时候，会导致一个check会被跳过去的，所以才处理了double check
（在说什么？我怎么开始听不懂了），两次的话，就总有一次会成功&lt;/p&gt;
&lt;h4 id=&#34;eprintstacktrace是禁止的&#34;&gt;e.printStackTrace()是禁止的&lt;/h4&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;log.error(&amp;quot;&amp;quot;,{},e);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;token的延长时间&#34;&gt;token的延长时间&lt;/h4&gt;
&lt;p&gt;一个是长效token,一个是短效的token,这样子的话会更加安全一点&lt;/p&gt;
&lt;h4 id=&#34;左边代码行的地方右键使用annotation&#34;&gt;左边代码行的地方右键使用annotation&lt;/h4&gt;
&lt;p&gt;可以看见是谁写的代码
这个功能就很尴尬啊（原来是可以知道代码是谁写的啊）&lt;/p&gt;
&lt;h4 id=&#34;不要在异常中处理业务逻辑&#34;&gt;不要在异常中处理业务逻辑&lt;/h4&gt;
&lt;p&gt;每次抛异常的时候，会把栈中的东西都抛出去，使用runtimeException来处理（对性能要求高的时候，code优先，返回ErrorCode）&lt;/p&gt;
&lt;h4 id=&#34;批量长链接转短链接url&#34;&gt;批量长链接转短链接url&lt;/h4&gt;
&lt;p&gt;使用key value，放在redis中，同时可以存在db，在上边加一个缓存加一层redis
toC查询的过程&lt;/p&gt;
&lt;h4 id=&#34;连续插入&#34;&gt;连续插入&lt;/h4&gt;
&lt;p&gt;上一个请求insert来了，马上又来了一个
批量 insert ignore 就行了，插进去就行了
通过一个id，md5（效率很快）的碰撞概率，smartcode 短连接然后就可以返回给
这个算法的奥义是六位，然后保证不会重复&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The MD5 message-digest algorithm is a widely used hash function producing a 128-bit hash value. Although MD5 was initially designed to be used as a cryptographic hash function, it has been found to suffer from extensive vulnerabilities.
&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/MD5&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;我们尽量不要使用事物transaction并发性会很低&#34;&gt;我们尽量不要使用事物，transaction，并发性会很低&lt;/h4&gt;
&lt;p&gt;这是一定可以避免的，使用最终一致性
更新很多表的问题，应该很少出问题
后台打log,都会有专门的人来进行数据的修复，不要为了这个牺牲性能
（先跑，然后就人来修）
使用事物的话，还会对数据库造成锁的问题
事务的话应该尽量的小&lt;/p&gt;
&lt;h4 id=&#34;批量更新的建议&#34;&gt;批量更新的建议&lt;/h4&gt;
&lt;p&gt;整个这个东西，最开始的时候一定要分批的去搞
超过100个的时候就是一批？&lt;/p&gt;
&lt;h4 id=&#34;redis&#34;&gt;redis&lt;/h4&gt;
&lt;p&gt;redis 有pipeling来做，速度会比较快
zSet是排序，
mSet是大量的，但是好像没有超时的时间，
批量写缓存&lt;/p&gt;
&lt;h4 id=&#34;stringutils&#34;&gt;StringUtils&lt;/h4&gt;
&lt;p&gt;有isEmpty(),也有isNotEmpty()&lt;/p&gt;
</description>
        </item>
        <item>
        <title>SpringBoot开发中的一些小细节(一)Slf4J、Post和Get的小技巧</title>
        <link>https://lllovol.com/p/spring1/</link>
        <pubDate>Fri, 14 Dec 2018 19:13:00 +0000</pubDate>
        
        <guid>https://lllovol.com/p/spring1/</guid>
        <description>&lt;img src="https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/2.jpg" alt="Featured image of post SpringBoot开发中的一些小细节(一)Slf4J、Post和Get的小技巧" /&gt;&lt;p&gt;原来写的代码被CTO抓出来吐槽，发现确实都是一些当初自己没有注意到的地方，打算将这样的小细节一点一点的收集起来，养成更好的编码习惯。&lt;/p&gt;
&lt;h1 id=&#34;slf4j&#34;&gt;Slf4j&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at deployment time.
摘自https://www.slf4j.org/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在编写Spring的代码的时候，只需要在Class上方添加一个@Slf4j的注解即可。slf4j是facade pattern的典型例子（隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口，又被成为门面模式或者外观模式）
使用的时候，可以使用占位符的方式进行日志的记录，省去了原来自己拼接日志的麻烦。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    log.debug(&amp;quot;wxpushGet() returned: {}&amp;quot; ,result);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是有一些需要注意的地方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在日常开发调试的时候应该少用log.info()，而应该使用log.debug，不然在上线之后，就会产生很多冗余的信息。&lt;/li&gt;
&lt;li&gt;只有在线上部署的时候，关键代码的信息，才使用log.info(),来显示日志的信息。&lt;strong&gt;千万不能滥用！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在catch的抛出错误的时候，使用log.error()。会打印错误以及异常的信息&lt;/li&gt;
&lt;li&gt;log.warn(),用于打印潜在的用户的错误可能的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;dto等model的data注解&#34;&gt;Dto等model的@Data注解&lt;/h1&gt;
&lt;p&gt;@Data注解，可以实现类的Getter和Setter的同时还有toString方法，没有必要自己再转一次Json(如果只是打印个日志的话)，lombok生成的toString的可读性是很高的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lombok 是一种 Java™ 实用工具，可用来帮助开发人员消除 Java 的冗长，尤其是对于简单的 Java 对象（POJO Plain Ordinary Java Object）。它通过注解实现这一目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;rest的post和get&#34;&gt;Rest的post和get&lt;/h1&gt;
&lt;p&gt;rest风格不是随便使用get的(这是一个前辈给我说的，有次看了不少相关的文章和介绍，包括get和post到底有什么区别)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.ruanyifeng.com/blog/2011/09/restful.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;理解Restful架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.ruanyifeng.com/blog/2014/05/restful_api.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Restful Api 设计指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/l123649/article/details/79552299&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;get和post有什么区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.cnblogs.com/logsharing/p/8448446.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;get和post比较另类的区别（没有区别）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天前辈在看我的代码的时候，就问我为什么所有的都是get，说实话，当时的我真的是懵逼的。
我脑海中原来get和post区别大概如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get请求要比post快&lt;/li&gt;
&lt;li&gt;get用户可以直接修改参数，post是将数据放在request body中，稍微安全一点&lt;/li&gt;
&lt;li&gt;get一般是用来请求数据&lt;/li&gt;
&lt;li&gt;post一般是用来发送数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大概就是如上的内容了，然后在读完上面几篇文章后，又有了新的认识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get在浏览器回退的时候是无害的，而post会再次请求（应该就是返回上一页面的时候，get秒回，post会重新请求）&lt;/li&gt;
&lt;li&gt;get请求会被浏览器主动cache,而post不会，除非手动自己设置&lt;/li&gt;
&lt;li&gt;get请求只支持url的编码，而post支持多种编码的方式&lt;/li&gt;
&lt;li&gt;get请求的参数会被留在浏览器的历史记录当中，但是post不会&lt;/li&gt;
&lt;li&gt;get请求的参数有长度限制，但是post没有&lt;/li&gt;
&lt;li&gt;get只接受ASCII字符，而post没有限制&lt;/li&gt;
&lt;li&gt;get的参数会直接暴露在url上，因此不能用来传递敏感的信息&lt;/li&gt;
&lt;li&gt;get的参数通过url来传递，而post是直接放在request body当中的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的很多标准答案的概念，其实都是慢慢的通过人员长期使用形成了一部分思维定式，上面的文章之一的观点就有不同的见解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给post加上url传参，给get加上request body,在技术上都是可以实现的，只是不能通过浏览器实现，但是并不是所有的网络服务都是通过浏览器来的&lt;/li&gt;
&lt;li&gt;两者都是单纯的源于http协议，只有一丁点根本的区别，一个用于获取数据，一个用于修改数据&lt;/li&gt;
&lt;li&gt;get的长度限制，主要是浏览器服务器等，为了防止一些黑客的攻击来进行的限制，和get、post的无关。&lt;/li&gt;
&lt;li&gt;可以在get的车里放data,也可以在post车外面放data,但是这样很蠢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/SpringBoot%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e5%b0%8f%e7%bb%86%e8%8a%82%ef%bc%88%e4%b8%80%ef%bc%89_files/64122226.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;64122226.png&#34;
	
	
&gt;
&lt;img src=&#34;https://lllovol.oss-cn-beijing.aliyuncs.com/assets/img/SpringBoot%e5%bc%80%e5%8f%91%e4%b8%ad%e7%9a%84%e4%b8%80%e4%ba%9b%e5%b0%8f%e7%bb%86%e8%8a%82%ef%bc%88%e4%b8%80%ef%bc%89_files/64276701.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;64276701.png&#34;
	
	
&gt;&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
