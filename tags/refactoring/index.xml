<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Refactoring on lllovol</title>
    <link>https://lllovol.com/tags/refactoring/</link>
    <description>Recent content in Refactoring on lllovol</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 07 Dec 2021 21:05:58 +0000</lastBuildDate><atom:link href="https://lllovol.com/tags/refactoring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《重构》-重构的原则</title>
      <link>https://lllovol.com/p/2021/12/refactoring-principles/</link>
      <pubDate>Tue, 07 Dec 2021 21:05:58 +0000</pubDate>
      
      <guid>https://lllovol.com/p/2021/12/refactoring-principles/</guid>
      <description>前言 本文是一篇关于Martin Fowler《重构：改善既有代码的设计》的第二章读书笔记与总结。
何谓重构 很多一线的实践者会非常随意的使用重构这个词，但是作者会非常严谨地使用重构。
 重构（名词）：对软件内部的结构的一种调整，目的是在不改变可观察行为的前提下，提高其可理解性，降低其修改成本 重构（动词）：使用一系列重构手法，在不改变可观察行为的前提下，调整其结构。  重构的关键在于运用大量微且保持软件行为的步骤，一步步达成大规模的修改。 每个单独的重构呀么很小，要么由若干个小步骤组合而成。这样的好处是，即使重构没有完成，也可以在任何时刻停下来，代码很少进入到不可工作的状态。
重构与性能优化 二者有很多相似之处
 都需要修改代码 都不会改变程序的整体功能  区别
 重构是为了让代码更容易理解，更易于修改。这可能会让程序运行的更快，也可能运行的更慢。 性能优化时，只关心如何让代码程序运行得更快，最终得到的代码有可能更难理解和维护，对此需要有心理准备。  两顶帽子 Kent Beck提出了两顶帽子的比喻。使用重构技术进行软件开发是，可以把自己的时间分配给两种截然不同的行为：
 添加新功能：不应该修改既有的代码，只管添加新功能。同时需要添加测试并且让测试正常运行。 重构：不再添加新的功能，只调整代码的结构。此时不应该添加任何测试，只有在绝对必要的时候才修改测试。  但是在实际的开发过程当中，我实际会经常变换帽子：当我开始添加新功能时候，突然意识到如果把程序结构修改一下，功能添加会容易很多。于是就换上了一顶重构帽子，开始了一会的重构工作。当程序结构调整好了之后，又戴上了原来的帽子。
总之，整个过程中，无论何时何地，都要清楚当前的自己戴的帽子究竟是哪一个，并且了解不同的帽子对编程状态提出的不同的要求
为何重构 重构绝对不是包治百病的灵丹妙药，更不是所谓的“银弹”，但是绝对算是一把银钳子，可以帮你始终良好的控制自己的代码。 重构是一个工具，它能够用于以下几个目的：
重构改进软件的设计 如果没有重构，程序的内部设计（架构）会逐渐的腐败变质。当人们只为了短期目的而修改代码时，经常没有完全理解架构的整体设计，于是代码就逐渐失去了自己的结构。（屎山代码就是这么来的，但是没有办法避免） 越难看出代码的设计意图，就越难保护其设计，腐败的也就越快。经常的重构有助于代码为支持自己该有的形态。 同时，消除重复代码，就可以确定所有事物和行为在代码中只表述一次，这才是优秀设计的根本。
重构使软件更容易理解 虽然代码是在计算机上运行的，编程的核心就是“准确的说出我想要的”，但是除了计算机之外，源码还有其他读者，几个月之后可能会有另外以为程序员尝试读懂我的代码并且进行一些修改。我们很容易就忘记了这个读者，“又不是不能用”，然后这个代码就这么写出来了。而后人可能会花费很多时间来理解和阅读我的代码。
因此，我们需要改变一下开发的节奏，让代码变得更加易于理解。重构可以让代码更加易读。
做一个懒惰的程序员，表现形式之一就是，总是记不住自己写过的代码。对于任何能够立刻查阅的东西，都可以故意不去记它，别把自己的脑袋塞爆了。尽量把需要记住的东西写在代码里。
重构帮助找到bug 重构的时候，能够更加深入的理解代码的所做所谓，并立即把新的理解反映在代码当中。在弄清楚程序结构的同时，必须要做一些假设去验证，因此想不把bug找出来都难。
 Kent Beck：我不是一个特别好的程序员，我只是一个有一些特别好的习惯的还不错的程序员
 重构提高编程速度 最后，前面的一切都归结到了这一点: 重构能够帮助我们更快的开发程序。
这虽然有点违反直觉，因为重构本来就是一件耗费精力的事情。但是如果一个代码全靠补丁来不断的修复，最后就是补丁补补丁，需要考古学家才能弄清楚这个代码到底是怎么个回事。以至于最后，这个系统的负担会不断拖慢新增功能的速度，到最后程序员恨不得重头开始写整个系统。
如果代码很清晰，引入bug的可能性就会很小，即使引入的bug，调试和排查也会容易很多。理想情况下，我的代码库会逐渐严骅成为一个平台，在其上可以容易的构造与其领域相关的新功能。
 设计耐久性假说：通过投入精力改善内部设计，我们增加了软件的耐久性，从而可以更长时间的保持开发的快速。
 何时重构 编程的每个小时，都应该去做重构。有几种方式可以把重构融入工作过程中。
三次法则  第一次做某件事的时候尽管去做 第二次做类似的事情会产生方案，但是无论如何还是可以去去做 第三次再做类似的事情，就应该去重构  预备性重构：让添加新功能更容易 重构的最佳时机就是在添加新功能之前
帮助理解的重构：使代码更易懂 需要理解代码做什么才能着手修改
 比如看到一段迷惑的代码，自问，能不能重构它，让它看起来一目了然？ 看到结果糟糕的条件判断，想修改，发现函数命名太糟糕了？ 等等，都是重构的机会。哪怕只是修改函数的命名这类重构，只要能够更加清楚的表达出一图，都会是非常有意义的。这些初步的重构，就像是扫去窗上的灰尘，能够让我们看到窗外的风景。  捡垃圾式重构 可以把要重构的点记下来，把更紧急的事情处理之后，抽空来处理这些垃圾。积少成多</description>
    </item>
    
  </channel>
</rss>
